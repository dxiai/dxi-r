[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Einführung in die Datenwissenschaft mit R",
    "section": "",
    "text": "Vorwort\nWork in Progress\n\n\nCopyright\nDieses Werk ist lizenziert unter einer Creative Commons Namensnennung - Nicht-kommerziell - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz (CC-BY-NC-SA). Details zur Nutzungsbedingungen und dem Copyright finden sich unter createivecommons.org.\n2023, Christian Glahn, Zurich, Switzerland"
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#motivation-und-ausgangslage",
    "href": "kapitel/einleitung/kapitel.html#motivation-und-ausgangslage",
    "title": "1  Einleitung",
    "section": "1.1 Motivation und Ausgangslage",
    "text": "1.1 Motivation und Ausgangslage"
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#base-r-und-tidy-r",
    "href": "kapitel/einleitung/kapitel.html#base-r-und-tidy-r",
    "title": "1  Einleitung",
    "section": "1.2 Base R und Tidy R",
    "text": "1.2 Base R und Tidy R\nR ist eine Programmiersprache, die durch Funktionsbibliotheken erweitert wird. Beim Starten von R wird zuerst nur das Basissystem geladen. Das R-Basissystem besteht aus den eingebauten Sprachelementen und Funktionen sowie aus den Bibliotheken base, compiler, datasets, grDevices, graphics, grid, methods, parallel, splines, stats, stats4, tcltk, tools, translations, and utils. Alle Funktionen dieser Bibliotheken stehen damit nach dem Start von R sofort bereit. Diese Funktionen heissen im R-Jargon Base R. Dieses Basissystem stellt bereits alle Funktionen für das statistische Programmieren bereit.\nBase R verwendent sehr viele Idiome als Funktionsnamen, aus denen sich nicht intuitiv erschliesst, was eine Funktion leistet. Ausserdem wurden im Laufe der Entwicklung immer wieder Funktionen dem Basissystem hinzugefügt, die sich nicht konsistent in das bestehende System aus Funktionen integrieren. Als Beispiel sollen die Funktionen eapply(), lapply(), sapply(), tapply() und vapply() sowie replicate() und rep() dienen. Bis auf replicate() sehen die Funktionsnamen ähnlich aus, werden aber in unterschiedlichen Kontexten verwendet und auf unterschiedliche Weise aufgerufen. replicate() und rep() haben einen ähnlichen Funktionsnamen und in der Beschreibung dienen beide Funktionen der replikation. Die Funktion replicate() ist aber eine Variante der Funktion lapply() mit ähnlicher Syntax und rep() nicht.\nBeim Erlernen von Base R müssen die Kernsyntax der Programmiersprache, die Verwendung der Idiome mit ihren passenden Kontexten und Anwendungen sowie alle Widersprüche erlernt werden. Für Programmierneulinge erscheinen Programme in Base R sehr kyptisch und wenig intuitiv. Selbst erfahrenen R-Entwickler:innen erschliesst sich die Funktionsweise einiger Base R-Programme erst nach dem Studium der zugehörigen Bibliotheksdokumentation.\nMit zunehmender Bedeutung der Datenwissenschaften, wurden die Inkonsistenzen von Base R zum Hindernis für komplexe Anwendungen und Analysen. Ausgehend von einer konsistenten Syntax für die Datenvisualisierung wurden nach und nach R-Bibliotheken für eine konsistente und koherente Datentransformation und -Auswertung bereitgestellt. Diese Bibliotheken stellen Daten und Datenströme in das Zentrum der Programmierung. Durch selbsterklärende Funktionsnamen, das zusammenfassen in Funktionsgruppen und einheitliche Logik für Funktionsaufrufe bilden diese Bibliotheken einen R-Dialekt, der als tidy R bezeichnet wird. R-Programme sind auch für unerfahrende R-Interessierte deutlich intuitiver zu verstehen, wenn sie mit den tidy R Konzepten entwickelt wurden, als vergleichbare Base R Varianten. Durch den datenzentrierten Zugang lässt sich tidy R wesentlich leichter erlernen als Base R.\nDen Kern von tidy R bildet die Bibliothek tidyverse, die die wichtigsten Funktionen für die Datentransformation und die Datenvisualisierung zusammenfasst. Sie besteht aus den Unterbibliotheken dplyr, forcats, ggplot2, purrr, readr, tibble und tidyr.\nWichtige ergänzende Funktionen für die Statistik und das statistische Modellieren werden durch die Bibliotheken rstatix und tidymodels bereitgestellt.\nIn diesem Buch werden alle Konzepte datenzentrisch mit dem tidy R Ansatz erarbeitet. Base R Konzepte, Operatoren und Funktionen werden nur verwendet, wenn diese nicht im Widerspruch zu tidy R stehen. In diesen Fällen werden diese nicht gesondert als Base R hervorgehoben."
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#organisation-dieses-buchs",
    "href": "kapitel/einleitung/kapitel.html#organisation-dieses-buchs",
    "title": "1  Einleitung",
    "section": "1.3 Organisation dieses Buchs",
    "text": "1.3 Organisation dieses Buchs"
  },
  {
    "objectID": "kapitel/tool-chain/installation.html#r-installieren",
    "href": "kapitel/tool-chain/installation.html#r-installieren",
    "title": "2  Tool Chain",
    "section": "2.1 R installieren",
    "text": "2.1 R installieren\nDie Installation von R ist einfach. Auf der R-Project Webseite kann das Installationspaket für das jeweilige Betriebssystem heruntergeladen werden. Die Installation erfolgt wie gewohnt über den Installer.\n\n\n\n\n\n\nMacOS\n\n\n\nViele R-Bibliotheken benötigen zusätzliche Komponenten, damit sie funktionieren. Diese Komponenten müssen zusätzlich kompiliert werden. Unter MacOS benötigt R dafür die App XCode und die XCode Command Line Tools.\nBeide Komponenten stehen unter MacOS kostenlos zur Verfügung. XCode wird wie gewohnt über Apple’s AppStore installiert. Nach der Installation muss XCode einmal gestartet werden, um die Lizenzbedingungen zu akzeptieren. Anschliessend sollten die notwendigen Ergänzungen für die Entwicklung unter MacOS installiert werden.\nNach erfolgreicher Installation erscheint eine Abfrage, zum Starten eines neuen Projekts (Abbildung 2.1).\n\n\n\nAbbildung 2.1: XCode Start Dialog\n\n\nDamit ist die Installation von XCode abgeschlossen. Nun folgt die Installation der Kommandozeilenwerkzeuge. Dazu muss ein Terminal geöffnet werden.\n\n\n\nAbbildung 2.2: MacOS Terminal\n\n\nIm Terminal muss das folgende Kommando eingegeben und anschliessend mit der Eingabe-Taste abgeschlossen werden.\nxcode-select --install\nAnschliessend folgen mehrere Abgragen zur Installation der XCode-Command-Line Komponenten. Nach der Installation kann das Terminal und XCode wieder geschlossen werden.\nXCode wird regelmässig grösseren Änderungen unterzogen. Diese Änderungen erfolgen oft im April, Juni und September. Nach einem Update von XCode müssen die Command-Line Tools ebenfalls erneut installiert werden. Ausserdem ist es notwendig, dass die Lizensbedingungen erneut akzeptiert werden, sonst lassen sich R-Bibliotheken nicht mehr kompilieren.\n\n\n\n2.1.1 Überprüfen der Installation\nNach erfolgreicher Installation sollte R mit den Werkzeugen der Laufzeitumgebung auf dem Rechner vorhanden sein. Die Installation lässt sich mithilfe des Terminals (MacOS) oder der Powershell (Windows) überprüfen.\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nUnter MacOS muss der folgende Befehl eingegeben und mit der Eingabe-Taste abgeschlossen werden.\nRscript -e 'sessionInfo()'\nIn der Windows Powershell muss der Befehl wie folgt aussehen:\nRSCRIPT.EXE -e 'sessionInfo()'\n\n\nBei erfolgreicher Installation erscheint eine Meldung im Terminal, die der folgen Meldung ähnelt. Die Funktion sessionInfo() zeigt die Versionsinformationen der aktuellen R-Installation an.\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin22.4.0 (64-bit)\nRunning under: macOS Ventura 13.5.2\n\nMatrix products: default\nBLAS:   /opt/homebrew/Cellar/openblas/0.3.23/lib/libopenblasp-r0.3.23.dylib \nLAPACK: /opt/homebrew/Cellar/r/4.3.1/lib/R/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] de_DE.UTF-8/de_DE.UTF-8/de_DE.UTF-8/C/de_DE.UTF-8/de_DE.UTF-8\n\ntime zone: Europe/Zurich\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n[1] compiler_4.3.1\n\n\n2.1.2 Erste Schritte\nR ist eine interaktive Sprache und besteht im Kern aus einer sog. Laufzeitumgebung. Diese Umgebung übersetzt R-Syntax in Maschinensprache und führt vollständige Ausdrücke direkt aus. Innerhalb der Laufzeitumgebung steht ein einfacher Zeileneditor zur Verfügung, mit dem Eingaben erstellt und manipuliert werden können.\n\n\n\n\n\n\nMacOS vs Windows\n\n\n\nDie R-Laufzeitumgebung wird auf MacOS-Systeme im Terminal mit dem Kommando R und Eingabetaste gestartet.\nAuf Windows-Systemen wird die Laufzeitumgebung in der Powershell mit dem Kommando R.EXE aufgerufen.\n\n\nR verwendet für alle Operationen Funktionen. Die meisten R-Funktionen haben einen Namen und werden mit runden Klammern aufgerufen. Ein Beispiel ist die Funktion quit(), mit der die R-Laufzeitumgebung verlassen wird. Funktionen werden in die Laufzeitumgebung eingegeben und durch das Drücken der Eingabetaste ausgeführt.\nquit()\nDieser Funktionsaufruf führt zu der Abfrage, ob die aktuelle Arbeitsumgebung gesichert werden soll.\nSave workspace image? [y/n/c]:\nWeil nichts geändert wurde, kann diese Frage mit n für No beantwortet und mit einem Druck auf die Eingabetaste übergeben werden. Anschliessend wird die Laufzeitumgebung geschlossen und kehrt auf die Kommandozeile des Betriebssystems zurück.\nNeben der interaktiven Laufzeitumgebung wird R mit dem Programm Rscript ausgeliefert. Mit Rscript können Dateien mit R-Code zusammenhängend ausgeführt werden.\n\nDefinition 2.1 Ein R-Script ist eine Datei, die nur R-Code enthält. Ein R-Script hat per Konvention die Dateiendung .r\n\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nDas Programm Rscript heisst unter Windows RSCRIPT.EXE.\n\n\n\nBeispiel 2.1 (Ausführen eines R-Scripts im MacOS Terminal)  \nRscript my-rscript.r\n\nRscript kann ausserdem einzelne Code-Zeilen ausführen, ohne in die interaktive Laufzeitumgebung wechseln zu müssen. Diese Funktion ist praktisch, um eine einfache Operation auszuführen, wie z.B. eine Bibliothek zu installieren (s. Kapitel 2.3)."
  },
  {
    "objectID": "kapitel/tool-chain/installation.html#grafische-oberflächen-für-r",
    "href": "kapitel/tool-chain/installation.html#grafische-oberflächen-für-r",
    "title": "2  Tool Chain",
    "section": "2.2 Grafische Oberflächen für R",
    "text": "2.2 Grafische Oberflächen für R\nR hat keine eigene grafische Benutzeroberfläche und ist auf eine externe Entwicklungsumgebung angewiesen. Eine solche Entwicklungsumgebung muss zusätzlich zu R installiert werden, damit die Programmierung und die Analyse vereinfacht wird. Die am häufigsten eingesetzten Entwicklungsumgebungen für R sind:\n\nRStudio\nJupyter Notebooks\nVisual Studio Code\n\n\n\n\n\n\n\nHinweis\n\n\n\nIn diesem Buch wird Visual Studio Code für alle Beispiele mit Benutzeroberfläche verwendet. Die Bedienung von RStudio oder JupyterLab unterscheidet für die Arbeit in diesem Buch sich nur marginal von Visual Studio Code.\n\n\nEine R-Entwicklungsumgebung ist unabhängig von der R-Laufzeitumgebung, die die Programmiersprache bereitstellt. Es ist also möglich, R-Programme in der einen Umgebung zu entwickeln und später in einer anderen weiterzubearbeiten und auszuführen.\nDie Grundkomponenten einer Entwicklungsumgebung sind immer gleich (Abbildung 2.3):\n\nCode-Editor, mit dem Dokumentation und analytische Funktionen geschrieben werden.\nDatei-Browser, über den alle Dateien eines Projekts verwaltet werden können.\n\nLaufzeit-Console, über die die R-Laufzeitumgebung zugänglich ist.\nDatenbetrachter, zur Auswertung von generierten Datenstrukturen.\nVisualisierungsbetrachter, zur Anzeige von Datenvisualisierungen.\n\n\n\n\nAbbildung 2.3: Komponenten einer datenzentrischen Entwicklungsumgebung am Beispiel von Visual Studio Code\n\n\nNeben diesen Komponenten existieren oft zustätzliche Werkzeuge und Ansichten.\n\nWerkzeuge zur Versionierung von Code und Daten.\nDokumentation für R und ergänzende Bibliotheken.\nInstallationsunterstützung von Bibliotheken.\n\n\n2.2.1 RStudio\nRStudio ist eine integrierte Analyseumgebung, die speziell für die Entwicklung von R-Programmen und R-Analysen entwickelt wurde. Das System ist auf R-spezifische Arbeitsabläufe zur Datenanalyse ausgerichtet und unterstützt neben R auch die Programmiersprache Python.\nRStudio verwendet eine spezielle Version von Markdown, um R-Code-Fragmente auszuführen und die Ergebnisse in das Dokument einzubinden. Dieses Format heisst R-Markdown.\nVon RStudio existiert auch eine Web-basierte Version, welche online Zusammenarbeit und online Publikationen unterstützt.\n\n\n2.2.2 JupyterLab\nJupyterLab ist eine Web-basierte Analyseumgebung, die ursprünglich für die Programmiersprache Python entwickelt wurde. JupyterLab wurde speziell für Datendokumente entwickelt und unterstützt ausschliesslich Jupyter Notebooks als Austauschformat für Analysen.\nJupyterLab unterstützt neben Python viele andere Programmiersprachen. Dazu gehört auch R. JupyterLab integriert Programmiersprachen durch spezielle Kernel, die Code-Fragmente auswerten und die Ergebnisse in ein Datendokument einbinden.\nIn der Praxis werden Jupyter Notebooks und JupyterLab oft eingesetzt, wenn sehr umfangreiche Daten analysiert werden sollen, die nicht ohne weiteres über das Internet übertragen werden können oder dürfen.\n\n\n2.2.3 Visual Studio Code\nVisual Studio Code ist ein kostenloser Code-Editor mit vielen Erweiterungen für fast alle Programmiersprachen und Arbeitsumgebungen. Die Erweiterung für R ist ebenfalls kostenlos und kann über den Extension Manager installiert werden.\nIm Gegensatz zu R-Studio ist Visual Studio Code in erster Linie ein Code-Editor und bietet für R eine vergleichsweise einfache Entwicklungsumgebung. Der grösste Unterschied zwischen Visual Studio Code und RStudio oder JupyterLab ist der wenig differenzierte Variablen-Inspektor.\nIn Visual Studio Code lassen sich u.a. auch R-Markdown-Dokumente und Jupyter Notebooks bearbeiten."
  },
  {
    "objectID": "kapitel/tool-chain/installation.html#sec-install-libs",
    "href": "kapitel/tool-chain/installation.html#sec-install-libs",
    "title": "2  Tool Chain",
    "section": "2.3 R-Bibliotheken installieren",
    "text": "2.3 R-Bibliotheken installieren\nR verfügt über einen sehr grossen Fundus an Lösungen für das statistische Rechnen. Diese Lösungen werden als Bibliotheken bereitgestellt und über das Comprehensive R Archive Network (CRAN) geteilt. CRAN ist ein integraler Bestandteil von R. Weil R jedoch über sehr viele Bibliotheken verfügt, werden diese nicht mit R ausgeliefert, sondern müssen bei Bedarf installiert werden. Hierzu liefert R die Funktion install.packages() mit. Diese Funktion teilt R mit, eine Bibliothek mit einem bestimmten Namen zu installieren.\n\nBeispiel 2.2 (Funktions-Schema von install.packages())  \ninstall.packages(package_name)\n\nIn diesem Buch werden neben den R-Basisfunktionen fast ausschliesslich die Funktionen der tidyverse-Bibliothek behandelt. Die tidyverse-Bibliothek erweitert die R-Syntax um moderne Sprachkonzepte und vereinheitlicht viele Funktionen für Standardaufgaben.\n\n\n\n\n\n\nHinweis\n\n\n\nStreng genommen ist die tidyverse-Bibliothek eine R-Bibliothek im engeren Sinn. Vielmehr vereint sie die häufig zusammen eingesetzten Biblliotheken ggplot2 (Kapitel 18), dplyr (Kapitel 14), tidyr (Kapitel 16), readr (Kapitel 7), stringr (Kapitel 9), forcats (Kapitel 10), lubridate und purrr (Kapitel 8) sowie etliche weitere Module für die tägliche Arbeit mit Daten.\n\n\nWeil die tidyverse-Bibliothek eine zentrale Bedeutung im R-Umfeld hat, ist es an dieser Stelle sinnvoll, die tidyverse-Bibliothek mithilfe von Rscript zu installieren.\n\nBeispiel 2.3 (Installieren der tidyverse-Bibliotheken unter MacOS)  \nRscript -e 'install.packages(\"tidyverse\")'\n\nBei der ersten Installation einer Bibliothek fragt R nach einem CRAN-Mirror. Hier sollte ein geografisch nahe Quelle gewählt werden, um die Ladezeiten zu verringern.\nMit Visual Studio Code können R-Bibliotheken auch mit der Arbeitsumgebung installiert werden. Dazu wird die R-Erweiterung geöffnet und im Bereich Help Pages die Option Install CRAN Package gewählt. Anschliessend wird der gewünschte Bibliotheksname in der interaktiven Suche eingegeben und mit der Eingabetaste ausgewählt (Abbildung 2.4).\n\n\n\nAbbildung 2.4: Installation der tidyverse-Bibliothek in Visual Studio Code"
  },
  {
    "objectID": "kapitel/tool-chain/hilfe.html#help",
    "href": "kapitel/tool-chain/hilfe.html#help",
    "title": "3  Hilfe bekommen",
    "section": "3.1 help()",
    "text": "3.1 help()\nDie help()-Funktion ist der erste Anlaufpunkt, um mehr über eine Funktion zu erfahren.\nR-Funktionen sind in der Regel sehr ausführlich dokumentiert. Falls Sie Details über die Arbeitsweise einer Funktion erfahren möchten, können Sie die Dokumentation einer Funktion mit der help()-Funktion abrufen. Dazu rufen Sie diese Funktion wie jede andere R-Funktion auf.\nDie help()-Funktion ist Teil von Base R und ist in jeder Umgebung verfügbar.\nDie Funktion erwartet den gewünschten Funktionsnamen. help() kann der Funktionsname direkt oder als Zeichenkette als Parameter übergeben werden. D.h. die beiden folgenden Operationen haben den gleichen Effekt und zeigen die Dokumentation der Funktion read.csv an.\n\nBeispiel 3.1 (Hilfe anzeigen)  \nhelp(read.csv)\nhelp(\"read.csv\")\n\nIn Visual Studio Code ist es nicht notwendig, die help()-Funktion aufzurufen, weil die Hilfe direkt in die Arbeitsumgebung integriert ist. In R-Scirpten reicht es, den Mauszeiger über eine Funktion zu bewegen. Visual Studio Code zeigt dann die Hilfe direkt im Editor an (Abbildung 3.1). Diese Darstellung wird als Inline-Hilfe bezeichnet.\n\n\n\nAbbildung 3.1: Inline Anzeige einer R-Funktionsdokumentation in Visual Studio Code\n\n\nNeben der Inline-Hilfe lassen sich alle Funktionen der installierten R-Bibliotheken auch über den Abschnitt Help Pages der R-Erweiterung zugreifen. Dort findet sich unter dem letzten Punkt Help Topics by Packages die Dokumentation für alle auf dem Computer installierten Bibliotheken. Der erste Unterpunkt für jede Bibliothek ist der Index, der alle Dokumente für eine Bibliothek auflistet (Abbildung 3.2). Nach dem Installieren einer Bibliothek sollte diese Seite aufgerufen werden, um sich mit der installierten Version vertraut zu machen.\n\n\n\n\n\n\nAchtung\n\n\n\nIm Internet finden sich viele Materialien zur Verwendung einzelner Bibliotheken. Oft beziehen sich diese Materialien auf ältere Versionen der jeweiligen Bibliothek. Damit ist nicht sichergestellt, dass die beschriebenen Techniken der richtigen Vorgehensweise entsprechen. Deshalb sollte immer die offizielle Dokumentation der installierten Bibliotheken zur Überprüfung der beschriebenen Methoden herangezogen werden.\n\n\n\n\n\nAbbildung 3.2: Index der Dokumentation für die Bibliothek dplyr\n\n\n\n3.1.1 Aufbau von Funktionsdokumentationen\nDie meisten R-Bibliotheken folgen einer Konvention zur systematischen Dokumentation von Funktionen. Jede Funktionsdokumentation besteht aus den folgenden Teilen:\n\nBeispielen für den Aufruf der Funktion\nBeschreibung aller Funktionsparameter\nEiner detaillierten Funktionsbeschreibung\nBeispielen\n\nDie Beispiele zeigen typische Aufrufe der jeweiligen Funktion und finden sich immer am Ende der Dokumentation. Es lohnt sich häufig zuerst die Beispiele anzusehen und danach die Funktionsdetails zu lesen."
  },
  {
    "objectID": "kapitel/tool-chain/hilfe.html#vignettes",
    "href": "kapitel/tool-chain/hilfe.html#vignettes",
    "title": "3  Hilfe bekommen",
    "section": "3.2 Vignettes",
    "text": "3.2 Vignettes\nViele R-Bibliotheken haben komplexe Anwendungen. Diese Anwendungen werden in sogenannten Vignettes beschrieben. Eine Vignette ist eine ausführliche Beschreibung einer Funktion oder des Zusammenspiels mehrerer Funktionen mit nachvollziehbaren Beispielen.\nSie können sich die verfügbaren Vignettes für eine Bibliothek mit der Operation vignette(package = bibliotheksname) anzeigen lassen. Wenn Sie z.B. alle Vignettes für die dplyr Bibliothek anzeigen lassen möchten, dann geben Sie vignette(package = \"dplyr\") ein. Das Ergebnis ist die Liste der verfügbaren Vignettes für diese Bibliothek.\nWenn Sie das gesuchte Thema gefunden haben, dann können Sie sich die Vignette mit dem folgenden Befehl anzeigen lassen: vignette(thema, package = bibliotheksname)\n\n\n\nAbbildung 3.3: Index der dplyr Anleitungen\n\n\nIn Visual Studio Code sind alle Vignettes einer Bibliothek (Abbildung 3.3) über deren Dokumentationsindex (Abbildung 3.2) erreichbar. Dadurch lassen sich Anleitungen oft leichter finden."
  },
  {
    "objectID": "kapitel/tool-chain/hilfe.html#cheat-sheets",
    "href": "kapitel/tool-chain/hilfe.html#cheat-sheets",
    "title": "3  Hilfe bekommen",
    "section": "3.3 Cheat Sheets",
    "text": "3.3 Cheat Sheets\nDie tidyverse-Bibliotheken bieten zusätzlich Spickzettel für die wichtigsten Funktionen und Techniken für eine Bibliothek auf zwei Seiten. Diese Spickzettel werden auch als Cheat Sheets bezeichnet. Sie können diese Cheat Sheets doppelseitig ausdrucken und als Schnellreferenz verwenden.\nIm Git-Repository rstudio/cheatsheets finden sich Spickzettel und Kurzreferenzen viele R-Bibliotheken.\n\n\n\n\n\n\nAchtung\n\n\n\nDie Spickzettel sind nicht Teil der Dokumenation einer Bibliothek und werden nicht mit ihr gepflegt.\nEin Spickzettel ersetzt nicht die Dokumentation! Gelegentlich verweisen Spickzettel auf stark veraltete Praktiken. Es ist also immer ein Vergleich mit der offiziellen Dokumentation notwendig.\n\n\nDie folgenden Spickzettel unterstützen die Arbeit mit diesem Buch:\n\nDatenimport\nDatenvisualisierung (ggplot2)\nDatentransformation (dplyr)\nDatenbereinigung (tidyr)\nVektorfunktionen (purrr)\nZeichenketten (stringr)\nFaktoren (forcats)\nDatumswerte (lubridate)"
  },
  {
    "objectID": "kapitel/tool-chain/language.html#syntaktische-symbole",
    "href": "kapitel/tool-chain/language.html#syntaktische-symbole",
    "title": "4  R-Sprachelemente",
    "section": "4.1 Syntaktische Symbole",
    "text": "4.1 Syntaktische Symbole\nSyntaktische Symbole sind alle Sprachelemente, die für sich allein stehen. Symbole können Werte, Schlüsselworte oder Bezeichner sein. Symbole werden durch Operatoren oder durch Leerzeichen voneinander getrennt.\n\n4.1.1 Werte\nWerte können direkt angegeben werden. Dabei legt der Datentyp eines Werts (Kapitel 6) fest, wie dieser eingegeben werden muss.\n\nZahlen werden als Ziffernfolge direkt eingegeben (z.B. 123.45).\nWahrheitswerte werden in Grossbuchstaben eingegeben (z.B. WAHR).\nZeichenketten werden in Anführungszeichen eingegeben (z.B. \"Daten und Information\")\n\n\n\n4.1.2 Schlüsselworte\nR kennt verschiedene Schlüsselworte, die als eigene Symbole festgelegt sind und nicht verändert werden können. Jedes der folgenden Schlüsselworte hat eine Bedeutung für R und kann nur in dieser Bedeutung verwendet und nicht umdefiniert werden.\nFunktionen (Kapitel 8)\n\nfunction\n\nEntscheidungen (Kapitel 11) zur bedingten Ausführung von Operationen.\n\nif\nelse\n\nSchleifen zur wiederholten Ausführung von Operationen.\n\nrepeat\nwhile\nfor\nnext\nbreak\n\n\n\n\n\n\n\nKeine Schleifen in der Paxis\n\n\n\nR-Schleifen sind im Vergleich zu vergleichbaren Funktionen äusserst ineffizient. Deshalb haben Schleifen in der praktischen Anwendung von R keine Bedeutung mehr. Stattdessen werden ausschliesslich spezielle Funktionen über Datenstrukturen verwendet. Entsprechend finden sich diese Schlüsselworte sehr selten in R-Skripten.\n\n\n\n\n4.1.3 Bezeichner\nIst ein Symbol kein Schlüsselwort und kein Wert, dann wird das Symbol als Bezeichner behandelt. Ein Bezeichner ist ein Platzhalter für einen Wert (Kapitel 6) und kann wie ein Wert in Operationen verwendet werden.\nGrundsätzlich können Bezeichner beliebige Zeichen enthalten. R erkennt einfache Bezeichner mit zwei Regeln.\n\nBeginnt mit einem ASCII-Buchstaben (A-Z, a-z) oder einem Unterstrich.\nEnthält nur ASCII-Buchstaben (A-Z, a-z), arabische Ziffern (0-9) und Unterstriche.\n\nWeicht ein Bezeichner von diesen Regeln ab, dann muss dieser als solcher durch Backticks (`) gekennzeichnet werden. Beispiel 4.1 zeigt einen Bezeichner, der den deutschen Umlaut (ü) und ein Leerzeichen enthält. Weil ü kein ASCII-Buchstabe ist und das Leerzeichen normalerweise Symbole trennt, muss der ganze Bezeichner als Symbol markiert werden.\n\nBeispiel 4.1 (markierter Bezeichner)  \n`merkwürdiger Bezeichner`\n\nWird der Bezeichner aus Beispiel 4.1 nicht markiert, erzeugt R die Fehlermeldung Fehler: unerwartetes Symbol in \"merwürdiger Name\"."
  },
  {
    "objectID": "kapitel/tool-chain/language.html#operationen",
    "href": "kapitel/tool-chain/language.html#operationen",
    "title": "4  R-Sprachelemente",
    "section": "4.2 Operationen",
    "text": "4.2 Operationen\n\nDefinition 4.1 Eine Operation ist ein syntaktisches Konstrukt, das von einer Programmiersprache als ausgeführbar erkannt wird.\n\nEine Operation kann sich als ein Satz in einer Sprache vorgestellt werden, wobei für Programmiersprachen nur ganze (vollständige) Sätze gültig sind und ausgeführt werden.\nR fügt Symbole und Operatoren solange zusammen, bis eine syntaktisch gültige Operation gefunden wird. Syntaktisch gültig heisst in diesem Zusammenhang, dass alle syntaktischen Elemente für eine Operation gefunden wurden. Erst dann versucht R diese Operation auszuführen. Bei der Ausführung kann festgestellt werden, dass eine Operation nicht ausführbar ist. In diesem Fall erzeugt R eine Fehlermeldung.\nDie einfachste R-Operation ist die Angabe eines einzelnen Symbols. Wird nur ein Symbol als Operation eingegeben, dann bedeutet das für R, dass die zum Symbol gehörenden Daten serialisiert werden sollen. Das bedeutet, dass die Daten des Symbols angezeigt werden. Ist das Symbol ein Wert, dann wird der Wert wiederholt.\n\nBeispiel 4.2 (Wert direkt serialisieren)  \n\"Daten und Information\"\n\nBeispiel 4.2 zeigt die Operation, die die Zeichenkette Daten und Information als Ergebnis serialisiert.\n\n4.2.1 Operatoren\n\nDefinition 4.2 Ein Operator ist ein syntaktisches Element, das Symbole zu einer Operation verknüpft.\n\nDie bekanntesten Operatoren sind die arithmetischen Operatoren und die Vergleichsoperatoren.\nIn R sind vier spezielle Operatoren wichtig:\n\nDie drei Zuweisungsoperatoren (&lt;-, = und -&gt;).\nDer Funktionsaufrufoperator (()).\n\nMit den Zuweisungsoperatoren können Werte Namen zugewiesen werden. Bei den Pfeil-Operatoren wird der Wert in Richtung des Pfeils zugewiesen. Beim Gleich-Operator erfolgt die Zuweisung von rechts nach links. (s. Beispiel 4.3)\n\nDefinition 4.3 Eine Deklaration heisst die (erste) Zuweisung eines Werts an eine Variable.\n\n\nBeispiel 4.3 (Zuweisung einer Zeichenkette)  \nbuchtitel1 = \"Daten und Information 1\"\nbuchtitel2 &lt;- \"Daten und Information 2\"\n\"Daten und Information 3\" -&gt; buchtitel3 \n\nEs können auch Namen anderen Namen zugewiesen werden. In diesem Fall wird der zugehörige Wert für einen Namen ermittelt und dem neuen Namen zugewiesen (Beispiel 4.4).\n\nBeispiel 4.4 (Zuweisung von Namen an einen anderen Namen.)  \nbuchtitel4 = buchttitel1 \n# buchtitel4 enthält \"Daten und Information 1\"\nbuchtitel5 &lt;- buchtitel2 \n# buchtitel5 enthält \"Daten und Information 2\"\nbuchtitel3 -&gt; buchtitel6 \n# buchtitel6 enthält \"Daten und Information 3\"\n\nDer Funktionsaufrufoperator prüft ob der vorangehende Name eine Funktion ist und ruft diese auf. Zwischen den Klammern können Werte oder Namen als Parameter der Funktion übergeben werden. Die Parameter werden durch Kommas getrennt (Beispiel 4.5).\n\nBeispiel 4.5 (Funktionsaufruf der Summefunktion mit Parametern)  \nsum(1,2,3) # 6\n\nDer Funktionsaufrufoperator darf nicht mit den aus der Mathematik bekannten Klammern verwechselt werden. Klammern fassen auch in R Teiloperationen zusammen und reihen diese gegenüber einer anderen Teiloperation vor. Der Funktionsaufrufoperator kommt nur zur Anwendung, wenn ein Name auf eine Funktion verweist.\nWird der Funktionsaufrufoperator zusammen mit dem Schlüsselwort function verwendet, dann wird eine Funktion mit den angegebenen Parametern erstellt (s. Beispiel 4.6). Diese Operation heisst Funktionsdeklaration. Eine deklarierte Funktion muss in R einem Namen zugewiesen werden.\n\nBeispiel 4.6 (Funktionsdeklaration)  \nadd3 &lt;- function (eins, zwei, drei) \n    sum(eins, zwei, drei)\n\n\n\n4.2.2 Blöcke\nMehrere Operationen lassen sich in R zu Blöcken zusammenfassen. Ein Block wird durch geschweifte Klammern ({ und }) markiert. Geschweifte Klammern bilden also den Blockoperator.\nEin Block wird von R als eine Operation behandelt. Damit die Operationen in einem Block von R ausgeführt werden können, müssen alle übergeordneten Blöcke geschlossen werden.\nBeispiel 4.7 zeigt die Deklaration einer Funktion, die aus zwei Operationen besteht. Damit beide Operationen zu einer Funktion zusammengefasst werden können, müssen diese in einen Block gefasst werden.\n\nBeispiel 4.7 (Funktionsdeklaration mit Block)  \nadd3mod6 &lt;- function (eins, zwei, drei) {\n    sum(eins, zwei, drei) -&gt; sechs\n    sechs %% 6\n}"
  },
  {
    "objectID": "kapitel/daten-organisieren/kapitel.html#mathematische-formeln-in-datendokumenten",
    "href": "kapitel/daten-organisieren/kapitel.html#mathematische-formeln-in-datendokumenten",
    "title": "5  Dokumentation",
    "section": "5.1 Mathematische Formeln in Datendokumenten",
    "text": "5.1 Mathematische Formeln in Datendokumenten\nIn Datendokumenten lassen sich mathematische Formeln darstellen. Diese Formeln werden im sog. LaTeX-Math-Mode eingegeben. Diese Formeln werden bei der Präsentation in die korrekte mathematische Darstellung überführt.\nDer LaTeX-Math-Mode ist eine Formelbeschreibungssprache (American Mathematical Society & LATEX Project, 2020; Høgholm & Madsen, 2022), mit der die exotischen und in nicht mathematischen Texten wenig bis nie verwendeten Symbole und deren Anordnung gezielt erzeugt werden können. Der LaTeX-Math-Mode wird von vielen Systemen zur Darstellung von Formeln verwendet. Deshalb lohnt sich eine Auseinandersetzung mit den Grundkonzepten dieser Technik.\nDer LaTeX-Math-Mode kennt zwei Modi: den inline Modus, wenn eine Formel wie oben in den Fliesstext eingebettet ist, und den Gleichungsmodus, wenn eine Formel wie eine Abbildung hervorgehoben und beschriftet wird. Der inline Modus wird durch ein einfaches Dollar-Zeichen ($) oder mit der Zeichenfolge Backslash-runde Klammer (\\( und \\)) eingeleitet und abgeschlossen. Der Gleichungsmodus wird durch ein doppeltes Dollar-Zeichen ($$) eingeleitet und abgeschlossen. Die Formelbeschreibung ist unabhängig vom Modus, wobei die Darstellung dem zur Verfügung stehenden Platz berücksichtigt.\nMit dem LaTeX-Math-Mode wird die Formel mit ihren Bestandteilen und ihren Beziehungen beschrieben. Die folgenden Grundregeln sind für den Math-Mode wichtig:\n\nZahlen und Buchstaben und andere Sonderzeichen auf der Tastatur werden als solche dargestellt.\nSonderzeichen, Operatoren und besondere Formatierungen werden durch einen Back-Slash (\\) eingeleitet, der von einem Schlüsselwort gefolgt wird.\nzusammengehörende Teilausdrücke werden durch geschweifte Klammern zusammengefasst ({}). Teilausdrücke, die nur aus einem Symbolbestehen müssen nicht in Klammern gesetzt werden.\nDas Dach (^) bedeutet den folgenden Teilausdruck hochstellen.\nDer Unterstrich (_) bedeutet den folgenden Teilausdruck tiefstellen.\n\n\nBeispiel 5.1 (LaTeX-Math-Mode) Die Formel \\sum_{i=1}^{n}{(\\frac{x_i}{2})^2} lässt sich mit einer normalen Tastatur nicht eingeben. Deshalb wird der Math-Mode zur Formelbeschreibung verwendet. Im inline Modus wird die Formeldarstellung so gewählt, dass die Formel ungefähr in die aktuelle Textzeile passt. Im Gleichungsmodus wird die gleiche Formel möglichst übersichtlich angezeigt.\n\n\\sum_{i=1}^{n}{(\\frac{x_i}{2})^2}\n\nDie Formel wird wie folgt im Math-Mode beschrieben:\n\\sum_{i=1}^{n}{(\\frac{x_i}{2})^2}\nDie Formel beginnt mit dem grossen griechischen Sigma (\\Sigma) für das Summensymbol. Das wird durch \\sum erzeugt. Eine Summe besteht aus drei Teilausdrücken:\n\nDem Initialwert unter dem Summenzeichen.\nDem Endwert über dem Summenzeichen.\nDem Summenterm hinter dem Summenzeichen.\n\nEntsprechend wird der Initialwert mit _ tiefgestellt, der Endwert mit ^ hochgestellt und der Summenterm wird hinter die Summe gefügt.\nDer Summenterm wird durch eine Potenz und einem Bruch gebildet. Die Potenz wird durch das Hochstellen gekennzeichnet. Die runden Klammern werden als einfache runde Klammern eingegeben\nDer Bruch ist eine besondere Darstellung und benötigt das Schlüsselwort frac für fraction (dt. Fraktur/Bruch). Ein Bruch besteht immer aus zwei Teilausdrücken, die nacheinander in geschweiften Klammern angegeben werden müssen. Der Zähler besteht aus dem Teilausdruck x_i. Entsprechend muss das i gegenüber dem x tiefgestellt werden. Weil es sich jeweils um einzelne Symbole handelt, müssen die Teilausdrücke nicht geklammert werden.\n\n\n\n\n\nAmerican Mathematical Society, & LATEX Project. (2020). User’s Guide for the amsmath Package. http://mirrors.ctan.org/macros/latex/required/amsmath/amsldoc.pdf\n\n\nGrolemund, G. (2014). Introduction to R Markdown. https://rmarkdown.rstudio.com/articles_intro.html\n\n\nHøgholm, M., & Madsen, L. (2022). mathtools – Mathematical tools to use with amsmath. https://ctan.org/pkg/mathtools?lang=en\n\n\nJupyter Development Team. (2015). The Notebook file format. https://nbformat.readthedocs.io/en/latest/format_description.html\n\n\nPosit Software PBC. (2023). quarto. https://quarto.org/\n\n\nThe Jupyter Book Community. (2023). Jupyter Book. https://jupyterbook.org"
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#fundamentale-datentypen",
    "href": "kapitel/datentypen/kapitel.html#fundamentale-datentypen",
    "title": "6  Datentypen",
    "section": "6.1 Fundamentale Datentypen",
    "text": "6.1 Fundamentale Datentypen\n\n6.1.1 Undefinierte Werte\nR kennt zwei voneinander verschiedene Werte für undefinierte Werte.\n\nNULL\nNA\n\nWeder NULL noch NA sind in R gleichwertig mit dem Wert 0. Die beiden Werte sind ausserdem nicht gleich und haben eine leicht unterschiedliche Bedeutung.\nNULL bedeutet, dass kein Wert vorhanden ist und kein Datentyp bekannt ist. Dieses Symbol ist für die Programmierung von Bedeutung und zeigt für eine Variable (Kapitel 8) an, dass diese auf keinen Wert im Speicher des Computers verweist. Das Symbol NULL ist ein eigener Datentyp.\nNA (für not available) bedeutet, dass ein Wert fehlt, obwohl ein Wert erwartet wird. In diesem Fall ist der Datentyp bekannt. Dieser Wert bezieht sich auf die Daten und zeigt fehlende Werte an. Der Wert NA hat einen beliebigen Datentyp ausser NULL. NA ist ein Platzhalter für fehlende Werte in Daten, der immer ausserhalb des gültigen Wertebereichs der Daten liegt. Damit müssen fehlende Werte in R nicht durch einen alternativen Wert ersetzt werden.\nBeim Zählen von Werten werden NA-Werte mitgezählt. Für mathematische Operationen, wie der Addition oder der Multiplikation, führt ein Operand mit Wert NA als Operand immer zum Ergebnis NA. Deshalb müssen NA Werte vor allen anderen Operationen behandelt werden.\n\n\n6.1.2 Zahlen\nR unterscheidet drei Arten von Zahlen:\n\nGleitkomma (numeric())\nGanzzahlen (integer())\nKomplexe Zahlen (complex())\n\nStandardmässig werden alle Zahlenwerte als Gleichkommazahlen erstellt. Gleitkommazahlen können sowohl direkt oder in wissenschaftlicher Notation eingegeben werden. Bei der wissenschaftlichen Notation muss immer der Nachkommaanteil angegeben werden.\n\nBeispiel 6.1 (Zahlenbeispiele in R)  \n5\n5.374\n3.92e+2\n1.0e-5\n\nDas kann mit der Funktion is.numeric() überprüft werden. Diese Funktion liefert Wahr zurück, wenn ein Wert eine Gleitkommazahl ist oder als solche behandelt werden kann.\nDie Werte anderer Datentypen lassen sich mit der Funktion as.numeric() in Zahlen umwandeln. Lässt sich ein Wert nicht eine Zahl umwandeln, dann wird der Wert NA mit einer entsprechenden Warnung erzeugt.\nGelegentlich müssen ganzzahlige Werte sichergestellt werden. Diese Werte werden aus Gleitkommazahlen mit der Funktion as.integer() erzeugt. Wird eine Gleitkommazahl in eine Ganzzahl umgewandelt, dann wird nur der ganzzahlige Teil behalten. Der Nachkommateil wird gestrichen und nicht gerundet. Grundsätzlich sind alle Längen und alle Indizes in R automatisch Ganzzahlen und müssen nicht umgewandelt werden.\nKomplexe Zahlen sind spezielle Zahlen, die über dem Zahlenraum der reellen bzw. Gleitkommazahlen hinausgehen. Eine Komplexe Zahl besteht aus einem reellen und einem imaginären Zahlenanteil. Der imaginäre Zahlenanteil ist als ein Vielfaches der Zahl i = \\sqrt{-1} definiert. In R wird diese Beziehung der beiden Teile als Summe dargestellt.\n\nBeispiel 6.2 (Darstellung einer komplexen Zahl)  \n3+7i\n\nAlternativ können komplexe Zahlen mit der Funktion complex() erzeugt werden. Dazu werden bei beiden Zahlenanteile getrennt über die Parameter real und imaginary angegeben, wobei beim imaginären Teil das nachfolgende i durch die Funktion eingefügt wird.\n\nBeispiel 6.3 (Erzeugen eines Vektors von komplexen Zahlen mit complex())  \ncomplex(real = c(2,8), imaginary = c(3, 7))\n[1] 2+3i 8+7i\n\nFür reelle Zahlen gilt, dass der imaginäre Anteil gleich 0 ist. Mit der Funktion as.complex() lässt sich jede Zahl in eine komplexe Zahl umwandeln. Wird eine so erstelle komplexe Zahl mit der ursprünglichen reellen Zahl verglichen, dann zeigt R korrekt an, dass die beiden Werte gleich sind.\n\n\n\n\n\n\nPraxis\n\n\n\nIn der Praxis wird die Umwandlung von reellen in komplexe Zahlen R überlassen.\n\n\n\nBeispiel 6.4 (Umwandeln einer reelen Zahl in eine komplexe Zahl)  \nas.complex(2.2)\n2.2+0i\n\nNeben den klassischen Zahlen verfügt R über das Konzept Unendlich, das in vielen Programmiersprachen fehlt. Ein unendlicher Wert wird durch das Symbol Inf dargestellt. Weil sowohl positive als auch negative unendliche Werte existieren steht Inf für positiv unendlich und -Inf für negativ unendlich.\n\n\n6.1.3 Zeichenketten\nZeichenketten heissen in R Character-Strings (character()). Zeichenketten müssen immer in Anführungszeichen eingefasst werden. Als Anführungszeichen dürfen das einfache Anführungszeichen (') oder das doppelte Anführungszeichen (\") verwendet werden.\n\nBeispiel 6.5 (Gleichwertige Zeichenketten mit einfachen und doppelten Anführungszeichen)  \n'Daten und Information'\n\"Daten und Information\"\n\n\n\n\n\n\n\nPraxis\n\n\n\nDie Lesbarkeit von R-Code wird dadurch verbessert, dass konsequent nur ein Symbol für die Kennzeichnung von Zeichenketten verwendet wird. Die Wahl welches der beiden Zeichen benutzt wird, wird von persönlichen Vorlieben geleitet. In diesem Buch wird konsequent das doppelte Anführungszeichen (\") eingesetzt, weil dadurch leere Zeichenketten direkt als solche erkennbar sind und dieses Symbol auch in anderen Programmiersprachen und Dateiformaten zur Kennzeichnung von Zeichenketten benutzt wird.\n\n\n\nBeispiel 6.6 (Leere Zeichenketten mit einfachen und doppelten Anführungszeichen)  \n''\n\"\"\n\nUm zu überprüfen, ob ein Wert eine Zeichenkette ist, wird die Funktion is.character() verwendet. Diese Funktion ergibt Wahr, wenn der Wert eine Zeichenkette ist und in allen anderen Fällen Falsch.\nUm einen anderen Wert in eine Zeichenkette umzuwandeln bzw. zu serialisieren, wird die Funktion as.character() eingesetzt.\n\nBeispiel 6.7 (Eine Zahl in eine Zeichenkette serialisieren)  \nas.character(123.4)\n# ergibt \"123.4\"\n\n\n\n6.1.4 Wahrheitswerte\nR kennt die beiden Wahrheitswerte Wahr und Falsch bzw. die englischen Begriffe True und False. In R müssen Wahrheitswerte ( logical()) immer in Grossbuchstaben geschrieben werden. Der Wert Wahr wird also TRUE und der Wert Falsch wird FALSE geschrieben.\nBeide Wahrheitswerte dürfen mit dem Anfangsbuchstaben abgekürzt werden. Auch dieser Buchstabe muss gross geschrieben werden. Die Werte T und TRUE sowie F und FALSE sind deshalb immer gleich.\nDie Werte TRUE und FALSE dürfen nicht in Anführungszeichen eingefasst werden, denn sonst werden sie als Zeichenketten und nicht als Wahrheitswerte interpretiert.\nNormalerweise müssen Wahrheitswerte nicht mit is.logical() geprüft oder mit as.logical() aus anderen Datentypen erzeugt werden.\n\n\n6.1.5 Faktoren\nEin besonderer Datentyp von R sind Faktoren (factor()).\n\nDefinition 6.1 Ein Faktor ist ein diskreter Datentyp mit einem festen Wertebereich mit einer ganzzahligen Ordnung.\n\nDie angezeigten Werte eines Faktors können als Zahlen, Zeichenketten oder Wahrheitswerte dargestellt werden. Jeder Faktor hat einen definierten Wertebereich, wobei die Werte dieses Wertebereichs diskret sind und eine ganzzahlige Ordnung haben. Mit Faktoren können nominal- und ordinalskalierte Datentypen abgebildet werden. Die Ordnung eines Faktor wird für die visuelle Darstellung der Werte verwendet und für Vergleiche von Werten berücksichtigt.\nEin Faktor ist in R ein eigener fundamentaler Datentyp und kann nicht als Datentyp der dargestellten Werte verwendet werden.\nDie Ordnungswerte eines Faktors lassen sich in Ganzzahlen ausgeben und entsprechend weiter verarbeiten. In diesem Fall muss der Faktor mit der Funktion as.integer() in Zahlen umgewandelt werden.\nDer Wertebereich eines Faktors kann mit der Funktion levels() abgefragt werden.\nDer Wertebereich eines Faktors ist standardmässig Alphanumerisch geordnet. Für ordinalskalierte Datentypen kann diese Reihung angepasst werden (s. Kapitel 10).\n\n\n\n\n\n\nWarnung\n\n\n\nDer tatsächliche Wertebereich eines Faktors umfasst immer nur die vorhandenen Werte in den Daten. Die nicht vorkommenden Werte werden von R aus dem Wertebereich eines Faktors entfernt."
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#datenstrukturen",
    "href": "kapitel/datentypen/kapitel.html#datenstrukturen",
    "title": "6  Datentypen",
    "section": "6.2 Datenstrukturen",
    "text": "6.2 Datenstrukturen\nDie zentralen Datenstrukturen von R sind Vektoren, Listen, Matrizen und Data-Frames.\n\n6.2.1 Vektoren\nVektoren sind Datenstrukturen, bei denen alle Elemente vom gleichen Datentyp sind. Alle Werte mit fundamentalen Datentyp sind in R grundsätzlich Vektoren mit einem Element. Diese Eigenschaft mit der Funktion is.vektor() überprüft werden. Diese FUnktion hat als Ergebnis Wahr, wenn die Eingabe ein Vektor ist und in allen anderen Fällen Falsch. Wird der Funktion ein Wert übergeben, dann gibt die Funktion Wahr (bzw. TRUE) zurück.\n\nBeispiel 6.8 (Ein Wert ist ein Vektor)  \nis.vector(1)\n# ergibt TRUE\n\nUm Werte zu längeren Vektoren zu Verknüpfen wird die Verbindenfunktion c() benutzt. Diese Funktion verbindet Vektoren so dass die Werte der Eingabevektoren im Ergebnisvektore nacheinander in der Reihenfolge der Eingabe vorliegen.\n\nBeispiel 6.9 (Erzeugen eines Vektors aus einzelnen Werten)  \nc(1, 2, 3)\n# ergibt {1, 2, 3}\n\nDie c()-Funktion hat immer einen Vektor als Ergebnis. Werden Vektoren als Eingabe verwendet, dann werden die Vektoren zu einem neuen Vektor zusammengefügt.\n\nBeispiel 6.10 (Erzeugen eines Vektors aus mehreren Vektoren)  \nc(c(3, 4), c(1, 2), c(5, 6))\n# ergibt {3, 4, 1, 2, 5, 6}\n\nVersucht man Vektoren aus Werten mit unterschiedlichen Datentypen zu erstellen, dann werden alle Werte in den allgemeinsten auftredenten Datentyp umgewandelt. Dabei gilt die Reihenfolge vom allgemeinsten Datentyp zum speziellsten Datentyp: Zeichenkette, Zahl, Wahrheitswert.\n\nBeispiel 6.11 (Erzeugen eines Vektors mit unerschiedlichen Datentypen)  \nc(1, TRUE, \"Daten und Information\")\n# ergibt {\"1\", \"TRUE\", \"Daten und Information\"}\n\nc(1, TRUE, 2 FALSE)\n# ergibt {1, 1, 2, 0}\n\nAlle Vektoren haben eine Länge, die mit der Funktion length() ermittelt wird.\n\nBeispiel 6.12 (Länge eines Vektor bestimmen)  \nlength(c(1,3,7))\n# ergibt 3\n\nDamit einzelne Werte eines Vektors angesprochen werden können, müssen eckige Klammern ([]) verwendet werden.\n\nBeispiel 6.13 (Ein Vektorelement über dessen Index ansprechen)  \nc(1, 7, 13) -&gt; vektor123\n\nvektor123[2] # ergibt 7\n\n\n\n\n\n\n\nPraxis\n\n\n\nIn der Regel werden die einzelnen Elemente von Vektoren nicht über den Index angesprochen. Im Gegensatz zu anderen Programmiersprachen hat die Verwendung des Vektorindex in R keine grosse Bedeutung.\n\n\nVektoren sind eingeschränkt auf eine Dimension. Um komplexere Datenstrukturen zu erhalten, müssen weitere Datenstrukturen hinzugezogen werden.\n\n\n6.2.2 Listen\nListen ähneln Vektoren in vielen Punkten. Der zentrale Unterschied zwischen Listen und Vektoren ist, dass die Elemente von Listen einen beliebigen Datentyp haben dürfen. Listen werden in R mit der Funktion list() erzeugt.\n\nBeispiel 6.14 (Erzeugen einer Liste aus einzelnen Werten)  \nlist(1, TRUE, \"Daten und Information\")\n# erzeugt {1, TRUE, \"Daten und Information\"}\n\nDie Funktion is.list() überprüft, ob ein Wert eine Liste ist. Die Funktion length() liefert die Anzahl der Elemente in einer Liste.\nIm Vergleich zur Funktion c() fügt die Funktion list() Listen nicht zusammen, sondern behandelt alle Eingabewerte als eigene Elemente. D.h. der Datentyp jedes Werts bleibt erhalten, wenn dieser einer Liste hinzugefügt wird. Diese Eigenschaft lässt sich ausnutzen, um geschachtelte Datenstrukturen zu erzeugen. Beispiel 6.15 zeigt die Erstellung einer geschachtelten Liste mit zwei unterschiedlich langen Vektoren.\n\nBeispiel 6.15 (Geschachtelte Liste mit zwei Vektoren)  \nlist(c(1, 2), c(3, 4, 5))\n\nDer Listen verwenden zur Indizierung doppelte eckige Klammern ([[]]). Nur so lassen sich die Werte der Liste korrekt referenzieren.\n\nBeispiel 6.16  \nlist(1, TRUE, \"Daten und Information\") -&gt; gemischteListe \n\ngemischteListe[[3]]\n# ergibt \"Daten und Information\"\n\n\n\n\n\n\n\nWarnung\n\n\n\nDer Vektorindex kann auch für Listeneinträge verwendet werden. In diesem Fall wird eine Liste zurückgegeben, die nur die ausgewählten Listenelemente enthält. Das ist normalerweise nicht gewünscht.\n\n\n\n6.2.2.1 Benannte Listen\nListeneinträge können Namen haben. Diese können später zum Referenzieren der Listeneinträge verwendet werden. Auf diese Weise lassen sich objektartige Strukturen erzeugen. Benannte Einträge lassen sich über die Position des Werts oder dem Namen als Index ansprechen. Wird ein Name als Index verwendet, dann muss dieser als Zeichenkette angegeben werden. Häufiger findet sich jedoch die Dollar-Referenzierung in R-Skripten. Die Dollar-Referenzierung verwendet das Dollar-Zeichen ($) um auf einen Namen zuzugreifen. Damit diese Referenzierung funktioniert, muss der Name ein gültiges R-Symbol sein, dass nicht markiert werden muss. Alle anderen Namen müssen als Listenindex verwendet werden. Beispiel 6.17 zeigt die verschiedenen Zugriffsarten für benannte Listen.\n\nBeispiel 6.17 (Verwendung benannter Listen)  \nlist(modul = \"Daten und Information\", \n     semester = 1) -&gt; \n        benannteListe\n\nbenannteListe[[2]] # ergibt 1\nbenannteListe[[\"semester\"]] # ergibt 1\nbenannteListe$semester # ergibt 1\n\n\n\n\n\n\n\nHinweis\n\n\n\nIn R müssen nicht alle Listeneinträge benannt sein. Es ist normal, dass sowohl benannte als auch unbenannte Listenelemente vorhanden sind. Unbenannte Listeneinträge können nur über ihre Position angesprochen werden.\n\n\n\n\n\n6.2.3 Matrizen\nAls vektororientierte Sprache ist die Matrix ein wichtiges Konstrukt der Datenstrukturierung. Alle Werte einer Matrix müssen vom Datentyp Zahl sein. Man kann sich eine Matrix als Vektor von gleichlangen Vektoren vorstellen. Wegen der besonderen Eigenschaften von R-Vektoren ist diese Art der Schachtelung jedoch nicht möglich.\nEine Matrix wird in R immer aus Vektoren erzeugt. Dafür gibt es vier Wege.\nEine Matrix wird aus einem Vektor über die Zeilenzahl m erstellt. Dabei werden immer m aufeinanderfolgende Werte eines Vektors in eine Spalte geschrieben.\n\nBeispiel 6.18 (eine m-Matrix aus einem Vektor erstellen)  \nmatrix(c(1,2,3,4,5,6), nrow = 2)\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nEine Matrix wird aus einem Vektor über die Spaltenzahl n erstellt. Dazu wird der Vektor in n grosse Blöcke aufeinanderfolgender Werte gegliedert, die jeweils in eine Spalte geschrieben werden.\n\nBeispiel 6.19 (eine n-Matrix aus einem Vektor erstellen)  \nmatrix(c(1,2,3,4,5,6), ncol = 2)\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\nEine Matrix wird über das Kreuzprodukt (Kapitel 13) aus zwei Vektoren erstellt.\n\nBeispiel 6.20  \nc(1, 2, 3) %*% t(c(3, 4, 5))\n     [,1] [,2] [,3]\n[1,]    3    4    5\n[2,]    6    8   10\n[3,]    9   12   15\n\n\n\n\n\n\n\nWarnung\n\n\n\nWird lässt sich der Ausgangsvektor nicht in die angegebene Zeilen- oder Spaltenzahl gliedern, dann werden die Vektorwerte solange wiederholt, bis die Matrix aufgefüllt wurde und eine eine Warnrmeldung ausgegeben. Dadurch ist das Ergebnis nicht immer klar nachvollziehbar.\n\n\nEine Matrix wird über das äussere Matrixprodukt (Kapitel 13) aus zwei Vektoren erstetllt.\n\nBeispiel 6.21 (eine -Matrix aus einem Vektor erstellen)  \nc(1, 2, 3) %o% c(3, 4, 5)\n     [,1] [,2] [,3]\n[1,]    3    4    5\n[2,]    6    8   10\n[3,]    9   12   15\n\n\n\n\n\n\n\nPraxis\n\n\n\nDas Kreuzprodukt sollte nicht zum Erzeugen von Matrizen verwendet, sondern ausschliesslich als mathematische Operation behandelt werden. Das äussere Produkt ist flexibler und einfacher anzuwenden.\n\n\nMit der Funktion is.matrix() kann überprüft werden, ob eine Datenstruktur eine Matrix ist. Erfüllt eine tabellarische Struktur die Kriterien für eine Matrix, dann kann diese Struktur mit der Funktion as.matrix() in eine Matrix umgewandelt werden.\nDie R-Matrix ähnelt der Struktur von Vektoren.\n\nEine Matrix hat eine Länge. Diese Länge entspricht der Gesamtzahl der Elemente der Matrix.\nWird eine Matrix in der Funktion c() als Wert übergeben, dann wird die Matrix zuerst in einen Vektor umgewandelt.\n\nWeil die Anzahl der Spalten und Zeilen nicht über die Länge bestimmt werden kann, muss zu diesem Zweck die Funktion dim() verwendet werden. dim() gibt die Anzahl der Zeilen und der Spalten in dieser Reihenfolge aus.\nDie Werte in einer R-Matrix können über den Zeilen- und Spaltenindex abgefragt werden. Dazu werden wie bei den Vektoren einfache eckige Klammern verwendet. Der Zeilen- und Spaltenindex werden dabei durch ein Komma voneinander getrennt.\n\nBeispiel 6.22 (Einen Wert über den Matrix-Index zugreifen)  \nc(1, 2, 3) %o% c(3, 4, 5) -&gt; matrix123\nmatrix123[2,2] # ergibt 8\n\nWird beim Matrix-Index der Zeilen- oder der Spaltenindex weggelassen, wird eine ganze Zeile bzw. Spalte als Vektor ausgewählt.\n\n\n\n\n\n\nPraxis\n\n\n\nÄhnlich wie bei Vektoren, ist es in der Praxis nur sehr selten notwendig, auf die Werte einer Matrix zuzugreifen.\n\n\n\n\n6.2.4 Data-Frames\nEin Data-Frame ist eine benannte geschachtelte Liste mit Vektoren gleicher Länge. Diese Datenstruktur ist die Basis für Datentabellen. Anders als eine normale geschachtelte Liste stellt ein Date-Frame zusätzlich sicher, dass alle Vektoren immer die gleiche Länge haben.\nData-Frames werden normalerweise mit den Funktionen tibble() oder tribble() erstellt. Diese Funktionen sind nur in tidy R verfügbar. Diese Funktionen erzeugen eine effizienteren und damit schnelle Version eines Data-Frames als Base R.\n\n\n\n\n\n\nPraxis\n\n\n\nData-Frames werden normalerweise beim Einlesen der Daten mit der korrekten Datenstruktur automatisch erzeugt. Händisches Erstellen von Date-Frames ist dann nicht mehr notwendig.\n\n\nWeil Data-Frames spezielle Listen sind, können sie genau gleich wie Listen behandelt werden. Es lassen sich damit die gleichen Zugriffe, wie bei Listen umsetzen.\n\n\n\n\n\n\nHinweis\n\n\n\nVektoren in Data-Frames können Listen als Datentyp haben, was bei normalen Vektore nicht möglich ist. Diese besondere Eigenschaft wird im Kapitel 16 ausgenutzt.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nDie Behandlung von Data-Frames als geschachtelte Listen ist inzwischen unüblich. Stattdessen sollten die effizienteren und leichter zu merkenden Transformationsschritte eingesetzt werden."
  },
  {
    "objectID": "kapitel/daten-importieren-exportieren/kapitel.html#daten-importieren",
    "href": "kapitel/daten-importieren-exportieren/kapitel.html#daten-importieren",
    "title": "7  Importieren und Exportieren",
    "section": "7.1 Daten importieren",
    "text": "7.1 Daten importieren\nDas Einlesen von Datendateien ist ein zentraler Bestandteil von R, weil es die Voraussetzung für die statistische Programmierung bildet. Diese Funktionen gehen jedoch nicht sehr sparsam mit dem Arbeitsspeicher unseres Computers um, sodass sehr grosse Datenmengen immer wieder zu Problemen führen.\nDie readr-Bibliothek ersetzt die Base R-Funktionen zum Einlesen von Dateien durch flexiblere und effizientere Funktionen. Diese Funktionen können mit grösseren Datenmengen umgehen und schonen den verfügbaren Arbeitsspeicher. Deshalb sind die readr-Funktionen den jeweiligen Gegenstücken von Base R vorzuziehen.\n\n7.1.1 Dateitypen\nFür den Austausch von Stichproben stehen verschiedene Dateiformate zur Verfügung. Diese Dateiformate unterscheiden sich durch die Strategie, mit der die Werte in den einzelnen Tabellenzellen unterschieden werden.\nDie wichtigsten Formate sind:\n\nTabulator getrennte Werte (TSV, tabulator-separated values)\nKomma getrennte Werte (CSV, comma-separated values)\nExcel Tabellen (via readxl-Bibliothek)\nFixformat Tabellen (FWF, fixed-width format)\nR-Datendateien (RDS, R-data structure)\n\nDiese Dateien können wir mit den folgenden Funktionen einlesen.\n\n\n\n\n\n\n\n\nFormat\ntidy R\nBase R\n\n\n\n\ntxt (ganze Datei)\nread_file()\nreadChar() + file.info()\n\n\ntxt (zeilenweise)\nread_lines()\nreadLines() + file()\n\n\ncsv (mit , als Trennzeichen)\nread_csv()\nread.csv()\n\n\ncsv (mit ; als Trennzeichen)\nread_delim() oder read_csv2()\nread.csv2()\n\n\ntsv\nread_tsv()\nread.table()\n\n\nxls (Excel Arbeitsmappen mit readxl)\nread_excel()\n-\n\n\nFWF\nread_fwf()\n-\n\n\nRDS\nread_rds()\nreadRDS()\n\n\n\nDie Base R Funktionen read.table(), read.csv und read.csv2() importieren Zeichenketten als Faktoren (s. Kapitel 6). Damit können diese Werte nicht direkt als Zeichenketten behandelt werden. Diese automatische Behandlung entfällt bei den jeweiligen tidy R Varianten. Dadurch lassen sich Daten intuitiver bearbeiten.\n\n\n\n\n\n\nAchtung\n\n\n\nIn der Schweiz kann das CSV-Format zu Verwirrung führen, weil sehr häufig das Semikolon als Spaltentrennzeichen und der Punkt als Dezimaltrennzeichen verwendet werden. Die Ursache für diese Situation sind CSV-Dateien, die aus Excel exportiert wurden.\nDie normalerweise für dieses Format empfohlene Funktion read_csv2() behandelt Dezimalzahlen fälschlich als Ganzzahlen. Um dieses Problem zu beheben, sollte das Dezimaltrennzeichen laut Dokumentation wie folgt angepasst werden:\nread_csv2(datei_name, locale = local(decimal_mark = \".\"))\nDieser Aufruf funktioniert jedoch nicht!\nHier greift die Funktion read_delim(). Wird dieser Funktion nur ein Dateiname übergeben, dann prüft die Funktion auf die verschiedenen Trennzeichen. Dieser (undokumentierte) Algorithmus erkennt Schweizer CSV-Dateien korrekt.\nread_delim(datei_name)\nDieser Aufruf importiert die Werte wie erwartet.\n\n\nBei der modernen read_ Variante können wir uns leicht an der Dateiendung orientieren, um die richtige read_-Funktion auszuwählen.\nWenn eine Datei eingelesen wird, dann gibt die jeweilige read_-Funktion neben den Daten auch zurück, wie die Datei eingelesen wurde. Enthält die eingelesene Datei die erwarteten Spaltenüberschriften, dann wurde das richtige Dateiformat ausgewählt.\n\n\n7.1.2 Dateien mit einer Spalte\nCSV-Dateien können mit Komma oder Semikolon als Trennzeichen erstellt werden. Die Funktion read_delim() liest diese Dateien meistens korrekt ein. Falls eine Datei mit nur einem Datenvektor importiert werden muss, dann kann R das Spaltentrennzeichen nicht finden. In solchen Fälle muss die Datei mit der read_csv() oder read_csv2()-Funktion noch einmal eingelesen werden.\nFür Spalten mit Zeichenketten oder Ganzzahlen wird immer die Funktion read_csv() verwendet.\nFür Gleitkommazahlen erfolgt die Auswahl auf Grundlage des verwendeten Dezimaltrennzeichens. Wird der Dezimalpunkt verwendet, dann muss die Funktion read_csv() benutzt werden. Wird das Dezimalkomma verwendet, dann muss die Funktion read_csv2() eingesetzt werden.\n\n\nBeispiel 7.1 (Datei mit einer Spalte importieren) Mit dem Aufruf read_csv(\"beispieldaten.csv\") werden Daten mit einem Komma als Trennzeichen und mit Dezimalpunkt eingelesen.\nMit dem Aufruf read_csv2(\"beispieldaten.csv\") werden Daten mit einem Semikolon als Trennzeichen und mit Dezimalkomma eingelesen.\nIn beiden Fällen nutzen wir dieses Verhalten aus, um eine Stichprobe mit nur einer Spalte einzulesen.\n\n\n\n\n7.1.3 Excel Arbeitsmappen\n\n\n\n\n\n\nPraxis\n\n\n\nLiegen Daten in einer Excel Arbeitsmappe vor, dann muss diese Arbeitsmappe nicht in ein anderes Dateiformat umgewandelt werden, damit die Daten in R importiert werden können.\n\n\nIn Excel werden Daten in Arbeitsmappen organisiert. Es ist also möglich, mehr als eine Tabelle und darauf basierende Operationen in einer Datei zu speichern. Damit Daten aus Arbeitsmappen in R importiert werden können, müssen die Struktur der Arbeitsmappe bekannt sein.\nEine Excel Arbeitsmappe ist eine Datei, die üblicherweise auf .xlsx endet. Die Dateiendung signalisiert uns meistens die interne Organisation einer Datei. Interne Organisation einer Datei bedeutet, in welcher Folge die Daten in einer Datei auf der Festplatte abgelegt sind.\nNur das Dateiformat von .xlsx-Dateien unterstützt alle Funktionen von Excel und kann von R korrekt eingelesen werden\nDas Dateiformat wird in Excel im Speichern-Unter-Dialog festgelegt. Dieser Dialog erscheint in der Regel, wenn eine neue Arbeitsmappe das erste Mal gespeichert wird. Wenn im Start-Dialog von Excel einfach eine neue Arbeitsmappe erstellt wird, dann erzeugt Excel automatisch eine Arbeitsmappe im Excel-Format.\n\n\n\n\n\n\nMerke\n\n\n\nExcel-Dateien sind Dateien mit der Endung .xlsx oder .xlsund werden als Excel Arbeitsmappen bezeichnet. Nur Dateien mit dieser Endung können in R als Excel-Datei importiert werden.\n\n\nExcel Arbeitsmappen haben vier zentrale Strukturelemente:\n\nArbeitsblätter\nAdressbereiche\nZellenwerte\nZellenformeln\n\nJedes Arbeitsblatt einer Arbeitsmappe hat einen eindeutigen Namen.\nDie Adressbereiche sind in Zeilen und Spalten gegliedert. Wir finden Daten daher immer auf einem bestimmten Arbeitsblatt in einem bestimmten Adressbereich. Die konkrete Position der Daten in der Arbeitsmappe legen die Autoren willkürlich fest.\nJede Zelle eines Arbeitsblatts hat immer zwei gleichzeitige Zustände, die immer in einer Excel Arbeitsmappe gespeichert werden:\n\nJede Zelle hat einen Wert.\nJede Zelle hat eine Operation.\n\nAus diesen Strukturelementen ergeben sich zwei Konsequenzen:\n\nEin Arbeitsblatt kann mehr als eine Tabelle mit Daten enthalten.\nDie Daten müssen nicht am Anfang (d.h. in der ersten Zeile und ersten Spalte) eines Arbeitsblatts beginnen.\n\nUm mit den Daten in Excel Arbeitsmappen arbeiten zu können, müssen bekannt sein, auf welchem Arbeitsblatt und in welchem Adressbereich die Daten stehen.\n\n\n\n\n\n\nMerke\n\n\n\nTabellen sind keine Strukturelemente von Excel Arbeitsmappen, die in R zugänglich sind.\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nWenn Excel Arbeitsmappen mit Excel geöffnet werden, dann berechnet Excel alle Operationen auf allen Arbeitsblättern neu. Damit werden die Werte in der Arbeitsmappe verändert.\nEs kommt also vor, dass sich eine Arbeitsmappe ändert, ohne dass eine Interaktion vorgenommen wurde. In diesen Fällen fragt Excel beim Schliessen der Arbeitsmappe, ob die Änderungen gespeichert werden sollen.\nWird eine Excel Arbeitsmappe in R (oder in einer anderen Programmiersprache) geöffnet, dann wird nur die Arbeitsmappe geöffnet ohne die Operationen neu zu berechnen.\n\n\nMit den Funktionen der readxl-Bibliothek können wir Excel Arbeitsmappen nach R importieren. Dabei sind zwei Funktionen von besonderer Bedeutung:\n\nexcel_sheets(dateiname) und\nread_excel(dateiname, sheet)\n\nMit der Funktion excel_sheets() können die vorhandenen Arbeitsblätter erkannt werden. Das Ergebnis dieser Funktion ist die Liste der Arbeitsblattnamen in einer Arbeitsmappe. Diese Funktion sollte vor dem Import von Daten zur Kontrolle der Arbeitsblattnamen verwendet werden.\nDie Funktion read_excel() erlaubt es einzelne Arbeitsblätter zu importieren. Wenn kein Arbeitsblattname für den Parameter sheet übergeben wird, dann nimmt die Funktion das aktive oder das erste Arbeitsblatt in der Arbeitsmappe.\nMit den readxl-Funktionen können keine Formeln aus den Zellen ausgelesen werden.\n\nBeispiel 7.2 (Excel-Arbeitsmappe importieren)  \nlibrary(readxl)\n\nArbeitsblaetter = excel_sheets(\"Bestellungen_2.xlsx\")\n# Das Arbeitsblatt \"Daten\" sollte vorhanden sein.\n\nDaten = read_excel(\"Bestellungen_2.xlsx\", \"Daten\")\n\nDie Funktion read_excel() importiert alle Daten auf einem Arbeitsblatt. Enthält nur ein bestimmter Bereich auf einem Arbeitsblatt die Daten von Interesse, dann muss dieser Bereich als Excel-Bereichsadresse angegeben werden.\n\n\n\n\n\n\nWarnung\n\n\n\nread_excel() kann nur mit Excels Arbeitsblattadressen umgehen. Tabellenadressen oder die Gatter-Notation beherrscht die Funktion nicht."
  },
  {
    "objectID": "kapitel/daten-importieren-exportieren/kapitel.html#daten-exportieren",
    "href": "kapitel/daten-importieren-exportieren/kapitel.html#daten-exportieren",
    "title": "7  Importieren und Exportieren",
    "section": "7.2 Daten exportieren",
    "text": "7.2 Daten exportieren\nR unterstützt den Export strukturierter Daten in Textdateien. Beim Exportieren kommen für die Formate TSV und CSV werden die entsprechenden Funktionen write_tsv(), write_csv() und write_csv2() benutzt. Für speziellformatierte Dateien kann die Funktion write_delim() eingesetzt werden.\nAlle Export-Funktionen erwarten eine Datenstruktur als ersten Parameter und einen Dateinamen als zweiten Parameter. Der Dateiname legt fest, wohin das Ergebnis der Funktion auf dem Computer geschrieben werden soll.\nDie Import- und Export-Funktionen lassen sich zu einfachen Konvertierungsprogrammen verknüpfen. Beispiel 7.3 korrigert von Excel exportierte CSV-Dateien in ein gültiges CSV-Format.\n\nBeispiel 7.3 (“Schweizer” CSV-Format korrigieren)  \nlibrary(readr)\n\nwrite_csv(\n    read_delim(\"Bestellungen_Excel.csv\"), \n    \"Bestellungen_korrigiert.csv\" \n)\n\n\n\n\n\n\n\nWarnung\n\n\n\nR kann Excel Arbeitsmappen nicht exportieren. Die readr-Funktionen write_excel_csv() und write_excel_csv2() exportieren CSV-Dateien mit einer zusätzlichen Markierung am Dateianfang. Diese Funktionen sollten nur verwendet werden, wenn eine CSV-Datei nur mit Excel importiert werden soll und nicht für die Archivierung oder Weiterverarbeitung gedacht ist.\nDie zusätzliche Markierung wird als Byte Order Mark (BOM) bezeichnet und muss das UTF8-Symbol FEFF sein. Dieses Symbol ist ein Leerzeichen ohne Länge und wird deshalb nie dargestellt. Excel bzw. Power Query verwenden das BOM, um UTF8-kodierte Dateien zu identifizieren."
  },
  {
    "objectID": "kapitel/daten-importieren-exportieren/kapitel.html#json-daten",
    "href": "kapitel/daten-importieren-exportieren/kapitel.html#json-daten",
    "title": "7  Importieren und Exportieren",
    "section": "7.3 JSON-Daten",
    "text": "7.3 JSON-Daten\nJSON ist ein Datenformat, dass von vielen sog. Web-Diensten zum Austausch von Datenstrukturen eingesetzt wird. R kann dieses Datenformat mit der tidyverse-Bibliothek jsonlite importieren und auch exportieren. jsonlite stellt zwei Funktionen für den regelmässigen Einsatz bereit:\n\nfromJSON()\ntoJSON()\n\nDie beiden Funktionen fromJSON() und toJSON() unterstützen das Parsen von und Serialisieren zu Zeichenketten im JSON-Format.\nUm Daten aus einer Textdatei im JSON-Format zu importieren, muss die gesamte Datei zuerst eingelesen werden und dann an den JSON-Parser fromJSON() übergeben werden.\n\nBeispiel 7.4 (JSON Daten aus einer Datei importieren)  \nlibrary(jsonlite)\n\nDaten = fromJSON(read_file(\"beispiele/daten.json\"))\n\nMit der Funktion toJSON() werden Daten in eine JSON-formatierte Zeichenkette umgewandelt. Diese Zeichenkette kann anschliessend mit write_file() in eine Datei geschrieben werden.\n\nBeispiel 7.5 (Daten im JSON-Format exportieren)  \nwrite_file(toJSON(Daten),\"neue_daten.json\"))\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie beiden Funktionen read_json() und write_json() erlauben das Lesen und Schreiben von Textdateien im JSON-Format. Die Standardeinstellungen sind jedoch nicht identisch mit denen von fromJSON() und toJSON(), so dass der Import und Export mit diesen Funktionen komplexer ist, als mit der oben beschrieben Technik."
  },
  {
    "objectID": "kapitel/daten-importieren-exportieren/kapitel.html#festkodierte-daten",
    "href": "kapitel/daten-importieren-exportieren/kapitel.html#festkodierte-daten",
    "title": "7  Importieren und Exportieren",
    "section": "7.4 Festkodierte Daten",
    "text": "7.4 Festkodierte Daten\nR unterstützt den Import von festkodierten Daten nicht direkt. Festkodierte Daten benötigen einen eigenen Parser, der die Datenfelder extrahiert. Die prinzipielle Vorgehensweise ähnelt dem Import und Export von JSON-Daten. Dazu werden die Daten als unstrukturierte Textdaten mit der Funktion read_file() eingelesen. Anschliessend werden die Datenfelder mit Zeichenketten-Operationen (Kapitel 9) einzeln extrahiert. Beim Exportieren müssen die Daten zuerst serialisiert werden und anschliessend mit der Funktion write_file() in die entsprechende Datei geschrieben werden."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#variablen",
    "href": "kapitel/variablen/kapitel.html#variablen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.1 Variablen",
    "text": "8.1 Variablen\nVariablen sind spezielle R Symbole (s. Kapitel 4) mit denen Werte für die spätere Verwendung markiert werden. Variablen sind also Bezeichner, welche die eigentlichen Werte substituieren.\nDamit eine Variable einen Wert substituieren kann, muss der Wert der Variablen zugewiesen werden. Ein Wert kann dabei ein einzelner Wert eines fundamentalen Datentyps oder eine komplexe Datenstruktur sein.\nBei der ersten Zuweisung wird eine Variable deklariert (Definition 4.3).\n\nBeispiel 8.1 (Den Wert 1 der Variable var1 zuweisen)  \nvar1 = 1\n\nVariablen müssen in einem Geltungsbereich eindeutig sein. Wird nämlich einer Variable mehrfach zugewiesen, dann ist der Wert einer Variablen der Wert der letzten Zuweisung.\nDer Geltungsbereich (engl. Scope) einer Variablen wird durch Funktionskörper definiert. R kennt dabei drei Arten von Geltungsbereichen. In diesem Zusammenhang spricht man von äusseren (engl. outer scope) und inneren Geltungsbereichen (engl. inner scope).\nGrundsätzlich können alle Variablen in einem Geltungsbereich verwendet werden, die in einem der äusseren Geltungsbereiche deklariert und zugewiesen wurden. Variablen der inneren Geltungsbereiche sind in den äusseren Geltungsbereichen nicht verfügbar.\nDer globale Geltungsbereich gilt für alle Variablen, die ausserhalb einer Funktion oder einer Bibliothek erzeugt werden.\nDer Funktionsgeltungsbereich ist auf den Funktionsköper einer Funktion beschränkt.\nDer Modulgeltungsbereich ist der globale Geltungsbereich einer Funktionsbibliothek. Variablen dieses Geltungsbereichs sind im globalen Geltungsbereich eines R-Scripts nicht erreichbar. In der Praxis spielt dieser Geltungsbereich eine untergeordnete Rolle\n\n\n\n\n\n\nWarnung\n\n\n\nDie letzte Zuweisung ist nicht zwingend die Zuweisung, die als letztes im Code erscheint."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#funktionen",
    "href": "kapitel/variablen/kapitel.html#funktionen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.2 Funktionen",
    "text": "8.2 Funktionen\nIn R bilden Funktionen die Grundlage für die Datenverarbeitung.\n\n\n\n\n\n\nMerke\n\n\n\nEine Funktion ist für R ein Wert wie eine Zahl oder eine Zeichenkette.\n\n\nIm Fall von Funktionen ist der Wert einer Funktion die Funktionsdeklaration. Entsprechend ist es möglich Funktionen zu überschreiben.\nWird nur der Bezeichner einer R gibt eine direkte Funktionsdefinition wie jeden anderen Wert direkt aus.\n\n8.2.1 Operatoren\nAlle R-Operatoren sind Funktionen. R kennt 29 vordefinierte Operatoren, die zwei Werte verknüpfen. Zu diesen Operatoren gehören die auch die arithmetischen Operatoren für die Grundrechenarten.\n\n\nTabelle 8.1: Liste der Base R Operatoren\n\n\n\n\n\n\n\nOperator\nBeschreibung\nArt\n\n\n\n\n+\nPlus, sowohl unär als auch binär\narithmetisch\n\n\n-\nMinus, sowohl unär als auch binär\narithmetisch\n\n\n*\nMultiplikation, binär\narithmetisch\n\n\n/\nDivision, binär\narithmetisch\n\n\n^\nPotenz, binär\narithmetisch\n\n\n%%\nModulo, binär\narithmetisch\n\n\n%/%\nGanzzahldivision, binär\narithmetisch\n\n\n%*%\nMatrixprodukt, binär\narithmetisch, Matrix\n\n\n%o%\näusseres Produkt, binär\narithmetisch, Matrix\n\n\n%x%\nKronecker-Produkt, binär\narithmetisch, Matrix\n\n\n&lt;\nKleiner als, binär\nlogisch\n\n\n&gt;\nGrösser als, binär\nlogisch\n\n\n==\nGleich, binär\nlogisch\n\n\n!=\nUngleich, binär\nlogisch\n\n\n&gt;=\nGrösser oder gleich, binär\nlogisch\n\n\n&lt;=\nKleiner oder gleich, binär\nlogisch\n\n\n%in%\nExistenzoperator, binär\nlogisch\n\n\n!\nunäres Nicht\nlogisch\n\n\n&\nUnd, binär, vektorisiert\nlogisch\n\n\n&&\nUnd, binär, nicht vektorisiert\nlogisch\n\n\n|\nOder, binär, vektorisiert\nlogisch\n\n\n||\nOder, binär, nicht vektorisiert\nlogisch\n\n\n&lt;-, &lt;&lt;-, =\nlinksgerichtete Zuweisung, binär\nZuweisung\n\n\n-&gt;, -&gt;&gt;\nrechtsgerichtete Zuweisung, binär\nZuweisung\n\n\n[\nIndexzugriff (Vektoren), binär\nIndex\n\n\n$, [[\nListenzugriff, binär\nIndex\n\n\n~\nfunktionale Abhängigkeit, sowohl unär als auch binär\nFunktionen\n\n\n:\nSequenz (in Modellen: Interaktion), binär\nFunktionen\n\n\n?\nHilfe\nspezial\n\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nIm R-Umfeld wird oft von Modellen geschrieben und gesprochen. Modelle sind spezielle Funktionen, die Beziehungen zwischen Daten beschreiben, ohne eine mathematisch exakte Beziehung vorzugeben. Modelle werden in der Statistik und Stochastik eingesetzt, wenn die exakten Beziehungen zwischen Daten unbekannt sind.\n\n\n\nBeispiel 8.2 (Exakte lineare Beziehung zwischen Daten)  \nf = function (x) 2 * x + 3\n\n\nBeispiel 8.3 (Beziehung zwischen Daten mit Interaktion als Modell)  \nf = y ~ x : c\n\nHinter jedem Operator steht eine Funktion, die mit den beiden Operanden als Parameter ausgeführt wird, um das Ergebnis des Operators zu bestimmen. Daraus folgt, dass jeder Operator auch als Funktionsbezeichner verwendet werden kann. In diesem Fall muss R mitgeteilt werden, dass der Operator nun als Funktionsbezeichner verwendet werden soll. Der Operator muss also mit Backticks als Bezeichner markiert werden.\n\nBeispiel 8.4 (+-Operator als Funktionsbezeichner)  \n`+`(1, 2)\n3\n\n\n8.2.1.1 Zuweisungsoperatoren\nR kennt zwei Zuweisungsoperatoren: &lt;- und -&gt;. Die Zuweisung erfolgt in Richtung des Pfeils. Daneben wird der =-Operator ebenfalls als (inoffizieller) Zuweisungsoperator unterstützt.\nEin Zuweisungsoperator erwartet immer einen Bezeichner und eine Operation als Parameter. Das Ergebnis der Operation wird als Wert dem Bezeichner zugewiesen.\nWeil nicht immer klar ist, ob &lt;- oder = verwendet werden soll, lautet die offizielle Kommunikation, dass für Variablenzuweisungen der &lt;--Operator verwendet werden sollte. Das einfache Gleich (=) weist einen Wert einem Funktionsparameter zu. Gerade in tidy R ist dieser Unterschied nur schwer nachvollziehbar, weil bestimmte Parameter wie Variablen behandelt werden.\n\n\n\n\n\n\nHinweis\n\n\n\nIn diesem Buch wird für die linksgerichtete Zuweisung immer das Gleichzeichen (=) verwendet, so dass eine Zuweisung eines Werts an eine Variable und an einen Parameter gleichwertig behandelt wird. Dadurch wird die Lesart etwas vereinfacht. Zusätzlich wird die rechtsgerichtete Zuweisung konsequent als Abschluss für einen primären Datenstrom (s. Kapitel 8.2.2) eingesetzt.\n\n\n\n\n8.2.1.2 Ausführungsoperator\nDer Ausführenoperator (()) gilt in R offiziell nicht als Operator, weil dieser nicht als Funktion umgesetzt werden kann. Es gibt zwar die Funktion do.call(), um eine Funktion auszuführen. Wenn diese Funktion als Ausführungsoperator eingesetzt wird, müsste do.call() sich selbst aufrufen, um sich selbst auszuführen. Dieses Problem wird von R dadurch gelöst, dass ( und ) als eigene Symbole erkannt werden und immer eine Funktionsausführung anzeigen.\n\n\n8.2.1.3 Hilfeoperator\nDer Hilfeoperator ist ein besonderer Operator, weil dieser die Interaktion mit der Dokumentation von Funktionen und Konzepten ermöglicht. Der Hilfeoperator wird normalerweise nicht in einem R-Script verwendet und hat keine Bedeutung für die Datenverarbeitung.\nDer Hilfeoperator kann direkt mit einem Bezeichner aufgerufen werden. Existiert für den Bezeichner eine Dokumentation, dann wird diese angezeigt.\n\nBeispiel 8.5 (Dokumentation der Funktion is.character())  \n?is.character\n\nWird der Hilfeoperator mit sich selbst aufgerufen, wird der nächste Wert als Suchbegriff gewertete und eine Suche über alle Hilfedokumente auf dem System durchgeführt.\n\nBeispiel 8.6 (Dokumentationssuche nach Operatoren)  \n??operator\n\n\n\n\n8.2.2 Funktionsketten\nR unterstützt die spezielle Funktionsverkettung mit dem |&gt;- Operator. Dadurch lassen sich Funktionsfolgen direkt in R ausdrücken. In Kombination mit der rechtsgerichteten Zuweisung (-&gt;) ist es möglich, Datenströme durch eine Funktionskette von einem Ausgangswert zu einem Ergebnis in der natürlichen Reihenfolge aufzuschreiben.\n\nBeispiel 8.7 (Funktionskette mit abschliessender Zuweisung)  \n# library(tidyverse)\niris |&gt;\n    filter(Species == \"setosa\") |&gt;\n    arrange(desc(Petal.Length)) -&gt; \n        sortierteSetosaWerte\n\nNeben der speziellen Funktionsverkettung (|&gt;) gibt es einen sehr ähnlichen Verkettungsoperator: %&gt;%. Dieser Verkettungsoperator ist Teil der tidyverse-Bibliothek und gleicht der speziellen Funktionsverkettung mit dem kleinen Unterschied, dass die Parameterzuweisung für die nachfolgende Funktion zusätzliche Kontrollmöglichkeiten bietet, die der speziellen Funktionsverkettung fehlen."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#eigene-funktionen-erstellen",
    "href": "kapitel/variablen/kapitel.html#eigene-funktionen-erstellen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.3 Eigene Funktionen erstellen",
    "text": "8.3 Eigene Funktionen erstellen\nIn R werden Funktionen mit dem function-Schlüsselwort erstellt. Eine R-Funktion besteht aus einer Parameterliste und einem Funktionskörper. Die Parameterliste wird in Klammern hinter dem Wort function angegeben. Der Funktionskörper kann eine einzelne Operation oder ein Block sein. Das Ergebnis einer Funktion ist das Ergebnis der letzten Operation des Funktionskörpers.\nBeispiel 8.8 zeigt eine Funktionsdeklaration, die einen parameter akzeptiert. Die Funktion quadriert diesen Wert und zieht vom Ergebnis 1 ab. An diesen Operationen wird erkannt, dass die Funktion nur Werte vom Datenyp Zahlen als parameter akzeptiert.\nParameter sind in R spezielle Variablen, mit denen Werte an eine Funktion übergeben werden. Parameter existieren nur innerhalb einer Funktion während der Ausführung des Funktionskörpers. Es kommt sehr häufig vor, dass ausserhalb einer Funktion Variablen mit gleichem Bezeichnern vorhanden sind. Ein Parameter überschreibt diese Variablen nicht.\n\nBeispiel 8.8 (Eine Funktion deklarieren)  \nfunction (parameter) {\n    parameter ^ 2 - 1\n}\n\nDamit eine Funktion sinnvoll verwendet werden kann, muss sie zuerst einer Variablen zugewiesen werden. Der Bezeichner einer Funktion sollte möglichst die zentrale Bedeutung einer Funktion beschreiben.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Wahl eines guten Funktionsbezeichners hängt vom jeweiligen Geltungsbereich ab.\nMathematische Funktionen werden oft mit f(x) oder g(x) usw. geschrieben. In R sind solche Bezeichner ebenfalls zulässig, solange sie eindeutig sind. Solche sehr kurzen Funktionsbezeichnern sollten speziell gekennzeichnet und dokumentiert werden.\n\n\nBeispiel 8.9 weist der Funktion aus Beispiel 8.8 den Bezeichner quadrat_minus_eins zu. Dieser Bezeichner kann anschliessend als Funktion verwendet werden (s. Beispiel 8.10).\n\nBeispiel 8.9 (Eine Funktion mit Bezeichner deklarieren)  \nquadrat_minus_eins = function (parameter) {\n    parameter ^ 2 - 1\n}\n\n\nBeispiel 8.10 (Eine selbstdeklarierte Funktion aufrufen)  \nquadrat_minus_eins(2)\n3\n\n\n8.3.1 Parameter und Variablen\nEin Parameter ist ein Platzhalter für einen Wert, der einer Funktion beim Funktionsaufruf übergeben wird. Parameter werden für eine spezielle Form der Variablenzuweisung eingesetzt.\nIm Funktionskörper verhält sich ein Parameter wie eine Variable. Einem Parameter können also in einem Funktionskörper neue Werte zugewiesen werden. Neben Parametern können Funktionskörper zusätzliche Variablen benötigen. Der Geltungsbereich dieser Variablen sind auf den Funktionskörper beschränkt.\n\n\n8.3.2 Datentypen überprüfen\nWird der neuen Funktion ein falscher Datentyp als Parameter übergeben, dann können die Rs Fehlermeldungen sehr verwirrend sein. Es ist daher ein guter Stil, Parameter die bestimmte Datentypen erfordern direkt zu Begin des Funktionskörpers zu prüfen (s. Beispiel 8.11).\n\nBeispiel 8.11 (Eine Funktion mit Typenprüfung deklarieren)  \nquadrat_minus_eins = function (parameter) {\n    stopifnot(is.numeric(parameter))\n    parameter ^ 2 - 1\n}\n\n\n\n8.3.3 Nebeneffekte\n\n\n\n\n\n\nWichtig\n\n\n\nNebeneffekte sind in (fast) immer unerwünscht. Die in diesem Abschnitt werden die beiden speziellen Zuweisungsoperatoren &lt;&lt;- und -&gt;&gt; vorgestellt, die gezielt Nebeneffekte erzeugen.\nDieser Abschnitt beschreibt einen Sonderfall der Variablen- oder Funktionsdeklaration in speziellen Closures (s.u.), der in R sehr selten vorkommt. Die meisten Algorithmen lassen sich nebeneffektsfrei Programmieren, weshalb die beiden speziellen Zuweisungsoperatoren normalerweise nicht verwendet werden.\n\n\nDer Funktionskörper bildet einen abgegrenzten Geltungsbereich für Variablen. Alle normalen Zuweisungen gelten nur für den Funktionskörper, selbst wenn eine Variable oder ein Parameter ursprünglich in einem äusseren Geltungsbereich deklariert wurde.\n\nBeispiel 8.12 (Geltungsbereich von Variablen in Funktionen)  \n# Deklarationen\nvar1 = 1\nf = function (x) {\n    var1 = x + var1\n    var1\n}\n\n# Anwendung\nf(2)\nvar1\n3 # Ergebnis von f(2)\n1 # Ergebnis von var1\n\nIn seltenen Fällen ist es notwendig, eine Variable eines äusseren Geltungsbereichs in einer Funktion einen neuen Wert zuzuweisen. Hier kommen die speziellen Zuweisungen &lt;&lt;- und -&gt;&gt; zum Einsatz. Wird anstelle einer normalen Zuweisung die spezielle Zuweisung verwendet, dann wird einer Variablen oder einem Parameter eines äusseren Geltungsbereich ein neuer Wert zugewiesen.\n\nDefinition 8.1 Ändert eine Funktion eine Variable eines äusseren Geltungsbereichs, dann ist diese Änderung ein Nebeneffekt der Funktion.\n\n\nBeispiel 8.13 (Funktion mit Nebeneffekt)  \n# Deklarationen\nvar1 = 1\nf = function (x) {\n    x + var1 -&gt;&gt; var1\n    var1\n}\n\n# Anwendung\nf(2)\nvar1\n3 # Ergebnis von f(2)\n3 # Ergebnis von var1\n\n\n\n\n\n\n\nPraxis\n\n\n\nIn R sollten ausschliesslich Closures Nebeneffekte haben, wenn eine Closure eine Variable einer generierenden Funktion ändern muss. Dieser Fall tritt sehr selten ein!\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nVariablen mit globalem Geltungsbereich sollten nie durch Nebeneffekte geändert werden.\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nObjektorientierte Sprachen, wie Python oder Java, verwenden Nebeneffekte als zentrales Programmierprinzip.\nStreng-funktionale Sprachen, wie Excel, sind nebeneffektfrei."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#bibliotheken",
    "href": "kapitel/variablen/kapitel.html#bibliotheken",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.4 Bibliotheken",
    "text": "8.4 Bibliotheken\nOft ist es nicht notwendig eigene Funktionen zu erstellen. Stattdessen kann in vielen Fällen auf Funktionsbibliotheken zurückgegriffen werden, die bereits entsprechende Funktionen bereitstellen.\nR wird durch Funktionsbibliotheken erweitert. Eine Funktionsbibliothek stellt hauptsächlich Funktionen und Operationen für bestimme Algorithmen oder Analysemethoden bereit. Eine Funktionsbibliothek wird mit der Funktion install.packages() auf einem Rechner installiert.\nIn einem R-Script lassen sich die Funktionen einer Bibliothek auf zwei Arten nutzen:\n\nDie Bibliothek wird mithilfe der Funktion library() in den Code eingebunden.\nEine Funktion einer Bibliothek wird direkt angesprochen.\n\nDie erste Option bietet sich an, wenn ein Script viele Funktionen einer Bibliothek aufrufen wird. R läd in diesem Fall alle Funktionen der Bibliothek, so dass diese direkt verwendet werden können.\n\nBeispiel 8.14 (Funktionen mit der library() Funktion einbinden)  \nlibrary(ggplot2)\n\nmtcars |&gt; \n    ggplot(aes(mpg, hp)) +\n        geom_point()\n\nDie zweite Option ist sinnvoll, wenn nur eine oder zwei Funktionen einer Bibliothek verwendet werden sollen. In diesem Fall muss R nicht die gesamte Bibliothek bereitstellen, sondern läd gezielt nur die gewünschten Funktionen.\n\nBeispiel 8.15 (Eine Funktion direkt ansprechen)  \nmtcars |&gt; \n    dplyr::filter(hp &gt; 200)\n\n\n\n\n\n\n\nHinweis\n\n\n\nR bietet sog. Meta-Bibliotheken an, mit denen mehrere Bibliotheken gemeinsam verwendet werden können. Funktionen können nur nicht über den Namen einer Meta-Bibliothek, sondern immer nur über die Bibliothek, die einer Funktion definiert.\n\n\nDie tidyverse-Bibliothek ist eine solche Meta-Bibliothek. Beispiel 8.16 zeigt wie die Funktion read_delim() direkt angesprochen werden kann, wenn die tidyverse-Bibliotheken nicht mit library(tidyverse) eingebunden wurden. read_delim() wird in der Bibliothek readr definiert. Entsprechend kann die Funktion nur über readr::read_delim() aufgerufen werden.\n\nBeispiel 8.16 (Funktion aus Unterbibliothek direkt ansprechen)  \nreadr::read_delim(\"meine_daten.csv\")\n# entspricht:\n#   library(tidyverse)\n#   read_delim(\"meine_daten.csv\")\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie Syntax von R kann durch Module erweitert werden. Diese Form nutzt die Konzepte zur Metaprogrammierung von R. Dadurch können neue Programmierkonzepte in die Sprache einfliessen. Die tidyverse-Bibliotheken nutzen diese Möglichkeit intensiv. Solche Bibliotheken müssen mit der Funktion library() eingebunden werden, damit die zusätzliche Syntax bereitgestellt wird."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#bibliotheksmanagement",
    "href": "kapitel/variablen/kapitel.html#bibliotheksmanagement",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.5 Bibliotheksmanagement",
    "text": "8.5 Bibliotheksmanagement\nVerwendet ein R-Script Funktionsbibliotheken, dann ist dieses Script nur auf Rechnern lauffähig, auf denen die benutzten Bibliotheken auch installiert sind. Solche notewendigen Bibliotheken heissen die Abhängigkeiten (engl. dependencies) eines Scripts. Alle Abhängigkeiten müssen dokumentiert werden.\n\n\n\n\n\n\nPraxis\n\n\n\nIm Internet gibt es sehr viele Beispiele, die die Funktion install.packages() als Teil des Programmcodes darstellen. In konkreten R-Projekten sollte die Funktion install.packages() nie in einem normalen R-Script aufgerufen werden, weil bei jedem Start des Script geprüft wird, ob eine neue Version der Bibliothek existiert. Diese Technik stellt ein Sicherheitsrisiko dar, weil bei jeder Ausführung des Scripts Installationen unkontrolliert vorgenommen werden können und Schadcode auf die Systeme geschleust werden kann.\nDas Risiko unkontrollierter Installationen wird verringert, indem Installationen von der Programmlogik getrennt und nur kontrolliert durchgeführt werden. Dadurch wird die Installation von Funktionsbibliotheken von ihrer Anwendung getrennt.\n\n\nDie Dokumentation von Abhängigkeiten wird normalerweise von einem sog. Packetmanagement übernommen. R verfügt über kein integriertes Packetmanagement. Dieses wird von der Bibliothek renv übernommen. Bevor dieses genutzt werden kann muss renv mit install.packages(\"renv\") installiert werden.\n\n\n\n\n\n\nPraxis\n\n\n\nrenv sollte bei der Installation von R gleich mitinstalliert werden.\n\n\nrenv ist ein Packetmanagementsystem für R. Anders als die Funktion install.packages() installiert renv nicht nur Bibliotheken, sondern dokumentiert auch die Abhängigkeiten eines Projekts in einer Form, dass alle Abhängigkeiten einfach auf dem System installiert werden können. Mit renv::restore() lässt sich ein Projekt in einer anderen Umgebung mit allen Abhängigkeiten konfigurieren und ausführen.\nWird eine Bibliothek mit renv installiert, dann steht diese Bibliothek nur dem jeweiligen Projekt zur Verfügung. Was auf dem ersten Blick als Nachteil klingt, ist ein grosser Vorteil, wenn unterschiedliche Projekte besonderen Anforderungen an die Versionen einer Bibliothek haben. Auf diese Weise kann jedes Projekt die richtige Version einer Bibliothek verwenden und beeinflusst keine anderen Projekte.\n\n8.5.1 Projektvorbereitung\nEin Projekt wird mit renv::init() für die Verwendung des Packetmanagements vorbereitet. Beim ersten Aufruf von renv werden die internen Abhängigkeiten von renv kontrolliert und notfalls installiert. Das nimmt etwas Zeit in Anspruch.\nDas Packetmanagement erfasst automatisch alle Bibliotheken, die systemweit installiert wurden. Dadurch wird sichergestellt, dass alle Bibliotheken berücksichtigt wurden, die im eigenen System installiert sind und deshalb auch im Projekt verwendet werden können. Die Einzige Ausnahme davon ist renv selbst.\n\n\n8.5.2 Bibliotheken installieren\nNach der Initialisierung des Packetmanagements können projektspezifische Bibliotheken mit renv::install() installiert werden. War eine Installation erfolgreich, sollte die Bibliothek auf ihre Funktionstüchtigkeit mit einem einfachen Beispiel geprüft und danach mit renv::snapshot() als Abhängigkeit dokumentiert werden. Mit einem Snapshot wird eine Bibliotheksversion als Abhängigkeit registiert. Im Gegensatz zu install.packages() wird ab diesem Zeitpunkt nicht mehr eine beliebige Version der Bibliothek installiert, sondern nur die dokumentierte Version. Dadurch wird sichergestellt, dass der Code auch in anderen Umgebungen wie erwartet funktioniert.\n\n\n8.5.3 Updates für Bibliotheken\nEine Besonderheit von renv ist die Möglichkeit, kontrollierte Updates für einzelne oder alle Abhängigkeiten eines Projekts mit renv::update() durchzuführen. renv::update() installiert die neusten Versionen der Projektbibliotheken.\n\n\n\n\n\n\nMerke\n\n\n\nUpdates sollten nie unklontrolliert akzeptiert werden!\n\n\nBevor neue Bibliotheksversionen in das Packetmanagement aufgenommen werden, sollte immer geprüft werden, ob der bestehende Code mit den neuen Versionen immer noch funktioniert. Sollten bei dieser Prüfung Probleme auftreten, dann können die Updates mit renv::revert() wieder rückgängig gemacht werden. Gab es keine Probleme, dann können die Updates mit renv::snapshot() übernommen werden."
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html",
    "href": "kapitel/zeichenketten/kapitel.html",
    "title": "9  Zeichenketten",
    "section": "",
    "text": "Work in Progress\n\n\n\n\n\n\nZeichenketten zerlegen\nString R"
  },
  {
    "objectID": "kapitel/faktoren/kapitel.html",
    "href": "kapitel/faktoren/kapitel.html",
    "title": "10  Faktoren",
    "section": "",
    "text": "Work in Progress\n\n\n\n\n\n\n\nDefinition 10.1"
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html",
    "href": "kapitel/boolsche-operationen/kapitel.html",
    "title": "11  Boole’sche Operationen",
    "section": "",
    "text": "Work in Progress"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html",
    "href": "kapitel/vektor-operationen/kapitel.html",
    "title": "12  Vektoroperationen",
    "section": "",
    "text": "Work in Progress"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html",
    "href": "kapitel/matrix-operationen/kapitel.html",
    "title": "13  Matrix-Operationen",
    "section": "",
    "text": "Work in Progress"
  },
  {
    "objectID": "kapitel/indizieren-gruppieren/kapitel.html#indizieren",
    "href": "kapitel/indizieren-gruppieren/kapitel.html#indizieren",
    "title": "14  Indizieren und Gruppieren",
    "section": "14.1 Indizieren",
    "text": "14.1 Indizieren"
  },
  {
    "objectID": "kapitel/indizieren-gruppieren/kapitel.html#gruppieren",
    "href": "kapitel/indizieren-gruppieren/kapitel.html#gruppieren",
    "title": "14  Indizieren und Gruppieren",
    "section": "14.2 Gruppieren",
    "text": "14.2 Gruppieren"
  },
  {
    "objectID": "kapitel/daten-kodieren/kapitel.html#mit-faktoren-kodieren",
    "href": "kapitel/daten-kodieren/kapitel.html#mit-faktoren-kodieren",
    "title": "15  Daten kodieren",
    "section": "15.1 Mit Faktoren kodieren",
    "text": "15.1 Mit Faktoren kodieren"
  },
  {
    "objectID": "kapitel/daten-formen/kapitel.html",
    "href": "kapitel/daten-formen/kapitel.html",
    "title": "16  Daten formen",
    "section": "",
    "text": "Work in Progress"
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html",
    "href": "kapitel/daten-beschreiben/kapitel.html",
    "title": "17  Daten beschreiben",
    "section": "",
    "text": "Work in Progress"
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html",
    "href": "kapitel/daten-visualisieren/kapitel.html",
    "title": "18  Daten visualisieren",
    "section": "",
    "text": "Work in Progress"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referenzen",
    "section": "",
    "text": "American Mathematical Society, & LATEX Project. (2020). User’s\nguide for the amsmath package. http://mirrors.ctan.org/macros/latex/required/amsmath/amsldoc.pdf\n\n\nGrolemund, G. (2014). Introduction to r markdown. https://rmarkdown.rstudio.com/articles_intro.html\n\n\nHøgholm, M., & Madsen, L. (2022). Mathtools – mathematical tools\nto use with amsmath. https://ctan.org/pkg/mathtools?lang=en\n\n\nJupyter Development Team. (2015). The notebook file format. https://nbformat.readthedocs.io/en/latest/format_description.html\n\n\nPosit Software PBC. (2023). Quarto. https://quarto.org/\n\n\nThe Jupyter Book Community. (2023). Jupyter book. https://jupyterbook.org"
  }
]