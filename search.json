[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Einführung in die Datenwissenschaft mit R",
    "section": "",
    "text": "Vorwort\nWork in Progress\n\n\nCopyright\nDieses Werk ist lizenziert unter einer Creative Commons Namensnennung - Nicht-kommerziell - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz (CC-BY-NC-SA). Details zur Nutzungsbedingungen und dem Copyright finden sich unter createivecommons.org.\n2023, Christian Glahn, Zurich, Switzerland\n\n\n\n\n\nDie PDF-Version liegt hier zum Download"
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#motivation-und-ausgangslage",
    "href": "kapitel/einleitung/kapitel.html#motivation-und-ausgangslage",
    "title": "1  Einleitung",
    "section": "1.1 Motivation und Ausgangslage",
    "text": "1.1 Motivation und Ausgangslage"
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#base-r-und-tidy-r",
    "href": "kapitel/einleitung/kapitel.html#base-r-und-tidy-r",
    "title": "1  Einleitung",
    "section": "1.2 Base R und Tidy R",
    "text": "1.2 Base R und Tidy R\nR ist eine Programmiersprache, die durch Funktionsbibliotheken erweitert wird. Beim Starten von R wird zuerst nur das Basissystem geladen. Das R-Basissystem besteht aus den eingebauten Sprachelementen und Funktionen sowie aus den Bibliotheken base, compiler, datasets, grDevices, graphics, grid, methods, parallel, splines, stats, stats4, tcltk, tools, translations, and utils. Alle Funktionen dieser Bibliotheken stehen damit nach dem Start von R sofort bereit. Diese Funktionen heissen im R-Jargon Base R. Dieses Basissystem stellt bereits alle Funktionen für das statistische Programmieren bereit.\nBase R verwendent sehr viele Idiome als Funktionsnamen, aus denen sich nicht intuitiv erschliesst, was eine Funktion leistet. Ausserdem wurden im Laufe der Entwicklung immer wieder Funktionen dem Basissystem hinzugefügt, die sich nicht konsistent in das bestehende System aus Funktionen integrieren. Als Beispiel sollen die Funktionen eapply(), lapply(), sapply(), tapply() und vapply() sowie replicate() und rep() dienen. Bis auf replicate() sehen die Funktionsnamen ähnlich aus, werden aber in unterschiedlichen Kontexten verwendet und auf unterschiedliche Weise aufgerufen. replicate() und rep() haben einen ähnlichen Funktionsnamen und in der Beschreibung dienen beide Funktionen der replikation. Die Funktion replicate() ist aber eine Variante der Funktion lapply() mit ähnlicher Syntax und rep() nicht.\nBeim Erlernen von Base R müssen die Kernsyntax der Programmiersprache, die Verwendung der Idiome mit ihren passenden Kontexten und Anwendungen sowie alle Widersprüche erlernt werden. Für Programmierneulinge erscheinen Programme in Base R sehr kyptisch und wenig intuitiv. Selbst erfahrenen R-Entwickler:innen erschliesst sich die Funktionsweise einiger Base R-Programme erst nach dem Studium der zugehörigen Bibliotheksdokumentation.\nMit zunehmender Bedeutung der Datenwissenschaften, wurden die Inkonsistenzen von Base R zum Hindernis für komplexe Anwendungen und Analysen. Ausgehend von einer konsistenten Syntax für die Datenvisualisierung wurden nach und nach R-Bibliotheken für eine konsistente und koherente Datentransformation und -Auswertung bereitgestellt. Diese Bibliotheken stellen Daten und Datenströme in das Zentrum der Programmierung. Durch selbsterklärende Funktionsnamen, das zusammenfassen in Funktionsgruppen und einheitliche Logik für Funktionsaufrufe bilden diese Bibliotheken einen R-Dialekt, der als tidy R bezeichnet wird. R-Programme sind auch für unerfahrende R-Interessierte deutlich intuitiver zu verstehen, wenn sie mit den tidy R Konzepten entwickelt wurden, als vergleichbare Base R Varianten. Durch den datenzentrierten Zugang lässt sich tidy R wesentlich leichter erlernen als Base R.\nDen Kern von tidy R bildet die Bibliothek tidyverse, die die wichtigsten Funktionen für die Datentransformation und die Datenvisualisierung zusammenfasst. Sie besteht aus den Unterbibliotheken dplyr, forcats, ggplot2, purrr, readr, tibble und tidyr.\nWichtige ergänzende Funktionen für die Statistik und das statistische Modellieren werden durch die Bibliotheken rstatix und tidymodels bereitgestellt.\nIn diesem Buch werden alle Konzepte datenzentrisch mit dem tidy R Ansatz erarbeitet. Base R Konzepte, Operatoren und Funktionen werden nur verwendet, wenn diese nicht im Widerspruch zu tidy R stehen. In diesen Fällen werden diese nicht gesondert als Base R hervorgehoben."
  },
  {
    "objectID": "kapitel/einleitung/kapitel.html#organisation-dieses-buchs",
    "href": "kapitel/einleitung/kapitel.html#organisation-dieses-buchs",
    "title": "1  Einleitung",
    "section": "1.3 Organisation dieses Buchs",
    "text": "1.3 Organisation dieses Buchs"
  },
  {
    "objectID": "kapitel/tool-chain/installation.html#r-installieren",
    "href": "kapitel/tool-chain/installation.html#r-installieren",
    "title": "2  Tool Chain",
    "section": "2.1 R installieren",
    "text": "2.1 R installieren\nDie Installation von R ist einfach. Auf der R-Project Webseite kann das Installationspaket für das jeweilige Betriebssystem heruntergeladen werden. Die Installation erfolgt wie gewohnt über den Installer.\n\n\n\n\n\n\nMacOS\n\n\n\nViele R-Bibliotheken benötigen zusätzliche Komponenten, damit sie funktionieren. Diese Komponenten müssen zusätzlich kompiliert werden. Unter MacOS benötigt R dafür die App XCode und die XCode Command Line Tools.\nBeide Komponenten stehen unter MacOS kostenlos zur Verfügung. XCode wird wie gewohnt über Apple’s AppStore installiert. Nach der Installation muss XCode einmal gestartet werden, um die Lizenzbedingungen zu akzeptieren. Anschliessend sollten die notwendigen Ergänzungen für die Entwicklung unter MacOS installiert werden.\nNach erfolgreicher Installation erscheint eine Abfrage, zum Starten eines neuen Projekts (Abbildung 2.1).\n\n\n\nAbbildung 2.1: XCode Start Dialog\n\n\nDamit ist die Installation von XCode abgeschlossen. Nun folgt die Installation der Kommandozeilenwerkzeuge. Dazu muss ein Terminal geöffnet werden.\n\n\n\nAbbildung 2.2: MacOS Terminal\n\n\nIm Terminal muss das folgende Kommando eingegeben und anschliessend mit der Eingabe-Taste abgeschlossen werden.\nxcode-select --install\nAnschliessend folgen mehrere Abgragen zur Installation der XCode-Command-Line Komponenten. Nach der Installation kann das Terminal und XCode wieder geschlossen werden.\nXCode wird regelmässig grösseren Änderungen unterzogen. Diese Änderungen erfolgen oft im April, Juni und September. Nach einem Update von XCode müssen die Command-Line Tools ebenfalls erneut installiert werden. Ausserdem ist es notwendig, dass die Lizensbedingungen erneut akzeptiert werden, sonst lassen sich R-Bibliotheken nicht mehr kompilieren.\n\n\n\n2.1.1 Überprüfen der Installation\nNach erfolgreicher Installation sollte R mit den Werkzeugen der Laufzeitumgebung auf dem Rechner vorhanden sein. Die Installation lässt sich mithilfe des Terminals (MacOS) oder der Powershell (Windows) überprüfen.\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nUnter MacOS muss der folgende Befehl eingegeben und mit der Eingabe-Taste abgeschlossen werden.\nRscript -e 'sessionInfo()'\nIn der Windows Powershell muss der Befehl wie folgt aussehen:\nRSCRIPT.EXE -e 'sessionInfo()'\n\n\nBei erfolgreicher Installation erscheint eine Meldung im Terminal, die der folgen Meldung ähnelt. Die Funktion sessionInfo() zeigt die Versionsinformationen der aktuellen R-Installation an.\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin22.4.0 (64-bit)\nRunning under: macOS Ventura 13.5.2\n\nMatrix products: default\nBLAS:   /opt/homebrew/Cellar/openblas/0.3.23/lib/libopenblasp-r0.3.23.dylib \nLAPACK: /opt/homebrew/Cellar/r/4.3.1/lib/R/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] de_DE.UTF-8/de_DE.UTF-8/de_DE.UTF-8/C/de_DE.UTF-8/de_DE.UTF-8\n\ntime zone: Europe/Zurich\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n[1] compiler_4.3.1\n\n\n2.1.2 Erste Schritte\nR ist eine interaktive Sprache und besteht im Kern aus einer sog. Laufzeitumgebung. Diese Umgebung übersetzt R-Syntax in Maschinensprache und führt vollständige Ausdrücke direkt aus. Innerhalb der Laufzeitumgebung steht ein einfacher Zeileneditor zur Verfügung, mit dem Eingaben erstellt und manipuliert werden können.\n\n\n\n\n\n\nMacOS vs Windows\n\n\n\nDie R-Laufzeitumgebung wird auf MacOS-Systeme im Terminal mit dem Kommando R und Eingabetaste gestartet.\nAuf Windows-Systemen wird die Laufzeitumgebung in der Powershell mit dem Kommando R.EXE aufgerufen.\n\n\nR verwendet für alle Operationen Funktionen. Die meisten R-Funktionen haben einen Namen und werden mit runden Klammern aufgerufen. Ein Beispiel ist die Funktion quit(), mit der die R-Laufzeitumgebung verlassen wird. Funktionen werden in die Laufzeitumgebung eingegeben und durch das Drücken der Eingabetaste ausgeführt.\nquit()\nDieser Funktionsaufruf führt zu der Abfrage, ob die aktuelle Arbeitsumgebung gesichert werden soll.\nSave workspace image? [y/n/c]:\nWeil nichts geändert wurde, kann diese Frage mit n für No beantwortet und mit einem Druck auf die Eingabetaste übergeben werden. Anschliessend wird die Laufzeitumgebung geschlossen und kehrt auf die Kommandozeile des Betriebssystems zurück.\nNeben der interaktiven Laufzeitumgebung wird R mit dem Programm Rscript ausgeliefert. Mit Rscript können Dateien mit R-Code zusammenhängend ausgeführt werden.\n\nDefinition 2.1 Ein R-Script ist eine Datei, die nur R-Code enthält. Ein R-Script hat per Konvention die Dateiendung .r\n\n\n\n\n\n\n\nMacOS vs. Windows\n\n\n\nDas Programm Rscript heisst unter Windows RSCRIPT.EXE.\n\n\n\nBeispiel 2.1 (Ausführen eines R-Scripts im MacOS Terminal)  \nRscript my-rscript.r\n\nRscript kann ausserdem einzelne Code-Zeilen ausführen, ohne in die interaktive Laufzeitumgebung wechseln zu müssen. Diese Funktion ist praktisch, um eine einfache Operation auszuführen, wie z.B. eine Bibliothek zu installieren (s. Kapitel 2.3)."
  },
  {
    "objectID": "kapitel/tool-chain/installation.html#grafische-oberflächen-für-r",
    "href": "kapitel/tool-chain/installation.html#grafische-oberflächen-für-r",
    "title": "2  Tool Chain",
    "section": "2.2 Grafische Oberflächen für R",
    "text": "2.2 Grafische Oberflächen für R\nR hat keine eigene grafische Benutzeroberfläche und ist auf eine externe Entwicklungsumgebung angewiesen. Eine solche Entwicklungsumgebung muss zusätzlich zu R installiert werden, damit die Programmierung und die Analyse vereinfacht wird. Die am häufigsten eingesetzten Entwicklungsumgebungen für R sind:\n\nRStudio\nJupyter Notebooks\nVisual Studio Code\n\n\n\n\n\n\n\nHinweis\n\n\n\nIn diesem Buch wird Visual Studio Code für alle Beispiele mit Benutzeroberfläche verwendet. Die Bedienung von RStudio oder JupyterLab unterscheidet für die Arbeit in diesem Buch sich nur marginal von Visual Studio Code.\n\n\nEine R-Entwicklungsumgebung ist unabhängig von der R-Laufzeitumgebung, die die Programmiersprache bereitstellt. Es ist also möglich, R-Programme in der einen Umgebung zu entwickeln und später in einer anderen weiterzubearbeiten und auszuführen.\nDie Grundkomponenten einer Entwicklungsumgebung sind immer gleich (Abbildung 2.3):\n\nCode-Editor, mit dem Dokumentation und analytische Funktionen geschrieben werden.\nDatei-Browser, über den alle Dateien eines Projekts verwaltet werden können.\n\nLaufzeit-Console, über die die R-Laufzeitumgebung zugänglich ist.\nDatenbetrachter, zur Auswertung von generierten Datenstrukturen.\nVisualisierungsbetrachter, zur Anzeige von Datenvisualisierungen.\n\n\n\n\nAbbildung 2.3: Komponenten einer datenzentrischen Entwicklungsumgebung am Beispiel von Visual Studio Code\n\n\nNeben diesen Komponenten existieren oft zustätzliche Werkzeuge und Ansichten.\n\nWerkzeuge zur Versionierung von Code und Daten.\nDokumentation für R und ergänzende Bibliotheken.\nInstallationsunterstützung von Bibliotheken.\n\n\n2.2.1 RStudio\nRStudio ist eine integrierte Analyseumgebung, die speziell für die Entwicklung von R-Programmen und R-Analysen entwickelt wurde. Das System ist auf R-spezifische Arbeitsabläufe zur Datenanalyse ausgerichtet und unterstützt neben R auch die Programmiersprache Python.\nRStudio verwendet eine spezielle Version von Markdown, um R-Code-Fragmente auszuführen und die Ergebnisse in das Dokument einzubinden. Dieses Format heisst R-Markdown.\nVon RStudio existiert auch eine Web-basierte Version, welche online Zusammenarbeit und online Publikationen unterstützt.\n\n\n2.2.2 JupyterLab\nJupyterLab ist eine Web-basierte Analyseumgebung, die ursprünglich für die Programmiersprache Python entwickelt wurde. JupyterLab wurde speziell für Datendokumente entwickelt und unterstützt ausschliesslich Jupyter Notebooks als Austauschformat für Analysen.\nJupyterLab unterstützt neben Python viele andere Programmiersprachen. Dazu gehört auch R. JupyterLab integriert Programmiersprachen durch spezielle Kernel, die Code-Fragmente auswerten und die Ergebnisse in ein Datendokument einbinden.\nIn der Praxis werden Jupyter Notebooks und JupyterLab oft eingesetzt, wenn sehr umfangreiche Daten analysiert werden sollen, die nicht ohne weiteres über das Internet übertragen werden können oder dürfen.\n\n\n2.2.3 Visual Studio Code\nVisual Studio Code ist ein kostenloser Code-Editor mit vielen Erweiterungen für fast alle Programmiersprachen und Arbeitsumgebungen. Die Erweiterung für R ist ebenfalls kostenlos und kann über den Extension Manager installiert werden.\nIm Gegensatz zu R-Studio ist Visual Studio Code in erster Linie ein Code-Editor und bietet für R eine vergleichsweise einfache Entwicklungsumgebung. Der grösste Unterschied zwischen Visual Studio Code und RStudio oder JupyterLab ist der wenig differenzierte Variablen-Inspektor.\nIn Visual Studio Code lassen sich u.a. auch R-Markdown-Dokumente und Jupyter Notebooks bearbeiten."
  },
  {
    "objectID": "kapitel/tool-chain/installation.html#sec-install-libs",
    "href": "kapitel/tool-chain/installation.html#sec-install-libs",
    "title": "2  Tool Chain",
    "section": "2.3 R-Bibliotheken installieren",
    "text": "2.3 R-Bibliotheken installieren\nR verfügt über einen sehr grossen Fundus an Lösungen für das statistische Rechnen. Diese Lösungen werden als Bibliotheken bereitgestellt und über das Comprehensive R Archive Network (CRAN) geteilt. CRAN ist ein integraler Bestandteil von R. Weil R jedoch über sehr viele Bibliotheken verfügt, werden diese nicht mit R ausgeliefert, sondern müssen bei Bedarf installiert werden. Hierzu liefert R die Funktion install.packages() mit. Diese Funktion teilt R mit, eine Bibliothek mit einem bestimmten Namen zu installieren.\n\nBeispiel 2.2 (Funktions-Schema von install.packages())  \ninstall.packages(package_name)\n\nIn diesem Buch werden neben den R-Basisfunktionen fast ausschliesslich die Funktionen der tidyverse-Bibliothek behandelt. Die tidyverse-Bibliothek erweitert die R-Syntax um moderne Sprachkonzepte und vereinheitlicht viele Funktionen für Standardaufgaben.\n\n\n\n\n\n\nHinweis\n\n\n\nStreng genommen ist die tidyverse-Bibliothek eine R-Bibliothek im engeren Sinn. Vielmehr vereint sie die häufig zusammen eingesetzten Biblliotheken ggplot2 (Kapitel 18), dplyr (Kapitel 14), tidyr (Kapitel 16), readr (Kapitel 7), stringr (Kapitel 9), forcats (Kapitel 10), lubridate und purrr (Kapitel 8) sowie etliche weitere Module für die tägliche Arbeit mit Daten.\n\n\nWeil die tidyverse-Bibliothek eine zentrale Bedeutung im R-Umfeld hat, ist es an dieser Stelle sinnvoll, die tidyverse-Bibliothek mithilfe von Rscript zu installieren.\n\nBeispiel 2.3 (Installieren der tidyverse-Bibliotheken unter MacOS)  \nRscript -e 'install.packages(\"tidyverse\")'\n\nBei der ersten Installation einer Bibliothek fragt R nach einem CRAN-Mirror. Hier sollte ein geografisch nahe Quelle gewählt werden, um die Ladezeiten zu verringern.\nMit Visual Studio Code können R-Bibliotheken auch mit der Arbeitsumgebung installiert werden. Dazu wird die R-Erweiterung geöffnet und im Bereich Help Pages die Option Install CRAN Package gewählt. Anschliessend wird der gewünschte Bibliotheksname in der interaktiven Suche eingegeben und mit der Eingabetaste ausgewählt (Abbildung 2.4).\n\n\n\nAbbildung 2.4: Installation der tidyverse-Bibliothek in Visual Studio Code"
  },
  {
    "objectID": "kapitel/tool-chain/hilfe.html#help",
    "href": "kapitel/tool-chain/hilfe.html#help",
    "title": "3  Hilfe bekommen",
    "section": "3.1 help()",
    "text": "3.1 help()\nDie help()-Funktion ist der erste Anlaufpunkt, um mehr über eine Funktion zu erfahren.\nR-Funktionen sind in der Regel sehr ausführlich dokumentiert. Falls Sie Details über die Arbeitsweise einer Funktion erfahren möchten, können Sie die Dokumentation einer Funktion mit der help()-Funktion abrufen. Dazu rufen Sie diese Funktion wie jede andere R-Funktion auf.\nDie help()-Funktion ist Teil von Base R und ist in jeder Umgebung verfügbar.\nDie Funktion erwartet den gewünschten Funktionsnamen. help() kann der Funktionsname direkt oder als Zeichenkette als Parameter übergeben werden. D.h. die beiden folgenden Operationen haben den gleichen Effekt und zeigen die Dokumentation der Funktion read.csv an.\n\nBeispiel 3.1 (Hilfe anzeigen)  \nhelp(read.csv)\nhelp(\"read.csv\")\n\nIn Visual Studio Code ist es nicht notwendig, die help()-Funktion aufzurufen, weil die Hilfe direkt in die Arbeitsumgebung integriert ist. In R-Scirpten reicht es, den Mauszeiger über eine Funktion zu bewegen. Visual Studio Code zeigt dann die Hilfe direkt im Editor an (Abbildung 3.1). Diese Darstellung wird als Inline-Hilfe bezeichnet.\n\n\n\nAbbildung 3.1: Inline Anzeige einer R-Funktionsdokumentation in Visual Studio Code\n\n\nNeben der Inline-Hilfe lassen sich alle Funktionen der installierten R-Bibliotheken auch über den Abschnitt Help Pages der R-Erweiterung zugreifen. Dort findet sich unter dem letzten Punkt Help Topics by Packages die Dokumentation für alle auf dem Computer installierten Bibliotheken. Der erste Unterpunkt für jede Bibliothek ist der Index, der alle Dokumente für eine Bibliothek auflistet (Abbildung 3.2). Nach dem Installieren einer Bibliothek sollte diese Seite aufgerufen werden, um sich mit der installierten Version vertraut zu machen.\n\n\n\n\n\n\nAchtung\n\n\n\nIm Internet finden sich viele Materialien zur Verwendung einzelner Bibliotheken. Oft beziehen sich diese Materialien auf ältere Versionen der jeweiligen Bibliothek. Damit ist nicht sichergestellt, dass die beschriebenen Techniken der richtigen Vorgehensweise entsprechen. Deshalb sollte immer die offizielle Dokumentation der installierten Bibliotheken zur Überprüfung der beschriebenen Methoden herangezogen werden.\n\n\n\n\n\nAbbildung 3.2: Index der Dokumentation für die Bibliothek dplyr\n\n\n\n3.1.1 Aufbau von Funktionsdokumentationen\nDie meisten R-Bibliotheken folgen einer Konvention zur systematischen Dokumentation von Funktionen. Jede Funktionsdokumentation besteht aus den folgenden Teilen:\n\nBeispielen für den Aufruf der Funktion\nBeschreibung aller Funktionsparameter\nEiner detaillierten Funktionsbeschreibung\nBeispielen\n\nDie Beispiele zeigen typische Aufrufe der jeweiligen Funktion und finden sich immer am Ende der Dokumentation. Es lohnt sich häufig zuerst die Beispiele anzusehen und danach die Funktionsdetails zu lesen."
  },
  {
    "objectID": "kapitel/tool-chain/hilfe.html#vignettes",
    "href": "kapitel/tool-chain/hilfe.html#vignettes",
    "title": "3  Hilfe bekommen",
    "section": "3.2 Vignettes",
    "text": "3.2 Vignettes\nViele R-Bibliotheken haben komplexe Anwendungen. Diese Anwendungen werden in sogenannten Vignettes beschrieben. Eine Vignette ist eine ausführliche Beschreibung einer Funktion oder des Zusammenspiels mehrerer Funktionen mit nachvollziehbaren Beispielen.\nSie können sich die verfügbaren Vignettes für eine Bibliothek mit der Operation vignette(package = bibliotheksname) anzeigen lassen. Wenn Sie z.B. alle Vignettes für die dplyr Bibliothek anzeigen lassen möchten, dann geben Sie vignette(package = \"dplyr\") ein. Das Ergebnis ist die Liste der verfügbaren Vignettes für diese Bibliothek.\nWenn Sie das gesuchte Thema gefunden haben, dann können Sie sich die Vignette mit dem folgenden Befehl anzeigen lassen: vignette(thema, package = bibliotheksname)\n\n\n\nAbbildung 3.3: Index der dplyr Anleitungen\n\n\nIn Visual Studio Code sind alle Vignettes einer Bibliothek (Abbildung 3.3) über deren Dokumentationsindex (Abbildung 3.2) erreichbar. Dadurch lassen sich Anleitungen oft leichter finden."
  },
  {
    "objectID": "kapitel/tool-chain/hilfe.html#cheat-sheets",
    "href": "kapitel/tool-chain/hilfe.html#cheat-sheets",
    "title": "3  Hilfe bekommen",
    "section": "3.3 Cheat Sheets",
    "text": "3.3 Cheat Sheets\nDie tidyverse-Bibliotheken bieten zusätzlich Spickzettel für die wichtigsten Funktionen und Techniken für eine Bibliothek auf zwei Seiten. Diese Spickzettel werden auch als Cheat Sheets bezeichnet. Sie können diese Cheat Sheets doppelseitig ausdrucken und als Schnellreferenz verwenden.\nIm Git-Repository rstudio/cheatsheets finden sich Spickzettel und Kurzreferenzen viele R-Bibliotheken.\n\n\n\n\n\n\nAchtung\n\n\n\nDie Spickzettel sind nicht Teil der Dokumenation einer Bibliothek und werden nicht mit ihr gepflegt.\nEin Spickzettel ersetzt nicht die Dokumentation! Gelegentlich verweisen Spickzettel auf stark veraltete Praktiken. Es ist also immer ein Vergleich mit der offiziellen Dokumentation notwendig.\n\n\nDie folgenden Spickzettel unterstützen die Arbeit mit diesem Buch:\n\nDatenimport\nDatenvisualisierung (ggplot2)\nDatentransformation (dplyr)\nDatenbereinigung (tidyr)\nVektorfunktionen (purrr)\nZeichenketten (stringr)\nFaktoren (forcats)\nDatumswerte (lubridate)"
  },
  {
    "objectID": "kapitel/tool-chain/language.html#syntaktische-symbole",
    "href": "kapitel/tool-chain/language.html#syntaktische-symbole",
    "title": "4  R-Sprachelemente",
    "section": "4.1 Syntaktische Symbole",
    "text": "4.1 Syntaktische Symbole\nSyntaktische Symbole sind alle Sprachelemente, die für sich allein stehen. Symbole können Werte, Schlüsselworte oder Bezeichner sein. Symbole werden durch Operatoren oder durch Leerzeichen voneinander getrennt.\n\n4.1.1 Werte\nWerte können direkt angegeben werden. Dabei legt der Datentyp eines Werts (Kapitel 6) fest, wie dieser eingegeben werden muss.\n\nZahlen werden als Ziffernfolge direkt eingegeben (z.B. 123.45).\nWahrheitswerte werden in Grossbuchstaben eingegeben (z.B. WAHR).\nZeichenketten werden in Anführungszeichen eingegeben (z.B. \"Daten und Information\")\n\n\n\n4.1.2 Schlüsselworte\nR kennt verschiedene Schlüsselworte, die als eigene Symbole festgelegt sind und nicht verändert werden können. Jedes der folgenden Schlüsselworte hat eine Bedeutung für R und kann nur in dieser Bedeutung verwendet und nicht umdefiniert werden.\nFunktionen (Kapitel 8)\n\nfunction\n\nEntscheidungen (Kapitel 11) zur bedingten Ausführung von Operationen.\n\nif\nelse\n\nSchleifen zur wiederholten Ausführung von Operationen.\n\nrepeat\nwhile\nfor\nnext\nbreak\n\n\n\n\n\n\n\nKeine Schleifen in der Paxis\n\n\n\nR-Schleifen sind im Vergleich zu vergleichbaren Funktionen äusserst ineffizient. Deshalb haben Schleifen in der praktischen Anwendung von R keine Bedeutung mehr. Stattdessen werden ausschliesslich spezielle Funktionen über Datenstrukturen verwendet. Entsprechend finden sich diese Schlüsselworte sehr selten in R-Skripten.\n\n\n\n\n4.1.3 Bezeichner\nIst ein Symbol kein Schlüsselwort und kein Wert, dann wird das Symbol als Bezeichner behandelt. Ein Bezeichner ist ein Platzhalter für einen Wert (Kapitel 6) und kann wie ein Wert in Operationen verwendet werden.\nGrundsätzlich können Bezeichner beliebige Zeichen enthalten. R erkennt einfache Bezeichner mit zwei Regeln.\n\nBeginnt mit einem ASCII-Buchstaben (A-Z, a-z) oder einem Unterstrich.\nEnthält nur ASCII-Buchstaben (A-Z, a-z), arabische Ziffern (0-9) und Unterstriche.\n\nWeicht ein Bezeichner von diesen Regeln ab, dann muss dieser als solcher durch Backticks (`) gekennzeichnet werden. Beispiel 4.1 zeigt einen Bezeichner, der den deutschen Umlaut (ü) und ein Leerzeichen enthält. Weil ü kein ASCII-Buchstabe ist und das Leerzeichen normalerweise Symbole trennt, muss der ganze Bezeichner als Symbol markiert werden.\n\nBeispiel 4.1 (markierter Bezeichner)  \n`merkwürdiger Bezeichner`\n\nWird der Bezeichner aus Beispiel 4.1 nicht markiert, erzeugt R die Fehlermeldung Fehler: unerwartetes Symbol in \"merwürdiger Name\"."
  },
  {
    "objectID": "kapitel/tool-chain/language.html#operationen",
    "href": "kapitel/tool-chain/language.html#operationen",
    "title": "4  R-Sprachelemente",
    "section": "4.2 Operationen",
    "text": "4.2 Operationen\n\nDefinition 4.1 Eine Operation ist ein syntaktisches Konstrukt, das von einer Programmiersprache als ausgeführbar erkannt wird.\n\nEine Operation kann sich als ein Satz in einer Sprache vorgestellt werden, wobei für Programmiersprachen nur ganze (vollständige) Sätze gültig sind und ausgeführt werden.\nR fügt Symbole und Operatoren solange zusammen, bis eine syntaktisch gültige Operation gefunden wird. Syntaktisch gültig heisst in diesem Zusammenhang, dass alle syntaktischen Elemente für eine Operation gefunden wurden. Erst dann versucht R diese Operation auszuführen. Bei der Ausführung kann festgestellt werden, dass eine Operation nicht ausführbar ist. In diesem Fall erzeugt R eine Fehlermeldung.\nDie einfachste R-Operation ist die Angabe eines einzelnen Symbols. Wird nur ein Symbol als Operation eingegeben, dann bedeutet das für R, dass die zum Symbol gehörenden Daten serialisiert werden sollen. Das bedeutet, dass die Daten des Symbols angezeigt werden. Ist das Symbol ein Wert, dann wird der Wert wiederholt.\n\nBeispiel 4.2 (Wert direkt serialisieren)  \n\"Daten und Information\"\n\nBeispiel 4.2 zeigt die Operation, die die Zeichenkette Daten und Information als Ergebnis serialisiert.\n\n4.2.1 Operatoren\n\nDefinition 4.2 Ein Operator ist ein syntaktisches Element, das Symbole zu einer Operation verknüpft.\n\nDie bekanntesten Operatoren sind die arithmetischen Operatoren und die Vergleichsoperatoren.\nIn R sind vier spezielle Operatoren wichtig:\n\nDie drei Zuweisungsoperatoren (&lt;-, = und -&gt;).\nDer Funktionsaufrufoperator (()).\n\nMit den Zuweisungsoperatoren können Werte Namen zugewiesen werden. Bei den Pfeil-Operatoren wird der Wert in Richtung des Pfeils zugewiesen. Beim Gleich-Operator erfolgt die Zuweisung von rechts nach links. (s. Beispiel 4.3)\n\nDefinition 4.3 Eine Deklaration heisst die (erste) Zuweisung eines Werts an eine Variable.\n\n\nBeispiel 4.3 (Zuweisung einer Zeichenkette)  \nbuchtitel1 = \"Daten und Information 1\"\nbuchtitel2 &lt;- \"Daten und Information 2\"\n\"Daten und Information 3\" -&gt; buchtitel3 \n\nEs können auch Namen anderen Namen zugewiesen werden. In diesem Fall wird der zugehörige Wert für einen Namen ermittelt und dem neuen Namen zugewiesen (Beispiel 4.4).\n\nBeispiel 4.4 (Zuweisung von Namen an einen anderen Namen.)  \nbuchtitel4 = buchttitel1 \n# buchtitel4 enthält \"Daten und Information 1\"\nbuchtitel5 &lt;- buchtitel2 \n# buchtitel5 enthält \"Daten und Information 2\"\nbuchtitel3 -&gt; buchtitel6 \n# buchtitel6 enthält \"Daten und Information 3\"\n\nDer Funktionsaufrufoperator prüft ob der vorangehende Name eine Funktion ist und ruft diese auf. Zwischen den Klammern können Werte oder Namen als Parameter der Funktion übergeben werden. Die Parameter werden durch Kommas getrennt (Beispiel 4.5).\n\nBeispiel 4.5 (Funktionsaufruf der Summefunktion mit Parametern)  \nsum(1,2,3) # 6\n\nDer Funktionsaufrufoperator darf nicht mit den aus der Mathematik bekannten Klammern verwechselt werden. Klammern fassen auch in R Teiloperationen zusammen und reihen diese gegenüber einer anderen Teiloperation vor. Der Funktionsaufrufoperator kommt nur zur Anwendung, wenn ein Name auf eine Funktion verweist.\nWird der Funktionsaufrufoperator zusammen mit dem Schlüsselwort function verwendet, dann wird eine Funktion mit den angegebenen Parametern erstellt (s. Beispiel 4.6). Diese Operation heisst Funktionsdeklaration. Eine deklarierte Funktion muss in R einem Namen zugewiesen werden.\n\nBeispiel 4.6 (Funktionsdeklaration)  \nadd3 &lt;- function (eins, zwei, drei) \n    sum(eins, zwei, drei)\n\n\n\n4.2.2 Blöcke\nMehrere Operationen lassen sich in R zu Blöcken zusammenfassen. Ein Block wird durch geschweifte Klammern ({ und }) markiert. Geschweifte Klammern bilden also den Blockoperator.\nEin Block wird von R als eine Operation behandelt. Damit die Operationen in einem Block von R ausgeführt werden können, müssen alle übergeordneten Blöcke geschlossen werden.\nBeispiel 4.7 zeigt die Deklaration einer Funktion, die aus zwei Operationen besteht. Damit beide Operationen zu einer Funktion zusammengefasst werden können, müssen diese in einen Block gefasst werden.\n\nBeispiel 4.7 (Funktionsdeklaration mit Block)  \nadd3mod6 &lt;- function (eins, zwei, drei) {\n    sum(eins, zwei, drei) -&gt; sechs\n    sechs %% 6\n}"
  },
  {
    "objectID": "kapitel/daten-organisieren/kapitel.html#mathematische-formeln-in-datendokumenten",
    "href": "kapitel/daten-organisieren/kapitel.html#mathematische-formeln-in-datendokumenten",
    "title": "5  Dokumentation",
    "section": "5.1 Mathematische Formeln in Datendokumenten",
    "text": "5.1 Mathematische Formeln in Datendokumenten\nIn Datendokumenten lassen sich mathematische Formeln darstellen. Diese Formeln werden im sog. LaTeX-Math-Mode eingegeben. Diese Formeln werden bei der Präsentation in die korrekte mathematische Darstellung überführt.\nDer LaTeX-Math-Mode ist eine Formelbeschreibungssprache (American Mathematical Society & LATEX Project, 2020; Høgholm & Madsen, 2022), mit der die exotischen und in nicht mathematischen Texten wenig bis nie verwendeten Symbole und deren Anordnung gezielt erzeugt werden können. Der LaTeX-Math-Mode wird von vielen Systemen zur Darstellung von Formeln verwendet. Deshalb lohnt sich eine Auseinandersetzung mit den Grundkonzepten dieser Technik.\nDer LaTeX-Math-Mode kennt zwei Modi: den inline Modus, wenn eine Formel wie oben in den Fliesstext eingebettet ist, und den Gleichungsmodus, wenn eine Formel wie eine Abbildung hervorgehoben und beschriftet wird. Der inline Modus wird durch ein einfaches Dollar-Zeichen ($) oder mit der Zeichenfolge Backslash-runde Klammer (\\( und \\)) eingeleitet und abgeschlossen. Der Gleichungsmodus wird durch ein doppeltes Dollar-Zeichen ($$) eingeleitet und abgeschlossen. Die Formelbeschreibung ist unabhängig vom Modus, wobei die Darstellung dem zur Verfügung stehenden Platz berücksichtigt.\nMit dem LaTeX-Math-Mode wird die Formel mit ihren Bestandteilen und ihren Beziehungen beschrieben. Die folgenden Grundregeln sind für den Math-Mode wichtig:\n\nZahlen und Buchstaben und andere Sonderzeichen auf der Tastatur werden als solche dargestellt.\nSonderzeichen, Operatoren und besondere Formatierungen werden durch einen Back-Slash (\\) eingeleitet, der von einem Schlüsselwort gefolgt wird.\nzusammengehörende Teilausdrücke werden durch geschweifte Klammern zusammengefasst ({}). Teilausdrücke, die nur aus einem Symbolbestehen müssen nicht in Klammern gesetzt werden.\nDas Dach (^) bedeutet den folgenden Teilausdruck hochstellen.\nDer Unterstrich (_) bedeutet den folgenden Teilausdruck tiefstellen.\n\n\nBeispiel 5.1 (LaTeX-Math-Mode) Die Formel \\sum_{i=1}^{n}{(\\frac{x_i}{2})^2} lässt sich mit einer normalen Tastatur nicht eingeben. Deshalb wird der Math-Mode zur Formelbeschreibung verwendet. Im inline Modus wird die Formeldarstellung so gewählt, dass die Formel ungefähr in die aktuelle Textzeile passt. Im Gleichungsmodus wird die gleiche Formel möglichst übersichtlich angezeigt.\n\n\\sum_{i=1}^{n}{(\\frac{x_i}{2})^2}\n\nDie Formel wird wie folgt im Math-Mode beschrieben:\n\\sum_{i=1}^{n}{(\\frac{x_i}{2})^2}\nDie Formel beginnt mit dem grossen griechischen Sigma (\\Sigma) für das Summensymbol. Das wird durch \\sum erzeugt. Eine Summe besteht aus drei Teilausdrücken:\n\nDem Initialwert unter dem Summenzeichen.\nDem Endwert über dem Summenzeichen.\nDem Summenterm hinter dem Summenzeichen.\n\nEntsprechend wird der Initialwert mit _ tiefgestellt, der Endwert mit ^ hochgestellt und der Summenterm wird hinter die Summe gefügt.\nDer Summenterm wird durch eine Potenz und einem Bruch gebildet. Die Potenz wird durch das Hochstellen gekennzeichnet. Die runden Klammern werden als einfache runde Klammern eingegeben\nDer Bruch ist eine besondere Darstellung und benötigt das Schlüsselwort frac für fraction (dt. Fraktur/Bruch). Ein Bruch besteht immer aus zwei Teilausdrücken, die nacheinander in geschweiften Klammern angegeben werden müssen. Der Zähler besteht aus dem Teilausdruck x_i. Entsprechend muss das i gegenüber dem x tiefgestellt werden. Weil es sich jeweils um einzelne Symbole handelt, müssen die Teilausdrücke nicht geklammert werden.\n\n\n\n\n\nAmerican Mathematical Society, & LATEX Project. (2020). User’s Guide for the amsmath Package. http://mirrors.ctan.org/macros/latex/required/amsmath/amsldoc.pdf\n\n\nGrolemund, G. (2014). Introduction to R Markdown. https://rmarkdown.rstudio.com/articles_intro.html\n\n\nHøgholm, M., & Madsen, L. (2022). mathtools – Mathematical tools to use with amsmath. https://ctan.org/pkg/mathtools?lang=en\n\n\nJupyter Development Team. (2015). The Notebook file format. https://nbformat.readthedocs.io/en/latest/format_description.html\n\n\nPosit Software PBC. (2023). quarto. https://quarto.org/\n\n\nThe Jupyter Book Community. (2023). Jupyter Book. https://jupyterbook.org"
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#fundamentale-datentypen",
    "href": "kapitel/datentypen/kapitel.html#fundamentale-datentypen",
    "title": "6  Datentypen",
    "section": "6.1 Fundamentale Datentypen",
    "text": "6.1 Fundamentale Datentypen\n\n6.1.1 Undefinierte Werte\nR kennt zwei voneinander verschiedene Werte für undefinierte Werte.\n\nNULL\nNA\n\nWeder NULL noch NA sind in R gleichwertig mit dem Wert 0. Die beiden Werte sind ausserdem nicht gleich und haben eine leicht unterschiedliche Bedeutung.\nNULL bedeutet, dass kein Wert vorhanden ist und kein Datentyp bekannt ist. Dieses Symbol ist für die Programmierung von Bedeutung und zeigt für eine Variable (Kapitel 8) an, dass diese auf keinen Wert im Speicher des Computers verweist. Das Symbol NULL ist ein eigener Datentyp.\nNA (für not available) bedeutet, dass ein Wert fehlt, obwohl ein Wert erwartet wird. In diesem Fall ist der Datentyp bekannt. Dieser Wert bezieht sich auf die Daten und zeigt fehlende Werte an. Der Wert NA hat einen beliebigen Datentyp ausser NULL. NA ist ein Platzhalter für fehlende Werte in Daten, der immer ausserhalb des gültigen Wertebereichs der Daten liegt. Damit müssen fehlende Werte in R nicht durch einen alternativen Wert ersetzt werden.\nBeim Zählen von Werten werden NA-Werte mitgezählt. Für mathematische Operationen, wie der Addition oder der Multiplikation, führt ein Operand mit Wert NA als Operand immer zum Ergebnis NA. Deshalb müssen NA Werte vor allen anderen Operationen behandelt werden.\n\n\n6.1.2 Zahlen\nR unterscheidet drei Arten von Zahlen:\n\nGleitkomma (numeric())\nGanzzahlen (integer())\nKomplexe Zahlen (complex())\n\nStandardmässig werden alle Zahlenwerte als Gleichkommazahlen erstellt. Gleitkommazahlen können sowohl direkt oder in wissenschaftlicher Notation eingegeben werden. Bei der wissenschaftlichen Notation muss immer der Nachkommaanteil angegeben werden.\n\nBeispiel 6.1 (Zahlenbeispiele in R)  \n5\n5.374\n3.92e+2\n1.0e-5\n\nDas kann mit der Funktion is.numeric() überprüft werden. Diese Funktion liefert Wahr zurück, wenn ein Wert eine Gleitkommazahl ist oder als solche behandelt werden kann.\nDie Werte anderer Datentypen lassen sich mit der Funktion as.numeric() in Zahlen umwandeln. Lässt sich ein Wert nicht eine Zahl umwandeln, dann wird der Wert NA mit einer entsprechenden Warnung erzeugt.\nGelegentlich müssen ganzzahlige Werte sichergestellt werden. Diese Werte werden aus Gleitkommazahlen mit der Funktion as.integer() erzeugt. Wird eine Gleitkommazahl in eine Ganzzahl umgewandelt, dann wird nur der ganzzahlige Teil behalten. Der Nachkommateil wird gestrichen und nicht gerundet. Grundsätzlich sind alle Längen und alle Indizes in R automatisch Ganzzahlen und müssen nicht umgewandelt werden.\nKomplexe Zahlen sind spezielle Zahlen, die über dem Zahlenraum der reellen bzw. Gleitkommazahlen hinausgehen. Eine Komplexe Zahl besteht aus einem reellen und einem imaginären Zahlenanteil. Der imaginäre Zahlenanteil ist als ein Vielfaches der Zahl i = \\sqrt{-1} definiert. In R wird diese Beziehung der beiden Teile als Summe dargestellt.\n\nBeispiel 6.2 (Darstellung einer komplexen Zahl)  \n3+7i\n\nAlternativ können komplexe Zahlen mit der Funktion complex() erzeugt werden. Dazu werden bei beiden Zahlenanteile getrennt über die Parameter real und imaginary angegeben, wobei beim imaginären Teil das nachfolgende i durch die Funktion eingefügt wird.\n\nBeispiel 6.3 (Erzeugen eines Vektors von komplexen Zahlen mit complex())  \ncomplex(real = c(2,8), imaginary = c(3, 7))\n[1] 2+3i 8+7i\n\nFür reelle Zahlen gilt, dass der imaginäre Anteil gleich 0 ist. Mit der Funktion as.complex() lässt sich jede Zahl in eine komplexe Zahl umwandeln. Wird eine so erstelle komplexe Zahl mit der ursprünglichen reellen Zahl verglichen, dann zeigt R korrekt an, dass die beiden Werte gleich sind.\n\n\n\n\n\n\nPraxis\n\n\n\nIn der Praxis wird die Umwandlung von reellen in komplexe Zahlen R überlassen.\n\n\n\nBeispiel 6.4 (Umwandeln einer reelen Zahl in eine komplexe Zahl)  \nas.complex(2.2)\n2.2+0i\n\nNeben den klassischen Zahlen verfügt R über das Konzept Unendlich, das in vielen Programmiersprachen fehlt. Ein unendlicher Wert wird durch das Symbol Inf dargestellt. Weil sowohl positive als auch negative unendliche Werte existieren steht Inf für positiv unendlich und -Inf für negativ unendlich.\n\n\n6.1.3 Zeichenketten\nZeichenketten heissen in R Character-Strings (character()). Zeichenketten müssen immer in Anführungszeichen eingefasst werden. Als Anführungszeichen dürfen das einfache Anführungszeichen (') oder das doppelte Anführungszeichen (\") verwendet werden.\n\nBeispiel 6.5 (Gleichwertige Zeichenketten mit einfachen und doppelten Anführungszeichen)  \n'Daten und Information'\n\"Daten und Information\"\n\n\n\n\n\n\n\nPraxis\n\n\n\nDie Lesbarkeit von R-Code wird dadurch verbessert, dass konsequent nur ein Symbol für die Kennzeichnung von Zeichenketten verwendet wird. Die Wahl welches der beiden Zeichen benutzt wird, wird von persönlichen Vorlieben geleitet. In diesem Buch wird konsequent das doppelte Anführungszeichen (\") eingesetzt, weil dadurch leere Zeichenketten direkt als solche erkennbar sind und dieses Symbol auch in anderen Programmiersprachen und Dateiformaten zur Kennzeichnung von Zeichenketten benutzt wird.\n\n\n\nBeispiel 6.6 (Leere Zeichenketten mit einfachen und doppelten Anführungszeichen)  \n''\n\"\"\n\nUm zu überprüfen, ob ein Wert eine Zeichenkette ist, wird die Funktion is.character() verwendet. Diese Funktion ergibt Wahr, wenn der Wert eine Zeichenkette ist und in allen anderen Fällen Falsch.\nUm einen anderen Wert in eine Zeichenkette umzuwandeln bzw. zu serialisieren, wird die Funktion as.character() eingesetzt.\n\nBeispiel 6.7 (Eine Zahl in eine Zeichenkette serialisieren)  \nas.character(123.4)\n# ergibt \"123.4\"\n\n\n\n6.1.4 Wahrheitswerte\nR kennt die beiden Wahrheitswerte Wahr und Falsch bzw. die englischen Begriffe True und False. In R müssen Wahrheitswerte ( logical()) immer in Grossbuchstaben geschrieben werden. Der Wert Wahr wird also TRUE und der Wert Falsch wird FALSE geschrieben.\nBeide Wahrheitswerte dürfen mit dem Anfangsbuchstaben abgekürzt werden. Auch dieser Buchstabe muss gross geschrieben werden. Die Werte T und TRUE sowie F und FALSE sind deshalb immer gleich.\nDie Werte TRUE und FALSE dürfen nicht in Anführungszeichen eingefasst werden, denn sonst werden sie als Zeichenketten und nicht als Wahrheitswerte interpretiert.\nNormalerweise müssen Wahrheitswerte nicht mit is.logical() geprüft oder mit as.logical() aus anderen Datentypen erzeugt werden.\n\n\n6.1.5 Faktoren\nEin besonderer Datentyp von R sind Faktoren (factor()).\n\nDefinition 6.1 Ein Faktor ist ein diskreter Datentyp mit einem festen Wertebereich mit einer ganzzahligen Ordnung.\n\nDie angezeigten Werte eines Faktors können als Zahlen, Zeichenketten oder Wahrheitswerte dargestellt werden. Jeder Faktor hat einen definierten Wertebereich, wobei die Werte dieses Wertebereichs diskret sind und eine ganzzahlige Ordnung haben. Mit Faktoren können nominal- und ordinalskalierte Datentypen abgebildet werden. Die Ordnung eines Faktor wird für die visuelle Darstellung der Werte verwendet und für Vergleiche von Werten berücksichtigt.\nEin Faktor ist in R ein eigener fundamentaler Datentyp und kann nicht als Datentyp der dargestellten Werte verwendet werden.\nDie Ordnungswerte eines Faktors lassen sich in Ganzzahlen ausgeben und entsprechend weiter verarbeiten. In diesem Fall muss der Faktor mit der Funktion as.integer() in Zahlen umgewandelt werden.\nDer Wertebereich eines Faktors kann mit der Funktion levels() abgefragt werden.\nDer Wertebereich eines Faktors ist standardmässig Alphanumerisch geordnet. Für ordinalskalierte Datentypen kann diese Reihung angepasst werden (s. Kapitel 10).\n\n\n\n\n\n\nWarnung\n\n\n\nDer tatsächliche Wertebereich eines Faktors umfasst immer nur die vorhandenen Werte in den Daten. Die nicht vorkommenden Werte werden von R aus dem Wertebereich eines Faktors entfernt."
  },
  {
    "objectID": "kapitel/datentypen/kapitel.html#datenstrukturen",
    "href": "kapitel/datentypen/kapitel.html#datenstrukturen",
    "title": "6  Datentypen",
    "section": "6.2 Datenstrukturen",
    "text": "6.2 Datenstrukturen\nDie zentralen Datenstrukturen von R sind Vektoren, Listen, Matrizen und Data-Frames.\n\n6.2.1 Vektoren\nVektoren sind Datenstrukturen, bei denen alle Elemente vom gleichen Datentyp sind. Alle Werte mit fundamentalen Datentyp sind in R grundsätzlich Vektoren mit einem Element. Diese Eigenschaft mit der Funktion is.vektor() überprüft werden. Diese FUnktion hat als Ergebnis Wahr, wenn die Eingabe ein Vektor ist und in allen anderen Fällen Falsch. Wird der Funktion ein Wert übergeben, dann gibt die Funktion Wahr (bzw. TRUE) zurück.\n\nBeispiel 6.8 (Ein Wert ist ein Vektor)  \nis.vector(1)\n# ergibt TRUE\n\nUm Werte zu längeren Vektoren zu Verknüpfen wird die Verbindenfunktion c() benutzt. Diese Funktion verbindet Vektoren so dass die Werte der Eingabevektoren im Ergebnisvektore nacheinander in der Reihenfolge der Eingabe vorliegen.\n\nBeispiel 6.9 (Erzeugen eines Vektors aus einzelnen Werten)  \nc(1, 2, 3)\n# ergibt {1, 2, 3}\n\nDie c()-Funktion hat immer einen Vektor als Ergebnis. Werden Vektoren als Eingabe verwendet, dann werden die Vektoren zu einem neuen Vektor zusammengefügt.\n\nBeispiel 6.10 (Erzeugen eines Vektors aus mehreren Vektoren)  \nc(c(3, 4), c(1, 2), c(5, 6))\n# ergibt {3, 4, 1, 2, 5, 6}\n\nVersucht man Vektoren aus Werten mit unterschiedlichen Datentypen zu erstellen, dann werden alle Werte in den allgemeinsten auftredenten Datentyp umgewandelt. Dabei gilt die Reihenfolge vom allgemeinsten Datentyp zum speziellsten Datentyp: Zeichenkette, Zahl, Wahrheitswert.\n\nBeispiel 6.11 (Erzeugen eines Vektors mit unerschiedlichen Datentypen)  \nc(1, TRUE, \"Daten und Information\")\n# ergibt {\"1\", \"TRUE\", \"Daten und Information\"}\n\nc(1, TRUE, 2 FALSE)\n# ergibt {1, 1, 2, 0}\n\nAlle Vektoren haben eine Länge, die mit der Funktion length() ermittelt wird.\n\nBeispiel 6.12 (Länge eines Vektor bestimmen)  \nlength(c(1,3,7))\n# ergibt 3\n\nDamit einzelne Werte eines Vektors angesprochen werden können, müssen eckige Klammern ([]) verwendet werden.\n\nBeispiel 6.13 (Ein Vektorelement über dessen Index ansprechen)  \nc(1, 7, 13) -&gt; vektor123\n\nvektor123[2] # ergibt 7\n\n\n\n\n\n\n\nPraxis\n\n\n\nIn der Regel werden die einzelnen Elemente von Vektoren nicht über den Index angesprochen. Im Gegensatz zu anderen Programmiersprachen hat die Verwendung des Vektorindex in R keine grosse Bedeutung.\n\n\nVektoren sind eingeschränkt auf eine Dimension. Um komplexere Datenstrukturen zu erhalten, müssen weitere Datenstrukturen hinzugezogen werden.\n\n\n6.2.2 Listen\nListen ähneln Vektoren in vielen Punkten. Der zentrale Unterschied zwischen Listen und Vektoren ist, dass die Elemente von Listen einen beliebigen Datentyp haben dürfen. Listen werden in R mit der Funktion list() erzeugt.\n\nBeispiel 6.14 (Erzeugen einer Liste aus einzelnen Werten)  \nlist(1, TRUE, \"Daten und Information\")\n# erzeugt {1, TRUE, \"Daten und Information\"}\n\nDie Funktion is.list() überprüft, ob ein Wert eine Liste ist. Die Funktion length() liefert die Anzahl der Elemente in einer Liste.\nIm Vergleich zur Funktion c() fügt die Funktion list() Listen nicht zusammen, sondern behandelt alle Eingabewerte als eigene Elemente. D.h. der Datentyp jedes Werts bleibt erhalten, wenn dieser einer Liste hinzugefügt wird. Diese Eigenschaft lässt sich ausnutzen, um geschachtelte Datenstrukturen zu erzeugen. Beispiel 6.15 zeigt die Erstellung einer geschachtelten Liste mit zwei unterschiedlich langen Vektoren.\n\nBeispiel 6.15 (Geschachtelte Liste mit zwei Vektoren)  \nlist(c(1, 2), c(3, 4, 5))\n\nDer Listen verwenden zur Indizierung doppelte eckige Klammern ([[]]). Nur so lassen sich die Werte der Liste korrekt referenzieren.\n\nBeispiel 6.16  \nlist(1, TRUE, \"Daten und Information\") -&gt; gemischteListe \n\ngemischteListe[[3]]\n# ergibt \"Daten und Information\"\n\n\n\n\n\n\n\nWarnung\n\n\n\nDer Vektorindex kann auch für Listeneinträge verwendet werden. In diesem Fall wird eine Liste zurückgegeben, die nur die ausgewählten Listenelemente enthält. Das ist normalerweise nicht gewünscht.\n\n\n\n6.2.2.1 Benannte Listen\nListeneinträge können Namen haben. Diese können später zum Referenzieren der Listeneinträge verwendet werden. Auf diese Weise lassen sich objektartige Strukturen erzeugen. Benannte Einträge lassen sich über die Position des Werts oder dem Namen als Index ansprechen. Wird ein Name als Index verwendet, dann muss dieser als Zeichenkette angegeben werden. Häufiger findet sich jedoch die Dollar-Referenzierung in R-Skripten. Die Dollar-Referenzierung verwendet das Dollar-Zeichen ($) um auf einen Namen zuzugreifen. Damit diese Referenzierung funktioniert, muss der Name ein gültiges R-Symbol sein, dass nicht markiert werden muss. Alle anderen Namen müssen als Listenindex verwendet werden. Beispiel 6.17 zeigt die verschiedenen Zugriffsarten für benannte Listen.\n\nBeispiel 6.17 (Verwendung benannter Listen)  \nlist(modul = \"Daten und Information\", \n     semester = 1) -&gt; \n        benannteListe\n\nbenannteListe[[2]] # ergibt 1\nbenannteListe[[\"semester\"]] # ergibt 1\nbenannteListe$semester # ergibt 1\n\n\n\n\n\n\n\nHinweis\n\n\n\nIn R müssen nicht alle Listeneinträge benannt sein. Es ist normal, dass sowohl benannte als auch unbenannte Listenelemente vorhanden sind. Unbenannte Listeneinträge können nur über ihre Position angesprochen werden.\n\n\n\n\n\n6.2.3 Matrizen\nAls vektororientierte Sprache ist die Matrix ein wichtiges Konstrukt der Datenstrukturierung. Alle Werte einer Matrix müssen vom Datentyp Zahl sein. Man kann sich eine Matrix als Vektor von gleichlangen Vektoren vorstellen. Wegen der besonderen Eigenschaften von R-Vektoren ist diese Art der Schachtelung jedoch nicht möglich.\nEine Matrix wird in R immer aus Vektoren erzeugt. Dafür gibt es vier Wege.\nEine Matrix wird aus einem Vektor über die Zeilenzahl m erstellt. Dabei werden immer m aufeinanderfolgende Werte eines Vektors in eine Spalte geschrieben.\n\nBeispiel 6.18 (eine m-Matrix aus einem Vektor erstellen)  \nmatrix(c(1,2,3,4,5,6), nrow = 2)\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nEine Matrix wird aus einem Vektor über die Spaltenzahl n erstellt. Dazu wird der Vektor in n grosse Blöcke aufeinanderfolgender Werte gegliedert, die jeweils in eine Spalte geschrieben werden.\n\nBeispiel 6.19 (eine n-Matrix aus einem Vektor erstellen)  \nmatrix(c(1,2,3,4,5,6), ncol = 2)\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\nEine Matrix wird über das Kreuzprodukt (Kapitel 13) aus zwei Vektoren erstellt.\n\nBeispiel 6.20  \nc(1, 2, 3) %*% t(c(3, 4, 5))\n     [,1] [,2] [,3]\n[1,]    3    4    5\n[2,]    6    8   10\n[3,]    9   12   15\n\n\n\n\n\n\n\nWarnung\n\n\n\nWird lässt sich der Ausgangsvektor nicht in die angegebene Zeilen- oder Spaltenzahl gliedern, dann werden die Vektorwerte solange wiederholt, bis die Matrix aufgefüllt wurde und eine eine Warnrmeldung ausgegeben. Dadurch ist das Ergebnis nicht immer klar nachvollziehbar.\n\n\nEine Matrix wird über das äussere Matrixprodukt (Kapitel 13) aus zwei Vektoren erstetllt.\n\nBeispiel 6.21 (eine -Matrix aus Vektoren erstellen)  \nc(1, 2, 3) %o% c(3, 4, 5)\n     [,1] [,2] [,3]\n[1,]    3    4    5\n[2,]    6    8   10\n[3,]    9   12   15\n\n\n\n\n\n\n\nPraxis\n\n\n\nDas Kreuzprodukt sollte nicht zum Erzeugen von Matrizen verwendet, sondern ausschliesslich als mathematische Operation behandelt werden. Das äussere Produkt ist flexibler und einfacher anzuwenden.\n\n\nMit der Funktion is.matrix() kann überprüft werden, ob eine Datenstruktur eine Matrix ist. Erfüllt eine tabellarische Struktur die Kriterien für eine Matrix, dann kann diese Struktur mit der Funktion as.matrix() in eine Matrix umgewandelt werden.\nDie R-Matrix ähnelt der Struktur von Vektoren.\n\nEine Matrix hat eine Länge. Diese Länge entspricht der Gesamtzahl der Elemente der Matrix.\nWird eine Matrix in der Funktion c() als Wert übergeben, dann wird die Matrix zuerst in einen Vektor umgewandelt.\n\nWeil die Anzahl der Spalten und Zeilen nicht über die Länge bestimmt werden kann, muss zu diesem Zweck die Funktion dim() verwendet werden. dim() gibt die Anzahl der Zeilen und der Spalten in dieser Reihenfolge aus.\nDie Werte in einer R-Matrix können über den Zeilen- und Spaltenindex abgefragt werden. Dazu werden wie bei den Vektoren einfache eckige Klammern verwendet. Der Zeilen- und Spaltenindex werden dabei durch ein Komma voneinander getrennt.\n\nBeispiel 6.22 (Einen Wert über den Matrix-Index zugreifen)  \nc(1, 2, 3) %o% c(3, 4, 5) -&gt; matrix123\nmatrix123[2,2] # ergibt 8\n\nWird beim Matrix-Index der Zeilen- oder der Spaltenindex weggelassen, wird eine ganze Zeile bzw. Spalte als Vektor ausgewählt.\n\n\n\n\n\n\nPraxis\n\n\n\nÄhnlich wie bei Vektoren, ist es in der Praxis nur sehr selten notwendig, auf die Werte einer Matrix zuzugreifen.\n\n\n\n\n6.2.4 Data-Frames\nEin Data-Frame ist eine benannte geschachtelte Liste mit Vektoren gleicher Länge. Diese Datenstruktur ist die Basis für Datentabellen. Anders als eine normale geschachtelte Liste stellt ein Date-Frame zusätzlich sicher, dass alle Vektoren immer die gleiche Länge haben.\nData-Frames werden normalerweise mit den Funktionen tibble() oder tribble() erstellt. Diese Funktionen sind nur in tidy R verfügbar. Diese Funktionen erzeugen eine effizienteren und damit schnelle Version eines Data-Frames als Base R.\n\n\n\n\n\n\nPraxis\n\n\n\nData-Frames werden normalerweise beim Einlesen der Daten mit der korrekten Datenstruktur automatisch erzeugt. Händisches Erstellen von Date-Frames ist dann nicht mehr notwendig.\n\n\nWeil Data-Frames spezielle Listen sind, können sie genau gleich wie Listen behandelt werden. Es lassen sich damit die gleichen Zugriffe, wie bei Listen umsetzen.\n\n\n\n\n\n\nHinweis\n\n\n\nVektoren in Data-Frames können Listen als Datentyp haben, was bei normalen Vektore nicht möglich ist. Diese besondere Eigenschaft wird im Kapitel 16 ausgenutzt.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nDie Behandlung von Data-Frames als geschachtelte Listen ist inzwischen unüblich. Stattdessen sollten die effizienteren und leichter zu merkenden Transformationsschritte eingesetzt werden."
  },
  {
    "objectID": "kapitel/daten-importieren-exportieren/kapitel.html#daten-importieren",
    "href": "kapitel/daten-importieren-exportieren/kapitel.html#daten-importieren",
    "title": "7  Importieren und Exportieren",
    "section": "7.1 Daten importieren",
    "text": "7.1 Daten importieren\nDas Einlesen von Datendateien ist ein zentraler Bestandteil von R, weil es die Voraussetzung für die statistische Programmierung bildet. Diese Funktionen gehen jedoch nicht sehr sparsam mit dem Arbeitsspeicher unseres Computers um, sodass sehr grosse Datenmengen immer wieder zu Problemen führen.\nDie readr-Bibliothek ersetzt die Base R-Funktionen zum Einlesen von Dateien durch flexiblere und effizientere Funktionen. Diese Funktionen können mit grösseren Datenmengen umgehen und schonen den verfügbaren Arbeitsspeicher. Deshalb sind die readr-Funktionen den jeweiligen Gegenstücken von Base R vorzuziehen.\n\n7.1.1 Dateitypen\nFür den Austausch von Stichproben stehen verschiedene Dateiformate zur Verfügung. Diese Dateiformate unterscheiden sich durch die Strategie, mit der die Werte in den einzelnen Tabellenzellen unterschieden werden.\nDie wichtigsten Formate sind:\n\nTabulator getrennte Werte (TSV, tabulator-separated values)\nKomma getrennte Werte (CSV, comma-separated values)\nExcel Tabellen (via readxl-Bibliothek)\nFixformat Tabellen (FWF, fixed-width format)\nR-Datendateien (RDS, R-data structure)\n\nDiese Dateien können wir mit den folgenden Funktionen einlesen.\n\n\n\nFormat\ntidy R\nBase R\n\n\n\n\ntxt (ganze Datei)\nread_file()\nreadChar() + file.info()\n\n\ntxt (zeilenweise)\nread_lines()\nreadLines() + file()\n\n\ncsv (mit , als Trennzeichen)\nread_csv()\nread.csv()\n\n\ncsv (mit ; als Trennzeichen)\nread_csv2()\nread.csv2()\n\n\ntsv\nread_tsv()\nread.table()\n\n\nxls (Excel Arbeitsmappen mit readxl)\nread_excel()\n-\n\n\nFWF\nread_fwf()\n-\n\n\nRDS\nread_rds()\nreadRDS()\n\n\n\nDie Base R Funktionen read.table(), read.csv und read.csv2() importieren Zeichenketten als Faktoren (s. Kapitel 6). Damit können diese Werte nicht direkt als Zeichenketten behandelt werden. Diese automatische Behandlung entfällt bei den jeweiligen tidy R Varianten. Dadurch lassen sich Daten intuitiver bearbeiten.\n\n\n\n\n\n\nAchtung\n\n\n\nIn der Schweiz kann das CSV-Format zu Verwirrung führen, weil sehr häufig das Semikolon als Spaltentrennzeichen und der Punkt als Dezimaltrennzeichen verwendet werden. Die Ursache für diese Situation sind CSV-Dateien, die aus Excel exportiert wurden.\nDie normalerweise für dieses Format empfohlene Funktion read_csv2() behandelt Dezimalzahlen fälschlich als Ganzzahlen. Um dieses Problem zu beheben, sollte das Dezimaltrennzeichen laut Dokumentation wie folgt angepasst werden:\nread_csv2(datei_name, locale = locale(decimal_mark = \".\"))\n\n\nBei der modernen read_ Variante können wir uns leicht an der Dateiendung orientieren, um die richtige read_-Funktion auszuwählen.\nWenn eine Datei eingelesen wird, dann gibt die jeweilige read_-Funktion neben den Daten auch zurück, wie die Datei eingelesen wurde. Enthält die eingelesene Datei die erwarteten Spaltenüberschriften, dann wurde das richtige Dateiformat ausgewählt.\n\n\n7.1.2 Dateien mit einer Spalte\nCSV-Dateien können mit Komma oder Semikolon als Trennzeichen erstellt werden. Falls eine Datei mit nur einem Datenvektor importiert werden muss, dann kann R das Spaltentrennzeichen nicht finden. In solchen Fälle muss die Datei mit der read_csv() oder read_csv2()-Funktion noch einmal eingelesen werden.\nFür Spalten mit Zeichenketten oder Ganzzahlen wird immer die Funktion read_csv() verwendet.\nFür Gleitkommazahlen erfolgt die Auswahl auf Grundlage des verwendeten Dezimaltrennzeichens. Wird der Dezimalpunkt verwendet, dann muss die Funktion read_csv() benutzt werden. Wird das Dezimalkomma verwendet, dann muss die Funktion read_csv2() eingesetzt werden.\n\n\nBeispiel 7.1 (Datei mit einer Spalte importieren) Mit dem Aufruf read_csv(\"beispieldaten.csv\") werden Daten mit einem Komma als Trennzeichen und mit Dezimalpunkt eingelesen.\nMit dem Aufruf read_csv2(\"beispieldaten.csv\") werden Daten mit einem Semikolon als Trennzeichen und mit Dezimalkomma eingelesen.\nIn beiden Fällen nutzen wir dieses Verhalten aus, um eine Stichprobe mit nur einer Spalte einzulesen.\n\n\n\n\n7.1.3 Excel Arbeitsmappen\n\n\n\n\n\n\nPraxis\n\n\n\nLiegen Daten in einer Excel Arbeitsmappe vor, dann muss diese Arbeitsmappe nicht in ein anderes Dateiformat umgewandelt werden, damit die Daten in R importiert werden können.\n\n\nIn Excel werden Daten in Arbeitsmappen organisiert. Es ist also möglich, mehr als eine Tabelle und darauf basierende Operationen in einer Datei zu speichern. Damit Daten aus Arbeitsmappen in R importiert werden können, müssen die Struktur der Arbeitsmappe bekannt sein.\nEine Excel Arbeitsmappe ist eine Datei, die üblicherweise auf .xlsx endet. Die Dateiendung signalisiert uns meistens die interne Organisation einer Datei. Interne Organisation einer Datei bedeutet, in welcher Folge die Daten in einer Datei auf der Festplatte abgelegt sind.\nNur das Dateiformat von .xlsx-Dateien unterstützt alle Funktionen von Excel und kann von R korrekt eingelesen werden\nDas Dateiformat wird in Excel im Speichern-Unter-Dialog festgelegt. Dieser Dialog erscheint in der Regel, wenn eine neue Arbeitsmappe das erste Mal gespeichert wird. Wenn im Start-Dialog von Excel einfach eine neue Arbeitsmappe erstellt wird, dann erzeugt Excel automatisch eine Arbeitsmappe im Excel-Format.\n\n\n\n\n\n\nMerke\n\n\n\nExcel-Dateien sind Dateien mit der Endung .xlsx oder .xlsund werden als Excel Arbeitsmappen bezeichnet. Nur Dateien mit dieser Endung können in R als Excel-Datei importiert werden.\n\n\nExcel Arbeitsmappen haben vier zentrale Strukturelemente:\n\nArbeitsblätter\nAdressbereiche\nZellenwerte\nZellenformeln\n\nJedes Arbeitsblatt einer Arbeitsmappe hat einen eindeutigen Namen.\nDie Adressbereiche sind in Zeilen und Spalten gegliedert. Wir finden Daten daher immer auf einem bestimmten Arbeitsblatt in einem bestimmten Adressbereich. Die konkrete Position der Daten in der Arbeitsmappe legen die Autoren willkürlich fest.\nJede Zelle eines Arbeitsblatts hat immer zwei gleichzeitige Zustände, die immer in einer Excel Arbeitsmappe gespeichert werden:\n\nJede Zelle hat einen Wert.\nJede Zelle hat eine Operation.\n\nAus diesen Strukturelementen ergeben sich zwei Konsequenzen:\n\nEin Arbeitsblatt kann mehr als eine Tabelle mit Daten enthalten.\nDie Daten müssen nicht am Anfang (d.h. in der ersten Zeile und ersten Spalte) eines Arbeitsblatts beginnen.\n\nUm mit den Daten in Excel Arbeitsmappen arbeiten zu können, müssen bekannt sein, auf welchem Arbeitsblatt und in welchem Adressbereich die Daten stehen.\n\n\n\n\n\n\nMerke\n\n\n\nTabellen sind keine Strukturelemente von Excel Arbeitsmappen, die in R zugänglich sind.\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nWenn Excel Arbeitsmappen mit Excel geöffnet werden, dann berechnet Excel alle Operationen auf allen Arbeitsblättern neu. Damit werden die Werte in der Arbeitsmappe verändert.\nEs kommt also vor, dass sich eine Arbeitsmappe ändert, ohne dass eine Interaktion vorgenommen wurde. In diesen Fällen fragt Excel beim Schliessen der Arbeitsmappe, ob die Änderungen gespeichert werden sollen.\nWird eine Excel Arbeitsmappe in R (oder in einer anderen Programmiersprache) geöffnet, dann wird nur die Arbeitsmappe geöffnet ohne die Operationen neu zu berechnen.\n\n\nMit den Funktionen der readxl-Bibliothek können wir Excel Arbeitsmappen nach R importieren. Dabei sind zwei Funktionen von besonderer Bedeutung:\n\nexcel_sheets(dateiname) und\nread_excel(dateiname, sheet)\n\nMit der Funktion excel_sheets() können die vorhandenen Arbeitsblätter erkannt werden. Das Ergebnis dieser Funktion ist die Liste der Arbeitsblattnamen in einer Arbeitsmappe. Diese Funktion sollte vor dem Import von Daten zur Kontrolle der Arbeitsblattnamen verwendet werden.\nDie Funktion read_excel() erlaubt es einzelne Arbeitsblätter zu importieren. Wenn kein Arbeitsblattname für den Parameter sheet übergeben wird, dann nimmt die Funktion das aktive oder das erste Arbeitsblatt in der Arbeitsmappe.\nMit den readxl-Funktionen können keine Formeln aus den Zellen ausgelesen werden.\n\nBeispiel 7.2 (Excel-Arbeitsmappe importieren)  \nlibrary(readxl)\n\nArbeitsblaetter = excel_sheets(\"Bestellungen_2.xlsx\")\n# Das Arbeitsblatt \"Daten\" sollte vorhanden sein.\n\nDaten = read_excel(\"Bestellungen_2.xlsx\", \"Daten\")\n\nDie Funktion read_excel() importiert alle Daten auf einem Arbeitsblatt. Enthält nur ein bestimmter Bereich auf einem Arbeitsblatt die Daten von Interesse, dann muss dieser Bereich als Excel-Bereichsadresse angegeben werden.\n\n\n\n\n\n\nWarnung\n\n\n\nread_excel() kann nur mit Excels Arbeitsblattadressen umgehen. Tabellenadressen oder die Gatter-Notation beherrscht die Funktion nicht."
  },
  {
    "objectID": "kapitel/daten-importieren-exportieren/kapitel.html#daten-exportieren",
    "href": "kapitel/daten-importieren-exportieren/kapitel.html#daten-exportieren",
    "title": "7  Importieren und Exportieren",
    "section": "7.2 Daten exportieren",
    "text": "7.2 Daten exportieren\nR unterstützt den Export strukturierter Daten in Textdateien. Beim Exportieren kommen für die Formate TSV und CSV werden die entsprechenden Funktionen write_tsv(), write_csv() und write_csv2() benutzt. Für speziellformatierte Dateien kann die Funktion write_delim() eingesetzt werden.\nAlle Export-Funktionen erwarten eine Datenstruktur als ersten Parameter und einen Dateinamen als zweiten Parameter. Der Dateiname legt fest, wohin das Ergebnis der Funktion auf dem Computer geschrieben werden soll.\nDie Import- und Export-Funktionen lassen sich zu einfachen Konvertierungsprogrammen verknüpfen. Beispiel 7.3 korrigert von Excel exportierte CSV-Dateien in ein gültiges CSV-Format.\n\nBeispiel 7.3 (“Schweizer” CSV-Format korrigieren)  \nlibrary(readr)\n\nwrite_csv(\n    read_csv2(\"Bestellungen_2.csv\"), \n    \"Bestellungen_korrigiert.csv\" \n)\noder eleganter mit Funktionsverkettung:\nread_csv2(\"Bestellungen_2.csv\") |&gt;  write_csv(\"Bestellungen_korrigiert.csv\" )\n\n\n\n\n\n\n\nWarnung\n\n\n\nR kann Excel Arbeitsmappen nicht exportieren. Die readr-Funktionen write_excel_csv() und write_excel_csv2() exportieren CSV-Dateien mit einer zusätzlichen Markierung am Dateianfang. Diese Funktionen sollten nur verwendet werden, wenn eine CSV-Datei nur mit Excel importiert werden soll und nicht für die Archivierung oder Weiterverarbeitung gedacht ist.\nDie zusätzliche Markierung wird als Byte Order Mark (BOM) bezeichnet und muss das UTF8-Symbol FEFF sein. Dieses Symbol ist ein Leerzeichen ohne Länge und wird deshalb nie dargestellt. Excel bzw. Power Query verwenden das BOM, um UTF8-kodierte Dateien zu identifizieren."
  },
  {
    "objectID": "kapitel/daten-importieren-exportieren/kapitel.html#json-daten",
    "href": "kapitel/daten-importieren-exportieren/kapitel.html#json-daten",
    "title": "7  Importieren und Exportieren",
    "section": "7.3 JSON-Daten",
    "text": "7.3 JSON-Daten\nJSON ist ein Datenformat, dass von vielen sog. Web-Diensten zum Austausch von Datenstrukturen eingesetzt wird. R kann dieses Datenformat mit der tidyverse-Bibliothek jsonlite importieren und auch exportieren. jsonlite stellt zwei Funktionen für den regelmässigen Einsatz bereit:\n\nfromJSON()\ntoJSON()\n\nDie beiden Funktionen fromJSON() und toJSON() unterstützen das Parsen von und Serialisieren zu Zeichenketten im JSON-Format.\nUm Daten aus einer Textdatei im JSON-Format zu importieren, kann die Funktion read_json() verwendet werden.\n\nBeispiel 7.4 (JSON Daten aus einer Datei importieren)  \nlibrary(jsonlite)\n\nDaten = read_json(\"beispiele/daten.json\", simplifyVektor = TRUE)\n\nMit der Funktion toJSON() werden Daten in eine JSON-formatierte Zeichenkette umgewandelt. Diese Zeichenkette kann anschliessend mit write_file() in eine Datei geschrieben werden (Beispiel 7.5). Dieser Doppelschritt kann mit der Funktion write_json() zusammengefasst werden (Beispiel 7.6).\n\nBeispiel 7.5 (Daten im JSON-Format exportieren)  \nwrite_file(toJSON(Daten),\"neue_daten.json\"))\n\n\nBeispiel 7.6 (Daten im JSON-Format exportieren und in eine Datei schreiben)  \nwrite_json(Daten,\"neue_daten.json\")\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie beiden Funktionen read_json() und write_json() erlauben das Lesen und Schreiben von Textdateien im JSON-Format. Die Standardeinstellungen sind jedoch nicht identisch mit denen von fromJSON() und toJSON(), so dass der Import und Export mit diesen Funktionen komplexer ist, als mit der oben beschrieben Technik."
  },
  {
    "objectID": "kapitel/daten-importieren-exportieren/kapitel.html#yaml-daten",
    "href": "kapitel/daten-importieren-exportieren/kapitel.html#yaml-daten",
    "title": "7  Importieren und Exportieren",
    "section": "7.4 YAML-Daten",
    "text": "7.4 YAML-Daten\nYAML ist eine Verallgemeinerung des JSON-Formats. Mit dem Ziel, dass Menschen komplexe Datenstrukturen leichter eingeben und lesen können. In R wird das Format von der Bibliothek yaml unterstützt. Diese Bibliothek gehört nicht zum tidyverse und muss separat installiert werden.\nDie yaml-Bibliothek stellt vier Funktionen bereit:\n\nyaml.load() zum Parsen einer YAML-formatierte Zeichenkette in einer Datenstruktur.\nas.yaml() zum Serialisieren einer Datenstruktur in eine YAML-Zeichenkette.\nread_yaml() zum Importieren von YAML-Daten aus einer Datei.\nwrite_yaml() zum Schreiben einer Datenstruktur in eine YAML-formatierte Datei.\n\nDer YAML-Parser yaml.load() erzeugt immer eine geschachtelte Datenstruktur aus benannten Listen, unbenannten Listen und Vektoren erzeugt wird. Der Parser erkennt automatisch, ob eine YAML-Liste ein Vektor oder eine Liste ist. YAML-Objekte werden immer in benannte Listen umgewandelt.\n\nBeispiel 7.7 (YAML-Daten mit read_yaml() importieren)  \nlibrary(yaml)\n\nyamlDaten = read_yaml(\"daten.yml\")\n\n\nBeispiel 7.8 (YAML-Daten mit read_yaml() exportieren)  \nyamlDaten |&gt; write_yaml(\"kopie_der_daten.yml\")"
  },
  {
    "objectID": "kapitel/daten-importieren-exportieren/kapitel.html#festkodierte-daten",
    "href": "kapitel/daten-importieren-exportieren/kapitel.html#festkodierte-daten",
    "title": "7  Importieren und Exportieren",
    "section": "7.5 Festkodierte Daten",
    "text": "7.5 Festkodierte Daten\nR unterstützt den Import von festkodierten Daten nicht direkt. Festkodierte Daten benötigen einen eigenen Parser, der die Datenfelder extrahiert. Die prinzipielle Vorgehensweise ähnelt dem Import und Export von JSON-Daten. Dazu werden die Daten als unstrukturierte Textdaten mit der Funktion read_file() eingelesen. Anschliessend werden die Datenfelder mit Zeichenketten-Operationen (Kapitel 9) einzeln extrahiert. Beim Exportieren müssen die Daten zuerst serialisiert werden und anschliessend mit der Funktion write_file() in die entsprechende Datei geschrieben werden."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#variablen",
    "href": "kapitel/variablen/kapitel.html#variablen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.1 Variablen",
    "text": "8.1 Variablen\nVariablen sind spezielle R Symbole (s. Kapitel 4) mit denen Werte für die spätere Verwendung markiert werden. Variablen sind also Bezeichner, welche die eigentlichen Werte substituieren.\nDamit eine Variable einen Wert substituieren kann, muss der Wert der Variablen zugewiesen werden. Ein Wert kann dabei ein einzelner Wert eines fundamentalen Datentyps oder eine komplexe Datenstruktur sein.\nBei der ersten Zuweisung wird eine Variable deklariert (Definition 4.3).\n\nBeispiel 8.1 (Den Wert 1 der Variable var1 zuweisen)  \nvar1 = 1\n\nVariablen müssen in einem Geltungsbereich eindeutig sein. Wird nämlich einer Variable mehrfach zugewiesen, dann ist der Wert einer Variablen der Wert der letzten Zuweisung.\nDer Geltungsbereich (engl. Scope) einer Variablen wird durch Funktionskörper definiert. R kennt dabei drei Arten von Geltungsbereichen. In diesem Zusammenhang spricht man von äusseren (engl. outer scope) und inneren Geltungsbereichen (engl. inner scope).\nGrundsätzlich können alle Variablen in einem Geltungsbereich verwendet werden, die in einem der äusseren Geltungsbereiche deklariert und zugewiesen wurden. Variablen der inneren Geltungsbereiche sind in den äusseren Geltungsbereichen nicht verfügbar.\nDer globale Geltungsbereich gilt für alle Variablen, die ausserhalb einer Funktion oder einer Bibliothek erzeugt werden.\nDer Funktionsgeltungsbereich ist auf den Funktionsköper einer Funktion beschränkt.\nDer Modulgeltungsbereich ist der globale Geltungsbereich einer Funktionsbibliothek. Variablen dieses Geltungsbereichs sind im globalen Geltungsbereich eines R-Scripts nicht erreichbar. In der Praxis spielt dieser Geltungsbereich eine untergeordnete Rolle\n\n\n\n\n\n\nWarnung\n\n\n\nDie letzte Zuweisung ist nicht zwingend die Zuweisung, die als letztes im Code erscheint."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#funktionen",
    "href": "kapitel/variablen/kapitel.html#funktionen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.2 Funktionen",
    "text": "8.2 Funktionen\nIn R bilden Funktionen die Grundlage für die Datenverarbeitung. Fast alle Spracheelemente sind als Funktionen umgesetzt.\n\n8.2.1 Identätsfunktion\nR hat eine explizite Identitätsfunktion identity(). Diese Funktion setzt die Identität für einen Parameter um. Die Funktion wird zur allgemeinen Identitätsfunktion, indem die Parameterliste als Liste übergeben.\n\nBeispiel 8.2 (Mehrparametrische Indentität)  \n\nidentity(list(1, \"Daten und Information\", TRUE))\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"Daten und Information\"\n\n[[3]]\n[1] TRUE\n\n\n\n\n\n8.2.2 Transformationen\nTransformationen verändern die Werte eines Vektors, wobei das Ergebnis immer ein Ergebnis der Länge des ursprünglichen Vektors hat.\nIn R sind alle arithmetischen Operatoren Transformatoren (s. Beispiel 8.3)\n\nBeispiel 8.3 (Additive Transformation eines Zahlenvektors (Skalarprodukt))  \n\nc(1, 9 , 7, 3, 5) * 2\n\n[1]  2 18 14  6 10\n\n\n\nEine besondere Gruppe innerhalb der Transformationen sind die Matrizen-Produkte (Kapitel 13) sowie das Umformen von Vektoren (Kapitel 16). Diese Transformationen erzeugen aus mehreren Vektoren Vektorfelder, wobei die urspünglichen Werte erhalten bleiben bzw. durch eine Multiplikation umgeformt werden.\n\n\n8.2.3 Aggregatoren\nAggregationen fassen Werte eines Vektors zusammen. Das Ergebnis von Aggregatoren ist oft ein einzelner Wert, kann aber auch mehrere Werte umfassen. In solchen Fällen hat das Aggregat höchstens die Länge des Eingabevektors.\nTypische Aggregationen sind die Summe (sum(), Beispiel 8.4) und andere statistische Kennzahlen (Kapitel 17).\n\nBeispiel 8.4 (Summenaggregation)  \n\nc(1, 2, 3, 4) |&gt; sum()\n\n[1] 10\n\n\n\n\n\n8.2.4 Transformationsverben\nDie tidyverse-Bibliothek kennt sog. Transformationsverben. Das sind spezielle Funktionen für die Arbeit mit Datenrahmen. Diese Funktionen vereinheitlichen den Umgang mit Daten, indem sie die Komplexität der notwendigen Arbeitsschritte verbergen. Gleichzeitig machen sie die Intention einer Datentransformation sichtbar.\n\nDie wichtigsten Transformationsverben der tidyverse Bibliothek{#tbl-transformationsverben}\n\n\n\n\n\n\n Funktion\nBeschreibung\n\n\n\n\nmutate()\n Führt eine oder mehrere Transformationen über einen Datenrahmen durch.\n\n\n arrange()\n Ordnet die Datensätze eines Datenrahmens neu an (Kapitel 11).\n\n\nsummarise()\n Führt eine oder mehrere Aggregationen über einen Datenrahmen durch.\n\n\ncount()\nZählt die Anzahl der Datensätze, optional auch entlang gemeinsamer Eigenschaften (Kapitel 12).\n\n\nrename()\nBenennt Vektoren um.\n\n\nselect()\nWählt Vektoren in einem Datenrahmen aus.\n\n\nfilter()\nAggregiert einen Datenrahmen mithilfe von logischen Ausdrücken (Kapitel 11)\n\n\ngroup_by()/ungroup()\nGruppiert einen Datenrahmen mithilfe gemeinsamer Eigenschaften (Kapitel 14)\n\n\npivot_longer()/ pivot_wider()\nÜberführt einen Datenrahmen von der Breitform in die Langform, bzw. umgekehrt (Kapitel 16).\n\n\nnest()/unnest()\n Bettet zusammengehörende Teile eines Datenrahmens als Unterstruktur in einen Datenrahmen ein, bzw. bettet diese Teile aus (Kapitel 16).\n\n\n\nDie beiden wichtigsten Funktionen sind mutate() für Transformationen und summarise() für Aggregationen. Das Ergebnis dieser Funktionen ist immer ein neuer Datenrahmen, welcher die transformierten Daten enthält.\n\n\n8.2.5 Generatoren\nGeneratoren bilden eine besondere Funktionsgruppe in R. Mit ihnen lassen sich Werte erzeugen. In dieser Gruppe gibt es zwei Arten:\n\nSequenzgeneratoren\nZufallsgeneratoren\n\n\n8.2.5.1 Sequenzgeneratoren\nSequenzgeneratoren erzeugen Sequenzen von Werten. Sequenzgeneratoren werden in R zur systematischen Erzeugung von Vektoren verwendet.\nDie beiden wichtigsten Funktionen dieser Gruppe sind die Funktionen seq() und rep().\nDie Funktion seq() erzeugt eine Sequenz von Werten mit fester Schrittweite. In R wird eine Sequenz über einen Startwert sowie die Länge, die Schrittweite oder den Endwert definiert.\n\nBeispiel 8.5 (Sequenzen mit seq() erzeugen)  \n\nseq(5) \n\n[1] 1 2 3 4 5\n\nseq(2, 5) \n\n[1] 2 3 4 5\n\nseq(2, len = 5) \n\n[1] 2 3 4 5 6\n\nseq(2, len = 3, by = 2) \n\n[1] 2 4 6\n\n\n\nSequenzen mit der Schrittweite 0 wiederholen den Startwert für die erforderliche Länge. Solche Sequenzen werden relativ häufig verwendet, weshalb Beispiel 8.6 etwas umständlich ist.\n\nBeispiel 8.6 (Einsvektor der Länge 4 mit seq() erzeugen)  \n\nseq(1, len = 4, by = 0)\n\n[1] 1 1 1 1\n\n\n\nDiese Operation kann mit R vereinfacht werden. Hierfür diehnt die Funktion rep() (für replicate). Die Funktion rep() erfordert den Wiederholungswert sowie die Anzahl der Wiederholungen (Beispiel 8.7).\n\nBeispiel 8.7 (Einsvektor der Länge 4 mit rep() erzeugen)  \n\nrep(1, 4)\n\n[1] 1 1 1 1\n\n\n\n\n\n8.2.5.2 Zufallsgeneratoren\n\nDefinition 8.1 Zufallszahlen sind numerische Werte, die zufällig ausgewählt werden.\n\nZufallszahlen werden in normalen Computer-Programmen relativ selten verwendet.\n\n\n\n\n\n\nMerke\n\n\n\nDie Anwendungsgebiete von Zufallszahlen sind die Krypografie und die Simualation.\n\n\nIn den Datenwissenschaften sind Simulationen ein wichtiges Werkzeug für analytische und prediktive Modelle, insbesondere für die künstliche Intelligenz.\nR bietet die Funktion runif() zur Erzeugung von gleichmässig verteilten Zufallszahlen. Die Funktion generiert zufällig reelle Werte im Intervall von \\left]0, 1 \\right[. In diesem Zusammenhang bedeutet gleichmässig verteilt, dass alle Werte mit gleicher Wahrscheinlichkeit erzeugt werden.\n\n\n\n\n\n\nMerke\n\n\n\nGleichmässig verteilte Werte werden auch als uniforme oder uniform-verteilte Werte bezeichnet.\n\n\n\nBeispiel 8.8 (Fünf Zufallswerte mit runif() erzeugen)  \n\nrunif(5)\n\n[1] 0.67027053 0.03871475 0.03580725 0.32839907 0.68025899\n\n\n\nAus diesen Werten lassen sich beliebige Zufallsvektoren erzeugen. Um Werte in anderen Intervallen zu erzeugen, können der Funktion eigene Intervallgrenzen übergeben werden.\nWerden uniformverteilte Zufallswerte gegenübergestellt, dann sind diese Werte gleichmässig im Intervall verteilt (Abbildung 8.1).\n\n\n\n\n\nAbbildung 8.1: Visualisierung von zwei Vektoren mit Zufallswerten\n\n\n\n\n\n\n\n\n\n\nMerke\n\n\n\nGanzzahlen dürfen nicht durch Runden , sondern müssen durch Entfernen des Nachkommaanteils mit trunc() erzeugt werden.\n\n\n\nBeispiel 8.9 (Zufällige Ganzzahlen in einem Intervall erzeugen)  \n\nrunif(10, min = -10, max = 10) |&gt; trunc()\n\n [1] -3  7 -9  9 -6 -5  9  7 -6 -6\n\n\n\nNeben den uniformverteilten Werten, stellt R Funktionen zum Erzeugen von Zufallswerten mit anderen Verteilungen an. Die Grundlage für diese Zufallswerte bilden die statistischen Verteilungen, wie z.B. die Normalverteilung (mit rnorm()), die F-Verteilung (mit rf()), die Binomialverteilung (mit rbinom()) oder die \\chi^2-Verteilung (mit rchisq()).\nIn diesen Verteilungen sind nicht alle Werte gleich wahrscheinlich. Dadurch erscheinen in einer Visualisierung die Werte geklumpt (Abbildung 8.2).\n\n\n\n\n\nAbbildung 8.2: Visualisierung von zwei Vektoren mit normalverteilten Zufallswerten\n\n\n\n\n\n\n\n\n\nAbbildung 8.3: Visualisierung von zwei Vektoren mit \\chi^2-verteilten Zufallswerten"
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#operatoren",
    "href": "kapitel/variablen/kapitel.html#operatoren",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.3 Operatoren",
    "text": "8.3 Operatoren\nAlle R-Operatoren sind Funktionen. R kennt 29 vordefinierte Operatoren, die zwei Werte verknüpfen. Zu diesen Operatoren gehören die auch die arithmetischen Operatoren für die Grundrechenarten.\n\n\nTabelle 8.1: Liste der Base R Operatoren\n\n\n\n\n\n\n\nOperator\nBeschreibung\nArt\n\n\n\n\n+\nPlus, sowohl unär als auch binär\narithmetisch\n\n\n-\nMinus, sowohl unär als auch binär\narithmetisch\n\n\n*\nMultiplikation, binär\narithmetisch\n\n\n/\nDivision, binär\narithmetisch\n\n\n^\nPotenz, binär\narithmetisch\n\n\n%%\nModulo, binär\narithmetisch\n\n\n%/%\nGanzzahldivision, binär\narithmetisch\n\n\n%*%\nMatrixprodukt, binär\narithmetisch, Matrix\n\n\n%o%\näusseres Produkt, binär\narithmetisch, Matrix\n\n\n%x%\nKronecker-Produkt, binär\narithmetisch, Matrix\n\n\n&lt;\nKleiner als, binär\nlogisch\n\n\n&gt;\nGrösser als, binär\nlogisch\n\n\n==\nGleich, binär\nlogisch\n\n\n!=\nUngleich, binär\nlogisch\n\n\n&gt;=\nGrösser oder gleich, binär\nlogisch\n\n\n&lt;=\nKleiner oder gleich, binär\nlogisch\n\n\n%in%\nExistenzoperator, binär\nlogisch\n\n\n!\nunäres Nicht\nlogisch\n\n\n&\nUnd, binär, vektorisiert\nlogisch\n\n\n&&\nUnd, binär, nicht vektorisiert\nlogisch\n\n\n|\nOder, binär, vektorisiert\nlogisch\n\n\n||\nOder, binär, nicht vektorisiert\nlogisch\n\n\n&lt;-, &lt;&lt;-, =\nlinksgerichtete Zuweisung, binär\nZuweisung\n\n\n-&gt;, -&gt;&gt;\nrechtsgerichtete Zuweisung, binär\nZuweisung\n\n\n[\nIndexzugriff (Vektoren), binär\nIndex\n\n\n$, [[\nListenzugriff, binär\nIndex\n\n\n~\nfunktionale Abhängigkeit, sowohl unär als auch binär\nFunktionen\n\n\n:\nSequenz (in Modellen: Interaktion), binär\nFunktionen\n\n\n|&gt;\nFunktionsverkettung\n\n\n\n?\nHilfe\nspezial\n\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nIm R-Umfeld wird oft von Modellen geschrieben und gesprochen. Modelle sind spezielle Funktionen, die Beziehungen zwischen Daten beschreiben, ohne eine mathematisch exakte Beziehung vorzugeben. Modelle werden in der Statistik und Stochastik eingesetzt, wenn die exakten Beziehungen zwischen Daten unbekannt sind.\n\n\n\nBeispiel 8.10 (Exakte lineare Beziehung zwischen Daten)  \nf = function (x, c) 2 * x + 3 * c\n\n\nBeispiel 8.11 (Beziehung zwischen Daten mit Interaktion als Modell)  \nf = y ~ x : c\n\nHinter jedem Operator steht eine Funktion, die mit den beiden Operanden als Parameter ausgeführt wird, um das Ergebnis des Operators zu bestimmen. Daraus folgt, dass jeder Operator auch als Funktionsbezeichner verwendet werden kann. In diesem Fall muss R mitgeteilt werden, dass der Operator nun als Funktionsbezeichner verwendet werden soll. Der Operator muss also mit Backticks als Bezeichner markiert werden.\n\nBeispiel 8.12 (+-Operator als Funktionsbezeichner)  \n\n`+`(1, 2)\n\n[1] 3\n\n\n\n\n8.3.1 Zuweisung\nR kennt zwei Zuweisungsoperatoren: &lt;- und -&gt;. Die Zuweisung erfolgt in Richtung des Pfeils. Daneben wird der =-Operator ebenfalls als (inoffizieller) Zuweisungsoperator unterstützt.\nEin Zuweisungsoperator erwartet immer einen Bezeichner und eine Operation als Parameter. Das Ergebnis der Operation wird als Wert dem Bezeichner zugewiesen.\nWeil nicht immer klar ist, ob &lt;- oder = verwendet werden soll, lautet die offizielle Kommunikation, dass für Variablenzuweisungen der &lt;--Operator verwendet werden sollte. Das einfache Gleich (=) weist einen Wert einem Funktionsparameter zu. Gerade in tidy R ist dieser Unterschied nur schwer nachvollziehbar, weil bestimmte Parameter wie Variablen behandelt werden.\n\n\n\n\n\n\nHinweis\n\n\n\nIn diesem Buch wird für die linksgerichtete Zuweisung immer das Gleichzeichen (=) verwendet, so dass eine Zuweisung eines Werts an eine Variable und an einen Parameter gleichwertig behandelt wird. Dadurch wird die Lesart etwas vereinfacht. Zusätzlich wird die rechtsgerichtete Zuweisung konsequent als Abschluss für einen primären Datenstrom (s. Kapitel 8.4) eingesetzt.\n\n\n\n\n8.3.2 Funktionsausführung\nDer Ausführenoperator (()) gilt in R offiziell nicht als Operator, weil dieser nicht als Funktion umgesetzt werden kann. Es gibt zwar die Funktion do.call(), um eine Funktion auszuführen. Wenn diese Funktion als Ausführungsoperator eingesetzt wird, müsste do.call() sich selbst aufrufen, um sich selbst auszuführen. Dieses Problem wird von R dadurch gelöst, dass ( und ) als eigene Symbole erkannt werden und immer eine Funktionsausführung anzeigen.\n\n8.3.2.1 Hilfeoperator\nDer Hilfeoperator ist ein besonderer Operator, weil dieser die Interaktion mit der Dokumentation von Funktionen und Konzepten ermöglicht. Der Hilfeoperator wird normalerweise nicht in einem R-Script verwendet und hat keine Bedeutung für die Datenverarbeitung.\nDer Hilfeoperator kann direkt mit einem Bezeichner aufgerufen werden. Existiert für den Bezeichner eine Dokumentation, dann wird diese angezeigt.\n\nBeispiel 8.13 (Dokumentation der Funktion is.character())  \n?is.character\n\nWird der Hilfeoperator mit sich selbst aufgerufen, wird der nächste Wert als Suchbegriff gewertete und eine Suche über alle Hilfedokumente auf dem System durchgeführt.\n\nBeispiel 8.14 (Dokumentationssuche nach Operatoren)  \n??operator"
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#sec-fkt-ketten",
    "href": "kapitel/variablen/kapitel.html#sec-fkt-ketten",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.4 Funktionsketten",
    "text": "8.4 Funktionsketten\nR unterstützt die spezielle Funktionsverkettung mit dem |&gt;- Operator. Dadurch lassen sich Funktionsfolgen direkt in R ausdrücken. In Kombination mit der rechtsgerichteten Zuweisung (-&gt;) ist es möglich, Datenströme durch eine Funktionskette von einem Ausgangswert zu einem Ergebnis in der natürlichen Reihenfolge aufzuschreiben.\n\nBeispiel 8.15 (Funktionskette mit abschliessender Zuweisung)  \n# library(tidyverse)\niris |&gt;\n    filter(Species == \"setosa\") |&gt;\n    arrange(desc(Petal.Length)) -&gt; \n        sortierteSetosaWerte\n\nNeben der speziellen Funktionsverkettung (|&gt;) gibt es einen sehr ähnlichen Verkettungsoperator: %&gt;%. Dieser Verkettungsoperator ist Teil der tidyverse-Bibliothek und gleicht der speziellen Funktionsverkettung mit dem kleinen Unterschied, dass die Parameterzuweisung für die nachfolgende Funktion zusätzliche Kontrollmöglichkeiten bietet, die der speziellen Funktionsverkettung fehlen."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#eigene-funktionen-erstellen",
    "href": "kapitel/variablen/kapitel.html#eigene-funktionen-erstellen",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.5 Eigene Funktionen erstellen",
    "text": "8.5 Eigene Funktionen erstellen\nIn R werden Funktionen mit dem function-Schlüsselwort erstellt. Eine R-Funktion besteht aus einer Parameterliste und einem Funktionskörper. Die Parameterliste wird in Klammern hinter dem Wort function angegeben. Der Funktionskörper kann eine einzelne Operation oder ein Block sein. Das Ergebnis einer Funktion ist das Ergebnis der letzten Operation des Funktionskörpers.\nBeispiel 8.16 zeigt eine Funktionsdeklaration, die einen parameter akzeptiert. Die Funktion quadriert diesen Wert und zieht vom Ergebnis 1 ab. An diesen Operationen wird erkannt, dass die Funktion nur Werte vom Datenyp Zahlen als parameter akzeptiert.\nParameter sind in R spezielle Variablen, mit denen Werte an eine Funktion übergeben werden. Parameter existieren nur innerhalb einer Funktion während der Ausführung des Funktionskörpers. Es kommt sehr häufig vor, dass ausserhalb einer Funktion Variablen mit gleichem Bezeichnern vorhanden sind. Ein Parameter überschreibt diese Variablen nicht.\n\nBeispiel 8.16 (Eine Funktion deklarieren)  \nfunction (parameter) {\n    parameter ^ 2 - 1\n}\n\nDamit eine Funktion sinnvoll verwendet werden kann, muss sie zuerst einer Variablen zugewiesen werden. Der Bezeichner einer Funktion sollte möglichst die zentrale Bedeutung einer Funktion beschreiben.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Wahl eines guten Funktionsbezeichners hängt vom jeweiligen Geltungsbereich ab.\nMathematische Funktionen werden oft mit f(x) oder g(x) usw. geschrieben. In R sind solche Bezeichner ebenfalls zulässig, solange sie eindeutig sind. Solche sehr kurzen Funktionsbezeichnern sollten speziell gekennzeichnet und dokumentiert werden.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nWeil das Schlüsselwort function recht lang ist, behindert es gelegentlich das Lesen sehr einfacher Funktionen. R erlaubt die Definition der Parameterliste mit \\() anstatt function () zu schreiben. Beide Schreibweisen sind gleichbedeutend.\nBeispiel 8.22 zeigt die Anwendung der Abkürzung mit \\().\nGrundsätzlich sollte das function-Schlüsselwort der Abkürzung vorgezogen werden, wenn eine Funktion einem Bezeichner zugewiesen wird.\n\n\nBeispiel 8.17 weist der Funktion aus Beispiel 8.16 den Bezeichner quadrat_minus_eins zu. Dieser Bezeichner kann anschliessend als Funktion verwendet werden (s. Beispiel 8.18).\n\nBeispiel 8.17 (Eine Funktion mit Bezeichner deklarieren)  \n\nquadrat_minus_eins = function (parameter) {\n    parameter ^ 2 - 1\n}\n\n\n\nBeispiel 8.18 (Eine selbstdeklarierte Funktion aufrufen)  \n\nquadrat_minus_eins(2)\n\n[1] 3\n\n\n\n\n8.5.1 Parameter und Variablen\nEin Parameter ist ein Platzhalter für einen Wert, der einer Funktion beim Funktionsaufruf übergeben wird. Parameter werden für eine spezielle Form der Variablenzuweisung eingesetzt.\nIm Funktionskörper verhält sich ein Parameter wie eine Variable. Einem Parameter können also in einem Funktionskörper neue Werte zugewiesen werden. Neben Parametern können Funktionskörper zusätzliche Variablen benötigen. Der Geltungsbereich dieser Variablen sind auf den Funktionskörper beschränkt.\n\n\n8.5.2 Datentypen überprüfen\nWird der neuen Funktion ein falscher Datentyp als Parameter übergeben, dann können die Rs Fehlermeldungen sehr verwirrend sein. Es ist daher ein guter Stil, Parameter die bestimmte Datentypen erfordern direkt zu Begin des Funktionskörpers zu prüfen (s. Beispiel 8.19).\n\nBeispiel 8.19 (Eine Funktion mit Typenprüfung deklarieren)  \nquadrat_minus_eins = function (parameter) {\n    stopifnot(is.numeric(parameter))\n    parameter ^ 2 - 1\n}\n\n\n\n8.5.3 Nebeneffekte\n\n\n\n\n\n\nWichtig\n\n\n\nNebeneffekte sind in (fast) immer unerwünscht. Die in diesem Abschnitt werden die beiden speziellen Zuweisungsoperatoren &lt;&lt;- und -&gt;&gt; vorgestellt, die gezielt Nebeneffekte erzeugen.\nDieser Abschnitt beschreibt einen Sonderfall der Variablen- oder Funktionsdeklaration in speziellen Closures (s.u.), der in R sehr selten vorkommt. Die meisten Algorithmen lassen sich nebeneffektsfrei Programmieren, weshalb die beiden speziellen Zuweisungsoperatoren normalerweise nicht verwendet werden.\n\n\nDer Funktionskörper bildet einen abgegrenzten Geltungsbereich für Variablen. Alle normalen Zuweisungen gelten nur für den Funktionskörper, selbst wenn eine Variable oder ein Parameter ursprünglich in einem äusseren Geltungsbereich deklariert wurde.\n\nBeispiel 8.20 (Geltungsbereich von Variablen in Funktionen)  \n\n# Deklarationen\nvar1 = 1\nf = function (x) {\n    var1 = x + var1\n    var1\n}\n\n# Anwendung\nf(2)\n\n[1] 3\n\nvar1\n\n[1] 1\n\n\n\nIn seltenen Fällen ist es notwendig, eine Variable eines äusseren Geltungsbereichs in einer Funktion einen neuen Wert zuzuweisen. Hier kommen die speziellen Zuweisungen &lt;&lt;- und -&gt;&gt; zum Einsatz. Wird anstelle einer normalen Zuweisung die spezielle Zuweisung verwendet, dann wird einer Variablen oder einem Parameter eines äusseren Geltungsbereich ein neuer Wert zugewiesen.\n\nDefinition 8.2 Ändert eine Funktion eine Variable eines äusseren Geltungsbereichs, dann ist diese Änderung ein Nebeneffekt der Funktion.\n\n\nBeispiel 8.21 (Funktion mit Nebeneffekt)  \n\n# Deklarationen\nvar1 = 1\nf = function (x) {\n    x + var1 -&gt;&gt; var1\n    var1\n}\n\n# Anwendung\nf(2)\n\n[1] 3\n\nvar1\n\n[1] 3\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nIn R sollten ausschliesslich Closures Nebeneffekte haben, wenn eine Closure eine Variable einer generierenden Funktion ändern muss. Dieser Fall tritt sehr selten ein!\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nVariablen mit globalem Geltungsbereich sollten nie durch Nebeneffekte geändert werden.\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nObjektorientierte Sprachen, wie Python oder Java, verwenden Nebeneffekte als zentrales Programmierprinzip.\nStreng-funktionale Sprachen, wie Excel, sind nebeneffektfrei."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#funktionen-als-werte",
    "href": "kapitel/variablen/kapitel.html#funktionen-als-werte",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.6 Funktionen als Werte",
    "text": "8.6 Funktionen als Werte\n\n\n\n\n\n\nMerke\n\n\n\nEine Funktion ist für R ein Wert wie eine Zahl oder eine Zeichenkette.\n\n\nIm Fall von Funktionen ist der Wert einer Funktion die Funktionsdeklaration. Entsprechend ist es möglich Funktionen zu überschreiben.\nWird nur der Bezeichner einer Funktion eingegeben, gibt R die Funktionsdefinition wie jeden anderen Wert direkt aus.\n\n8.6.1 Callbacks\nIn R werden am häufigsten Funktionen als Parameter an eine andere Funktion übergeben. Im Gegensatz zur Funktionsverkettung ist dabei die Funktion selbst und nicht ihr Ergebnis der Wert des Parameters. Eine Funktion höherer Ordnung implementiert oft den generischen Teil eines Algorithmus und delegiert dem Callback spezifische Aufgaben.\nEine typische Anwendung von Callbacks sind Schleifen. Zwar existieren in R die Schleifenkonzepte while, repeat und for, sie kommen in der Praxis jedoch nie zum Einsatz. Stattdessen kommen fast immer Funktionen höherer Ordnung zum Einsatz. Die Schleife wird durch die Funktion höherer Ordnung realisiert. Der Schleifenblock wird als Callback umgesetzt.\n\n\n\n\n\n\nHinweis\n\n\n\nWeil R eine vektorbasierte Programmiersprache ist, werden die meisten Operationen automatisch für alle Elemente eines Vektors ausgeführt. Dadurch sind viele Schleifen unnötig, die in anderen Programmiersprachen erforderlich sind.\n\n\nDie Funktionen der Bibliothek purrr oder deren Schwesterbibliothek furrr sind der einfachste Weg in R, um das Verhalten von Schleifen funktional umzusetzten. Dabei sind zwei Funktionen zentral:\n\nmap() für Operationen, die für jedes Element unabhängig ausgeführt werden können. Diese Operationen sind immer Transformationen. Die Funktion hat immer eine Liste als Ergebnis. Falls ein Vektor benötigt wird, kann dieser durch eine Verkettung mit unlist() oder mit der Funktion map_vec() erzeugt werden (s. Beispiel 8.22).\nreduce() für Operationen, die ein oder mehrere Elemente gemeinsam berücksichtigen. Diese Operationen sind meistens Aggregationen. (s. Beispiel 8.23)\n\n\nBeispiel 8.22 (Lineartransformation mit map())  \n\nmap(rbinom(10, 7, .5), \\(x) x - 4) |&gt; unlist()\n\n [1] -1  0  1 -1 -2  1  0  1  1  2\n\n# Alternativ\nmap_vec(rbinom(10, 7, .5), \\(x) x - 4)\n\n [1]  2  0  1 -3  0  2 -2  0 -1 -1\n\n\n\n\nBeispiel 8.23 (Berechnung des n-ten Werts der Fibonacci-Reihe mit reduce())  \n\nn = 6\n\nfib_add = function (a, b) c(a[2], a[1] + a[2])\n\nreduce(seq(2, len = n-1), fib_add, .init = c(0,1))[2]\n\n[1] 8\n\n\n\n\n\n8.6.2 Closures\nClosures sind Funktionen, die von anderen Funktionen erzeugt und als Ergebnis zurückgegeben werden. Eine Closure bleibt mit der Ausführung der erzeugenden Funktion auch nach Rückgabe verbunden. Dadurch ergeben sich Anwendungen, mit denen sich Funktionsaufrufe vereinfachen lassen.\n\nBeispiel 8.24 (Closure zum systematischen Quadrieren oder Kubieren)  \n\npotenz_factory = function(e) function (x) x ^ e\n\nquadrieren = potenz_factory(2)\nkubieren = potenz_factory(3)\n\nquadrieren(c(2, 3, 4))\n\n[1]  4  9 16\n\nkubieren(c(1, 2, 3))\n\n[1]  1  8 27\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nClosures werden in R meistens in Verbindung mit Callbacks verwendet. Die generierende Funktion konfiguriert die Callbacks mit ihren Parametern, so dass diese in den Callbacks verwendet werden können. Ein solches Vorgehen ist immer dann sinnvoll, wenn sehr ähnliche Logik in mehreren Callbacks vorkommt und abstrahiert werden kann.\n\n\n\nBeispiel 8.25 (Closure mit Callback verbinden)  \n\npotenz_reduzierer = function(e) function (p, x) p + x ^ e\n\nreduce(c(1,2,3), potenz_reduzierer(1)) # Summe \n\n[1] 6\n\nreduce(c(1,2,3), potenz_reduzierer(2)) # Quadrat-Summe\n\n[1] 14\n\nreduce(c(1,2,3), potenz_reduzierer(3)) # Kubik-Summe\n\n[1] 36"
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#bibliotheken",
    "href": "kapitel/variablen/kapitel.html#bibliotheken",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.7 Bibliotheken",
    "text": "8.7 Bibliotheken\nOft ist es nicht notwendig eigene Funktionen zu erstellen. Stattdessen kann in vielen Fällen auf Funktionsbibliotheken zurückgegriffen werden, die bereits entsprechende Funktionen bereitstellen.\nR wird durch Funktionsbibliotheken erweitert. Eine Funktionsbibliothek stellt hauptsächlich Funktionen und Operationen für bestimme Algorithmen oder Analysemethoden bereit. Eine Funktionsbibliothek wird mit der Funktion install.packages() auf einem Rechner installiert.\nIn einem R-Script lassen sich die Funktionen einer Bibliothek auf zwei Arten nutzen:\n\nDie Bibliothek wird mithilfe der Funktion library() in den Code eingebunden.\nEine Funktion einer Bibliothek wird direkt angesprochen.\n\nDie erste Option bietet sich an, wenn ein Script viele Funktionen einer Bibliothek aufrufen wird. R läd in diesem Fall alle Funktionen der Bibliothek, so dass diese direkt verwendet werden können.\n\nBeispiel 8.26 (Funktionen mit der library() Funktion einbinden)  \n\nlibrary(tidyverse)\n\nmtcars |&gt; \n    ggplot(aes(mpg, hp)) +\n        geom_point()\n\n\n\n\n\nDie zweite Option ist sinnvoll, wenn nur eine oder zwei Funktionen einer Bibliothek verwendet werden sollen. In diesem Fall muss R nicht die gesamte Bibliothek bereitstellen, sondern läd gezielt nur die gewünschten Funktionen.\n\nBeispiel 8.27 (Eine Funktion direkt ansprechen)  \n\nmtcars |&gt; \n    dplyr::filter(hp &gt; 200)\n\n                     mpg cyl disp  hp drat    wt  qsec vs am gear carb\nDuster 360          14.3   8  360 245 3.21 3.570 15.84  0  0    3    4\nCadillac Fleetwood  10.4   8  472 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8  440 230 3.23 5.345 17.42  0  0    3    4\nCamaro Z28          13.3   8  350 245 3.73 3.840 15.41  0  0    3    4\nFord Pantera L      15.8   8  351 264 4.22 3.170 14.50  0  1    5    4\nMaserati Bora       15.0   8  301 335 3.54 3.570 14.60  0  1    5    8\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nR bietet sog. Meta-Bibliotheken an, mit denen mehrere Bibliotheken gemeinsam verwendet werden können. Funktionen können nur nicht über den Namen einer Meta-Bibliothek, sondern immer nur über die Bibliothek, die einer Funktion definiert.\n\n\nDie tidyverse-Bibliothek ist eine solche Meta-Bibliothek. Beispiel 8.28 zeigt wie die Funktion read_csv() direkt angesprochen werden kann, wenn die tidyverse-Bibliotheken nicht mit library(tidyverse) eingebunden wurden. read_csv() wird in der Bibliothek readr definiert. Entsprechend kann die Funktion nur über readr::read_csv() aufgerufen werden.\n\nBeispiel 8.28 (Funktion aus Unterbibliothek direkt ansprechen)  \nreadr::read_csv(\"meine_daten.csv\")\n# entspricht:\n#   library(tidyverse)\n#   read_csv(\"meine_daten.csv\")\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie Syntax von R kann durch Module erweitert werden. Diese Form nutzt die Konzepte zur Metaprogrammierung von R. Dadurch können neue Programmierkonzepte in die Sprache einfliessen. Die tidyverse-Bibliotheken nutzen diese Möglichkeit intensiv. Solche Bibliotheken müssen mit der Funktion library() eingebunden werden, damit die zusätzliche Syntax bereitgestellt wird."
  },
  {
    "objectID": "kapitel/variablen/kapitel.html#bibliotheken-verwalten",
    "href": "kapitel/variablen/kapitel.html#bibliotheken-verwalten",
    "title": "8  Variablen, Funktionen und Operatoren",
    "section": "8.8 Bibliotheken verwalten",
    "text": "8.8 Bibliotheken verwalten\nVerwendet ein R-Script Funktionsbibliotheken, dann ist dieses Script nur auf Rechnern lauffähig, auf denen die benutzten Bibliotheken auch installiert sind. Solche notewendigen Bibliotheken heissen die Abhängigkeiten (engl. dependencies) eines Scripts. Weil sich die Abhängikeiten nicht immer leicht erkennen lassen, müssen alle Abhängigkeiten müssen dokumentiert werden.\n\n\n\n\n\n\nPraxis\n\n\n\nIm Internet gibt es sehr viele Beispiele, die die Funktion install.packages() als Teil des Programmcodes darstellen. In konkreten R-Projekten sollte die Funktion install.packages() nie in einem normalen R-Script aufgerufen werden, weil bei jedem Start des Script geprüft wird, ob eine neue Version der Bibliothek existiert. Diese Technik stellt ein Sicherheitsrisiko dar, weil bei jeder Ausführung des Scripts Installationen unkontrolliert vorgenommen werden können und Schadcode auf die Systeme geschleust werden kann.\nDas Risiko unkontrollierter Installationen wird verringert, indem Installationen von der Programmlogik getrennt und nur kontrolliert durchgeführt werden. Dadurch wird die Installation von Funktionsbibliotheken von ihrer Anwendung getrennt.\n\n\nDie Dokumentation von Abhängigkeiten wird normalerweise von einem sog. Packetmanagement übernommen. R verfügt über kein integriertes Packetmanagement. Dieses wird von der Bibliothek renv übernommen. Bevor dieses genutzt werden kann muss renv mit install.packages(\"renv\") installiert werden.\n\n\n\n\n\n\nPraxis\n\n\n\nrenv sollte bei der Installation von R gleich mitinstalliert werden.\n\n\nrenv ist ein Packetmanagementsystem für R. Anders als die Funktion install.packages() installiert renv nicht nur Bibliotheken, sondern dokumentiert auch die Abhängigkeiten eines Projekts in einer Form, dass alle Abhängigkeiten einfach auf dem System installiert werden können. Mit renv::restore() lässt sich ein Projekt in einer anderen Umgebung mit allen Abhängigkeiten konfigurieren und ausführen.\nWird eine Bibliothek mit renv installiert, dann steht diese Bibliothek nur dem jeweiligen Projekt zur Verfügung. Was auf dem ersten Blick als Nachteil klingt, ist ein grosser Vorteil, wenn unterschiedliche Projekte besonderen Anforderungen an die Versionen einer Bibliothek haben. Auf diese Weise kann jedes Projekt die richtige Version einer Bibliothek verwenden und beeinflusst keine anderen Projekte.\n\n8.8.1 Projektvorbereitung\nEin Projekt wird mit renv::init() für die Verwendung des Packetmanagements vorbereitet. Beim ersten Aufruf von renv werden die internen Abhängigkeiten von renv kontrolliert und notfalls installiert. Das nimmt etwas Zeit in Anspruch.\nDas Packetmanagement erfasst automatisch alle Bibliotheken, die systemweit installiert wurden. Dadurch wird sichergestellt, dass alle Bibliotheken berücksichtigt wurden, die im eigenen System installiert sind und deshalb auch im Projekt verwendet werden können. Die Einzige Ausnahme davon ist renv selbst.\n\n\n8.8.2 Bibliotheken installieren\nNach der Initialisierung des Packetmanagements können projektspezifische Bibliotheken mit renv::install() installiert werden. War eine Installation erfolgreich, sollte die Bibliothek auf ihre Funktionstüchtigkeit mit einem einfachen Beispiel geprüft und danach mit renv::snapshot() als Abhängigkeit dokumentiert werden. Mit einem Snapshot wird eine Bibliotheksversion als Abhängigkeit registiert. Im Gegensatz zu install.packages() wird ab diesem Zeitpunkt nicht mehr eine beliebige Version der Bibliothek installiert, sondern nur die dokumentierte Version. Dadurch wird sichergestellt, dass der Code auch in anderen Umgebungen wie erwartet funktioniert.\n\n\n8.8.3 Bibliotheken updaten\nEine Besonderheit von renv ist die Möglichkeit, kontrollierte Updates für einzelne oder alle Abhängigkeiten eines Projekts mit renv::update() durchzuführen. renv::update() installiert die neusten Versionen der Projektbibliotheken.\n\n\n\n\n\n\nMerke\n\n\n\nUpdates sollten nie unklontrolliert akzeptiert werden!\n\n\nBevor neue Bibliotheksversionen in das Packetmanagement aufgenommen werden, sollte immer geprüft werden, ob der bestehende Code mit den neuen Versionen immer noch funktioniert. Sollten bei dieser Prüfung Probleme auftreten, dann können die Updates mit renv::revert() wieder rückgängig gemacht werden. Gab es keine Probleme, dann können die Updates mit renv::snapshot() übernommen werden."
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#einzelne-symbole-aus-einer-zeichenkette-extrahieren",
    "href": "kapitel/zeichenketten/kapitel.html#einzelne-symbole-aus-einer-zeichenkette-extrahieren",
    "title": "9  Zeichenketten",
    "section": "9.1 Einzelne Symbole aus einer Zeichenkette extrahieren",
    "text": "9.1 Einzelne Symbole aus einer Zeichenkette extrahieren\nIn R lassen sich die einzelnen Symbole einer Zeichenkette mit der Operation zeichenkette |&gt; str_extract(\"\") extrahieren.\n\n\n\n\n\n\nWarnung\n\n\n\nWenn Sie die Zeichenketten in einem Zeichenkettenvektor in die einzelnen Symbole zerlegen möchten, dann erhalten Sie für jede Zeichenkette einen eigenen Vektor, der die Symbole der Zeichenkette enthält. R kann diese Vektoren nicht einfach zu einem grossen Vektor zusammensetzen. Daher werden die Ergebnisse als Listen geschützt und zu einem Ergebnisvektor zusammengefasst.\nIn einem zweiten Schritt können die extrahierten Symbole mit unnest() in der Stichprobe erweitert werden.\n\n\n\nBeispiel 9.1 (Zeichenkettenvektor in die einzelnen Symbole zerlegen)  \ntibble(zeichenkette = c(\"Daten\", \"und\", \"Information\")) |&gt; \n    mutate(\n        symbol = zeichenkette |&gt; str_extract_all(\"\") \n    ) |&gt; \n    unnest(symbol)\n\n\n\nzeichenkette &lt;chr&gt;\nsymbol &lt;chr&gt;\n\n\n\n\nDaten\nD\n\n\nDaten\na\n\n\nDaten\nt\n\n\nDaten\ne\n\n\nDaten\nn\n\n\nund\nu\n\n\nund\nn\n\n\nund\nd\n\n\nInformation\nI\n\n\nInformation\nn\n\n\nInformation\nf\n\n\nInformation\no\n\n\nInformation\nr\n\n\nInformation\nm\n\n\nInformation\na\n\n\nInformation\nt\n\n\nInformation\ni\n\n\nInformation\no\n\n\nInformation\nn\n\n\n\n\nBei solchen Operationen sollten Sie die Quelldaten nicht überschreiben. Erstellen Sie immer einen neuen Vektor für extrahierte Symbole und Zeichenketten. So bleibt der Bezug zu den ursprünglichen Werten erhalten."
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#nicht-druckbare-zeichen",
    "href": "kapitel/zeichenketten/kapitel.html#nicht-druckbare-zeichen",
    "title": "9  Zeichenketten",
    "section": "9.2 Nicht-druckbare Zeichen",
    "text": "9.2 Nicht-druckbare Zeichen\n\nDefinition 9.1 Als nicht-druckbare Zeichen werden Symbole bezeichnet, die bei der Darstellung einer Zeichenkette nicht angezeigt werden. Die nicht-druckbaren Zeichen zählen zur Länge einer Zeichenkette und verändern den Inhalt einer Zeichenkette.\n\nBeispiel: Die Zeichenkette Hallo unterscheidet sich von der Zeichenkette Hal&lt;0x08&gt;lo.\nExcel und R behandeln nicht-druckbare Zeichen unterschiedlich. In Excel werden die nicht-druckbaren Zeichen für die Darstellung und für Vergleiche entfernt, jedoch werden die nicht-druckbaren Zeichen bei der Länge und beim Extrahieren berücksichtigt. In R werden nicht-druckbare Zeichen bei der Darstellung und bei Vergleichen berücksichtigt. In Excel können wir mit der IDENTISCH()-Funktion zwei Zeichenketten nach den gleichen Regeln wie in R vergleichen.\nZu den nicht-druckbaren Zeichen gehören auch Leerzeichen, Tabulatoren und Zeilenumbrüche. Wir können diese speziellen nicht-druckbaren Zeichen nur erkennen, wenn sie von druckbaren Zeichen umgeben sind.\nDeutlich wird das an den folgenden Zeichenketten:\n\nHallo\nHal&lt;0x07&gt;lo, wobei das Symbol 0x07 für einen Piepton steht\nHal&lt;0x08&gt;lo, wobei das Symbol 0x08 für einmal Rückwärtslöschen steht.\n\nDiese drei Zeichenketten haben in Excel und R die Längen 5, 6 und 6. Excel stellt alle drei Zeichenketten als “Hallo” dar. Ausserdem werden die Zeichenketten als gleich ausgewertet. R wertet die Zeichenketten aus und stellt nicht-druckbare Zeichen prinzipiell als ein Leerzeichen dar. Das Symbol 0x08 wird von R ausgewertet und deshalb wird das vorangehende Symbol gelöscht. Entsprechend wird in unserem Fall Halo angezeigt. Ebenfalls werden alle drei Zeichenketten in R als ungleich ausgewertet."
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#die-leere-zeichenkette",
    "href": "kapitel/zeichenketten/kapitel.html#die-leere-zeichenkette",
    "title": "9  Zeichenketten",
    "section": "9.3 Die leere Zeichenkette",
    "text": "9.3 Die leere Zeichenkette\nEin besonderer Fall ist die leere Zeichenkette. Die leere Zeichenkette wird oft als Platzhalter genutzt. Die leere Zeichenkette ist das neutrale Element für die Verknüpfung von Zeichenketten.\nDie leere Zeichenkette wird in R immer durch doppelte Anführungszeichen eingerahmt. Soll eine leere Zeichenkette als Wert in einer Zelle eingegeben werden, dann ist ein einfacher Apostroph (`) einzugeben.\n\n\n\n\n\n\nHinweis\n\n\n\nIn R dürfen Sie optional auch einfache Anführungszeichen als alternative Zeichenkettenmarkierungen verwenden. Weil das einfache Anführungszeichen (’) und der Backtick (`) sehr ähnlich aussehen aber eine andere Bedeutung haben, sollte nur das doppelte Anführungszeichen (\") in R verwendet werden.\n\n\n\nBeispiel 9.2 (Die leere Zeichenkette)  \nleereZeichenkette = \"\"\n\n\n9.3.1 Schreibweise ändern"
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#zeichenketten-trennen",
    "href": "kapitel/zeichenketten/kapitel.html#zeichenketten-trennen",
    "title": "9  Zeichenketten",
    "section": "9.4 Zeichenketten trennen",
    "text": "9.4 Zeichenketten trennen\nIn R gibt es verschiedene Funktionen, die aus einem Wert mehrere Werte erzeugen. Das gilt insbesondere für die Zeichenkettenfunktionen. In diesem Zusammenhang nimmt die Funktion str_split() eine besondere Position ein, weil sie relativ oft gebraucht wird. Diese Funktion trennt eine Zeichenkette entlang eines Trennzeichens bzw. eines Trennmusters und gibt die Ergebniswerte zurück.\n\n\n\n\n\n\nHinweis\n\n\n\nWir können uns die Funktion str_split() als eine flexiblere Variante von Excels “Text in Spalten”-Befehl vorstellen. Die Parameter für diese Funktion sind eine Zeichenkette sowie das Trennmuster. Das Ergebnis ist ein Vektor aus Zeichenketten.\n\n\nNatürlich wäre es toll, wenn wir str_split() zum Umformen einer Stichprobe verwenden könnten. Allerdings führt das Ergebnis zu Listenvektoren, mit denen wir nicht leicht arbeiten können. Das illustriert das folgende Beispiel. In diesem Beispiel trennen wir die Zeichenketten im Vektor text an den Leerzeichen, sodass wir einzelne Worte erhalten.\n\nBeispiel 9.3 (Zeichenketten mit str_split() trennen)  \nlibrary(tidyverse)\n\ntexte = tibble(text = c(\"Daten und Information\", \"Klimatologie Informatik\"))\n\ntexte |&gt; \n    mutate(\n        getrennter_text = text |&gt; str_split(\" \")\n    )\n\n\n\ntext  &lt;chr&gt;\ngetrennter_text &lt;list&gt;\n\n\n\n\nDaten und Information\nDaten, und, Information\n\n\nKlimatologie Informatik\nKlimatologie, Informatik\n\n\n\n\nIm Vektor getrennter_text stehen nun Listen mit unterschiedlicher Länge. Wären diese Listen Vektoren, dann könnten wir mit der Funktion pivot_longer() die Werte transponieren. Das funktioniert mit eingebetteten Listen leider nicht, weil die Werte nicht über mehrere Vektoren verteilt sind, sondern alle im gleichen Vektor stehen.\n\nDefinition 9.2 Enthält ein Vektor Listen mit Werten, dann werden die Listenwerte als eingebettete (engl. nested) Werte bezeichnet.\n\nUm an eingebettete Werte zu gelangen, müssen wir sie zuerst “ausbetten”. Dazu verwenden wir die Funktion unnest(). Mit dieser Funktion werden eingebette Listen in einen Vektor entpackt.\n\nBeispiel 9.4 (Entpacken von getrennten Zeichenketten mit unnest())  \ntexte |&gt; \n    mutate(\n        getrennter_text = text |&gt; str_split(\" \")\n    ) |&gt; \n    unnest(getrennter_text) -&gt; texte_getrennt\n\ntexte_getrennt\n\n\n\ntext  &lt;chr&gt;\ngetrennter_text &lt;chr&gt;\n\n\n\n\nDaten und Information\nDaten\n\n\nDaten und Information\nund\n\n\nDaten und Information\nInformation\n\n\nKlimatologie Informatik\nKlimatologie\n\n\nKlimatologie Informatik\nInformatik\n\n\n\n\nBeachten Sie hier, dass alle nicht aufgelösten Vektoren für jeden Listeneintrag erweitert werden.\nJetzt können wir mit diesen Werten wie gewohnt weiterarbeiten.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Umkehrfunktion von unnest() ist die Funktion nest(). Beide Funktionen werden ausführlich in Kapitel 16 behandelt.\n\n\nDas Beispiel 9.4 können wir mit der folgenden Operation zurück in die Listenform bringen. Dabei beachten wir, dass wir den neuen Vektor benennen und diesem die Werte aus dem Ursprungsvektor übergeben müssen.\n\nBeispiel 9.5 (Zeichenketten einbetten)  \ntexte_getrennt |&gt; \n    nest(getrennter_text = getrennter_text)\n\n\n\ntext  &lt;chr&gt;\ngetrennter_text &lt;list&gt;\n\n\n\n\nDaten und Information\nDaten, und, Information\n\n\nKlimatologie Informatik\nKlimatologie, Informatik"
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#teilzeichenketten-extrahieren",
    "href": "kapitel/zeichenketten/kapitel.html#teilzeichenketten-extrahieren",
    "title": "9  Zeichenketten",
    "section": "9.5 Teilzeichenketten extrahieren",
    "text": "9.5 Teilzeichenketten extrahieren"
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#suchen-und-ersetzen",
    "href": "kapitel/zeichenketten/kapitel.html#suchen-und-ersetzen",
    "title": "9  Zeichenketten",
    "section": "9.6 Suchen und Ersetzen",
    "text": "9.6 Suchen und Ersetzen\n\n9.6.1 Position einer Teilzeichenkette finden\n\n\n9.6.2 Teilzeichenketten austauschen"
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#mustererkennung",
    "href": "kapitel/zeichenketten/kapitel.html#mustererkennung",
    "title": "9  Zeichenketten",
    "section": "9.7 Mustererkennung",
    "text": "9.7 Mustererkennung\n\nDefinition 9.3 Reguläre Ausdrücke sind Zeichenketten, mit denen komplexe Suchmuster für Zeichenketten beschrieben werden.\n\nEin regulärer Ausdruck beschreibt die Struktur einer gesuchten Zeichenkette. Reguläre Ausdrücke sind eine Standardtechnik zum Suchen-und-Ersetzen.\nR verfügt mit regulären Ausdrücken über eine leistungsfähige Mustererkennung für Zeichenketten. Diese Mustererkennung steuern wir über reguläre Ausdrücke(Vignette regex) oder Regulärausdruck (Sauer, 2019). Reguläre Ausdrücke erlauben es, Muster in Zeichenketten zu finden und diese Muster durch etwas anderes auszutauschen. In R schreiben wir reguläre Ausdrücke als Zeichenketten mit einer besonderen Musterbeschreibungssprache. Wir können an viele Zeichenkettenfunktionen solche regulären Ausdrücke als Parameter übergeben.\nDie wichtigsten Symbole zur Musterbeschreibung mit regulären Ausdrücken sind die folgenden Symbole und Symbolkombinationen:\n\n. - beschreibt das Vorkommen eines beliebigen Symbols\n\\s - beschreibt alle Symbole die als Leerzeichen gelten\n\\d - beschreibt alle Ziffern\n\\w - beschreibt alle Buchstaben unabhängig von der Gross- und Kleinschreibung\n* - beschreibt das Auftreten von Sequenzen von 0 oder mehreren der voranstehenden Symbole\n+ - beschreibt das Auftreten von Sequenzen von 1 oder mehreren der voranstehenden Symbole\n? - beschreibt das Auftreten von Sequenzen von 0 oder 1 des voranstehenden Symbols\n{} - beschreibt das Auftreten von Sequenzen der angegebenen Länge des voranstehenden Symbols\n^ - steht für den Anfang der Zeichenkette\n$ - steht für das Ende der Zeichenkette\n[] - “Symbolbereich”: Die Symbole zwischen den beiden Klammern beschreiben die möglichen Symbole an der Position in der Zeichenkette\n() - Gruppiert eine Teilzeichenkette\n\n\n9.7.1 Normale Zeichen in Mustern\nNormale Buchstaben oder Ziffern haben keine besondere Bedeutung und bedeuten, dass an der entsprechenden Stelle das jeweilige Symbol vorkommen muss.\nzeichenkettenVektor = c( \"Daten und Information\", \"Datenverarbeitung\", \"Informatik\", \"Daten Information\", \"Computation Daten Informatik\" )\n\n# der reguläre Ausdruck wäre eigentlich \"\\w\\s\\w\" die zusätzlichen Backslashs \n# zeigen R an, dass wir den Backslash in unserem Muster haben möchten.\n\nregulaererAusdruck = \"Daten In\"\n\nzeichenkettenVektor |&gt; str_detect(regulaererAusdruck) \n# erzeugt c(FALSE FALSE FALSE TRUE TRUE)\n\n\n9.7.2 Mustersymbole in R verwenden\nWenn wir ein Symbol in unserem Muster aufnehmen wollen, das normalerweise ein besonderes Symbol für reguläre Ausdrücke ist, dann müssen wir diesem Symbol einen Backslash voranstellen. Dieses Voranstellen wird als “Escaping” bezeichnet. Weil R reguläre Ausdrücke als Zeichenketten behandelt, müssen wir aufpassen, denn der Backslash ist auch ein reserviertes Symbol in Zeichenketten. Deshalb ist der zweite Backslash notwendig, um den ersten Backslash vor der Zeichenketteninterpretation zu schützen.\nzeichenkette = \"Daten und Information\"\n\n# der reguläre Ausdruck wäre eigentlich \"\\w\\s\\w\" die zusätzlichen Backslashs \n# zeigen R an, dass wir den Backslash in unserem Muster haben möchten.\n\nregulaererAusdruck = \"\\\\w\\\\s\\\\w\"\n\nzeichenkette |&gt; str_replace(regulaererAusdruck, \"p x\") # erzeugt \"Datep xnd Information\"\n\n# Hinweis, um alle Vorkommnisse des Musters auszutauschen, müssen wir \n# str_replace_all() verwenden!\n\n\n9.7.3 Multiplikatoren\nDie Symbole *, +, ? und {} werden als Multiplikatoren bezeichnet. So können Wiederholungen in Mustern abgebildet werden.\nMit diesen Elementen können wir Zeichenketten beschreiben, ohne die genaue Abfolge der Symbole zu kennen.\nBeispiele:\n\"ab\"       # erkennt ab\n\"a?b\"      # erkennt b und ab\n\"a*b\"      # erkennt b, ab, aab, aaab, aaaab usw. \n\"a+b\"      # erkennt ab, aab, aaab, aaaab usw. \n\"a{2}b\"    # erkennt aab\n\"a{2,4}b\"  # erkennt aab, aaab und aaaab\n\"a.b\"      # erkennt aab, acb, adb, a3b, a-b usw. \n\"a.*b\"     # erkennt ab, acb, acdb, a-!%b usw. \n\n\"a\\\\sb\"    # erkennt \"a b\" oder \"a     b\" (Achtung doppelter Backslash!)\n\"\\\\w\\\\d\"   # erkennt einen Buchstaben, der von einer Ziffer gefolgt wird  (Achtung doppelter Backslash!)\n\"a[cd]?b\"  # erkennt ab, acb und adb\n\n\"ab$\"      # erkennt ab nur am Ende der Zeichenkette\n\"^ab\"      # erkennt ab nur am Anfang der Zeichenkette\nGelegentlich wollen wir ein Muster bis zu einem bestimmten Symbol in unserer Zeichenkette finden. In diesem Fall können wir einen negierten Symbolbereich angeben.\n\n\nBeispiel 9.6 Gegeben ist die folgende Zeichenkette:\naquaponics = \"\n   The term aquaponics [7] is coined by combining \n    two words: aquaculture, which refers to fish \n    farming, and hydroponics—the technique of growing \n    plants without soil.[16]\"\nWir möchten nun die Zeichenkette ab dem Wort term und der öffnenden eckigen Klammer der Referenz markieren. D.h. wir wollen nicht ein beliebiges Zeichen und wollen nicht alle Symbole bis auf die öffnende Klammer explizit ausschliessen. Stattdessen können wir einen negierten Symbolbereich angeben. In unserem Fall erlauben wir jedes Zeichen, ausser die öffnende eckige Klammer. Weil die eckige Klammer eine besondere Bedeutung für reguläre Ausdrücke hat, müssen wir sie entsprechend mit Backslash “escapen”. Unser regulärer Ausdruck muss entsprechend \"termn [^\\\\[]+\\\\[\". Der Teil [^\\\\[]+ bedeutet dabei, “alle Symbole ausser der öffnenden eckigen Klammer [”. Die beiden Backslashes sind dabei die notwendige Escape-Sequenz, um die Klammer vom Symbolbereich zu unterscheiden.\nDer folgende Code demonstriert diesen regulären Ausdruck.\naquaponics |&gt;\n    str_match(\"term [^\\\\[]+\\\\[\")\n\n\nDas Ergebnis eines regulären Ausdrucks ist normalerweise immer nur der erste Treffer.\n\"term aquaponics [\"\nUm alle Treffer eines Musters zu erhalten, muss für die entsprechende _all-Variante der Funktion verwendet werden. Die folgenden Funktionen haben eine solche Funktionsvariante:\n\n\n\n\n\n\n\n\nBedeutung\nErster Treffer\nAlle Treffer\n\n\n\n\nFinde und extrahiere ein Suchmuster\nstr_extract()\nstr_extract_all()\n\n\nFinde ein Suchmuster und gebe die Zeichenkette zurück\nstr_match()\nstr_match_all()\n\n\nFinde ein Suchmuster und gebe die Position des Treffers zurück\nstr_locate()\nstr_locate_all()\n\n\nFinde und lösche ein Suchmuster\nstr_remove()\nstr_remove_all()\n\n\nFinde ein Suchmuster und ersetze den Treffer durch eine andere Zeichenkette\nstr_replace()\nstr_replace_all()\n\n\nZeige Suchtreffer für ein Suchmuster an\nstr_view()\nstr_view_all()"
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#tokens",
    "href": "kapitel/zeichenketten/kapitel.html#tokens",
    "title": "9  Zeichenketten",
    "section": "9.8 Tokens",
    "text": "9.8 Tokens\nDie Bibliothek tidytext stellt viele hilfreiche Funktionen zur quantitativen Textanalyse bereit. Beim Tokenisieren müssen verschiedene Regeln beachtet werden, damit das richtige Ergebnis erzeugt wird. Diese Regeln müssen wir zum Glück nicht im Detail kennen. Die Bibliothek tidytext stellt uns die Funktion unnest_tokens() sowie ein paar Hilfsfunktionen bereit. Mit diesen Funktionen können wir Texte leicht in Tokens zerlegen.\n\nlibrary(tidyverse)\nlibrary(tidytext)\n\ntibble(\n    rohtext = read_file(\"text/marketing_4.txt\")\n) -&gt; Rohdaten \nHier fällt uns eine neue Funktion auf: read_file(). Mit dieser Funktion können beliebige Textdateien eingelesen werden. R versucht bei dieser Funktion nicht, strukturierte Daten zu finden. Stattdessen wird der gesamte Inhalt der Datei als Zeichenkette zurückgegeben.\nNun können wir die Daten mit Hilfe von unnest_tokens() in Tokens zerlegen. Die Funktion unnest_tokens() funktioniert analog zu str_split() gefolgt von unnest(). Sie erleichtert diese Funktionsfolge, indem sie nicht nur Leerzeichen, sondern auch alle anderen Symbole und Satzzeichen, die keine Worte darstellen aus der ursprünglichen Zeichenkette entfernt.\nRohdaten |&gt; \n    unnest_tokens(worte, rohtext)  |&gt; \n    head()\n\n\n\nworte&lt;chr&gt;\n\n\n\n\nneues\n\n\nlehrbuch\n\n\nfür\n\n\nmodernes\n\n\nmarketing\n\n\nmarketing\n\n\n\nIn diesem Beispiel sehen wir die grundsätzliche Arbeitsweise der Funktion. Wir übergeben ein Stichprobenobjekt der Funktion über die Funktionsverkettung. Anschliessend übergeben wir der Funktion als ersten Parameter den Namen des Zielvektors (hier: worte) und als zweiten Parameter den Namen des Quellvektors (hier rohtext). Alle Texte im Vektor rohtext werden durch die Funktion in Worte zerlegt und anschliessend konsequent in die Kleinschreibung überführt. Abschliessend wird der ursprüngliche Vektor rohtext aus der Ergebnisstichprobe entfernt.\n\n9.8.1 Deutsche Gross- und Kleinschreibung\nWährend die Gross- und Kleinschreibung im Englischen (mit Ausnahme von Eigennamen) nicht signifikant ist, haben deutsche Worte in Gross- und Kleinschreibung eine andere inhaltliche Bedeutung. Falls diese Bedeutung erhalten bleiben soll, kann der optionale Parameter to_lower = FALSE übergeben werden. Der Code ändert sich dann wie folgt:\nRohdaten |&gt; \n    unnest_tokens(worte, rohtext, to_lower = FALSE)  |&gt; \n    head()\n\n\n\nworte&lt;chr&gt;\n\n\n\n\nNeues\n\n\nLehrbuch\n\n\nfür\n\n\nmodernes\n\n\nMarketing\n\n\nMarketing\n\n\n\n\n\n9.8.2 Texte in Sätze zerlegen\nWenn wir Texte in Sätze zerlegen wollen, dann verwenden wir die Funktion unnest_sentences().\nRohdaten |&gt; \n    unnest_sentences(saetze, rohtext, to_lower = FALSE)\n\n\n\n\n\n\nsaetze &lt;chr&gt;\n\n\n\n\nNeues Lehrbuch für modernes Marketing.\n\n\nMarketing wandelt sich im rasanten Tempo.\n\n\nAuf Kundenwünsche oder neue Technologien muss nicht nur auf der operativen, sondern auch auf der strategischen Ebene in nahezu Echtzeit reagiert werden.\n\n\nWelche Instrumente und Frameworks dem Marketing dabei zur Verfügung stehen, zeigt das gerade erschienene Lehrbuch des Instituts für Marketing Management: “Marketingmanagement.\n\n\nBuilding and Running the Business.\n\n\nMit Marketing Unternehmen transformieren” Marketing hat in den vergangenen Jahren einen Paradigmenwechsel durchlaufen.\n\n\n\nDieser Code ist übrigens identisch mit dem folgenden Code:\nRohdaten |&gt; \n    unnest_tokens(saetze, rohtext, to_lower = FALSE, token = \"sentences\")\nIn diesem Beispiel fällt auf, dass unnest_sentences() streng entlang den Satztrennzeichen (. ! ?) trennt und in Anführungszeichen eingebettete Sätze ebenfalls trennt. Dieses Verhalten kann nur dadurch beeinflusst werden, dass die Texte im Vorfeld entsprechend vorbereitet werden. In solchen Fällen empfiehlt es sich, eingebettete Satzenden durch ein Semikolon (;) zu ersetzen.\nIn anderen Fällen wollen wir nach dem Trennen die Satzzeichen aus den Sätzen vollständig entfernen. Das erreichen wir mit dem Parameter strip_punct = TRUE. Dieser Parameter veranlasst, dass alle Satzzeichen aus den Sätzen entfernt werden. Dazu gehört auch das Zeichen für das Satzende.\n\n\n9.8.3 Absätze trennen\nDamit wir Absätze trennen können, müssen die Rohtexte entsprechend vorbereitet sein. Absätze werden in Textformaten durch eine zusätzliche Leerzeile markiert. Das weicht von der üblichen Vorgehensweise bei der Arbeit mit Word ab. Dort markiert der einfache Zeilenumbruch einen Absatz.\n\n\n\n\n\n\nPraxis\n\n\n\nTrennen Sie beim Transkribieren mit MS Word Absätze immer mit einer zusätzlichen Leerzeile. In dieser Leerzeile dürfen keine anderen Symbole stehen (auch keine Leerschläge). Diese Zeile erzeugen Sie durch zwei Zeilenumbrüche mit der Eingabetaste. Sie halten sich so alle Optionen für die nachfolgende Analyse offen.\n\n\nSind die Textdaten entsprechend vorbereitet, dann können wir unsere Texte mit der Funktion unnest_paragraphs() in Absätze gliedern.\nRohdaten |&gt; \n    unnest_paragraphs(\n        saetze, \n        rohtext, \n        to_lower = FALSE, \n        paragraph_break = \"\\r\\n\\r\\n\"\n   )  \n\n\n\n\n\n\nWarnung\n\n\n\nDer zusätzliche Parameter paragraph_break = \"\\r\\n\\r\\n\" ist hier notwendig, weil die Daten aus Wort heraus als Nur Text (.txt) gespeichert wurden.\n\n\n\n\n9.8.4 n-Gramme extrahieren\nn-Gramme sind ein wichtiges Werkzeug für einen besseren inhaltlichen Überblick. Worte sind spezielle n-Gramme mit n = 1. Bei dieser Länge haben bestimmte häufig vorkommende Worte (die Stoppworte) die unerwünschte Eigenschaft, das Ergebnis inhaltlich zu verzerren. Durch das Entfernen dieser Worte wird aber immer auch ein Teil der inhaltlichen Bedeutung entfernt. Dieser besondere Effekt von Stoppworten tritt bei n-Grammen mit n &gt; 1 nicht auf.\nn-Gramme extrahieren wir mit der Funktion unnest_ngrams(). Dabei wird der Text in Wortsequenzen mit der Länge n gegliedert.\nRohdaten |&gt; \n    unnest_ngrams(ngram, rohtext, to_lower = FALSE) |&gt; \n    head()\n\n\n\nngram&lt;chr&gt;\n\n\n\n\nNeues Lehrbuch für\n\n\nLehrbuch für modernes\n\n\nfür modernes Marketing\n\n\nmodernes Marketing Marketing\n\n\nMarketing Marketing wandelt\n\n\nMarketing wandelt sich\n\n\n\nDieser Code ist identisch mit dem folgenden Code:\nRohdaten |&gt; \n    unnest_ngrams(ngram, rohtext, to_lower = FALSE, n = 3) |&gt; \n    head()\n\n\n\n\n\n\nPraxis\n\n\n\nTypische n-Gram-Längen sind 3, 5 oder 7.\nWobei die n-Gram-Länge von 3 am üblichsten ist.\n\n\nAm Beispiel ist die Arbeitsweise von n-Gram-Tokenisierung erkennbar: Beginnend vom ersten Wort wird eine Sequenz von n Worten extrahiert und so lange ein Wort weiter gegangen bis keine Wortsequenz der Länge n mehr möglich ist. Dabei ist zu beachten, dass Satz- und Zeilengrenzen nicht automatisch berücksichtigt werden. Um nur inhaltlich zusammenhängende n-Gramme zu erhalten, müssen zwei Tokenisierungen nacheinander vorgenommen werden. Das folgende Beispiel zeigt eine 3-Gram-Zerlegung auf Satzebene.\nRohtext |&gt; \n    unnest_sentences(saetze, rohtext, to_lower = FALSE)  |&gt; \n    unnest_ngrams(ngram, saetze, to_lower = FALSE)  |&gt; \n    head()\n\n\n\nngram&lt;chr&gt;\n\n\n\n\nNeues Lehrbuch für\n\n\nLehrbuch für modernes\n\n\nfür modernes Marketing\n\n\nMarketing wandelt sich\n\n\nwandelt sich im\n\n\nsich im rasanten"
  },
  {
    "objectID": "kapitel/zeichenketten/kapitel.html#rezepte",
    "href": "kapitel/zeichenketten/kapitel.html#rezepte",
    "title": "9  Zeichenketten",
    "section": "9.9 Rezepte",
    "text": "9.9 Rezepte\n\n9.9.1 Word als Datenquelle\nKodierte Texte sind keine Tabellen, sondern liegen als Word-Dokumente auf unserem Rechner. In diesen Word-Dokumenten sind unsere Daten Paare von markierten Textstellen und Kommentaren . Diese Paare wollen wir extrahieren.\nDieses Beispiel hat vier Beiträge vom offiziellen Blog des Studienschwerpunkts Marketing der ZHAW kopiert und kodiert. Dabei wurden Bilder entfernt. Mit diesem Beispiel untersuchen wir, ob diese Beiträge eine genderneutrale Sprache verwenden. Dazu wurden Substantive jeweils kategorisiert und mit der jeweiligen Geschlechtlichkeit (feminin, maskulin, neutral) kodiert.\n\n9.9.1.1 Schritt 1: Datei einlesen und bereinigen\nWenn wir unsere Texte mit Word kodiert haben, können wir sie mit Hilfe der docxtractr Bibliothek einlesen.\nlibrary(tidyverse)\nlibrary(docxtractr)\nNun können wir kodierte Dokumente in unsere R-Umgebung importieren. Dazu verwenden wir die besondere Funktion read_docx(). Diese Funktion liest das ganze Word-Dokument ein. Mit Hilfe der Funktion docx_extract_all_cmnts() sammeln wir unsere markierten Textstellen ein.\nread_docx(\"kodiert/marketing_1.docx\") |&gt; \n    docx_extract_all_cmnts(include_text = TRUE) -&gt; documentCodes\nDrei Vektoren sind für uns von besonderer Bedeutung:\n\nDer Vektor comment_text enthält nun unsere Kodierungen.\nDer Vektor id zeigt uns die Reihenfolge der Kommentare im Dokument.\nDer Vektor word_src enthält den beim Kodieren markierten Text.\n\nOft müssen wir unsere Codes und Texte noch bereinigen. In diesem Fall, sind die Codes nicht durchgehend einheitlich geschrieben und in jedem Kommentar stehen zwei Codes. Wir wollen deshalb die Codes trennen und vereinheitlichen. In unserem Fall sind enthalten die Kommentartexte immer zwei Kodierungen. Weil immer die gleiche Kode-Anzahl in den Kommentaren vorliegt, können wir die Funktion separate() verwenden.\n\n\n\n\n\n\nTipp\n\n\n\nDie Funktion separate() trennt einen Zeichenketten Vektor in mehrere Zeichenkettenvektoren auf.\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nDie separate()-Funktion darf nur verwenden werden, wenn alle Kommentare die gleiche Anzahl von Codes enthalten!\n\n\ndocumentCodes |&gt;\n    select(id, comment_text, word_src) |&gt; \n    separate(comment_text, into =c(\"kategorie\", \"gender\"), sep =\",\") |&gt;\n    mutate(\n        gender = gender |&gt; str_trim() |&gt; str_to_lower(),\n        kategorie = kategorie |&gt; str_trim() |&gt; str_to_lower()\n    ) -&gt; kodierteDaten\nNach diesem Schritt sind unsere Codes vereinheitlicht und für jede Textstelle können nun die Codes bearbeitet werden.\nFalls wir unterschiedlich viele Kodierungen in den Kommentaren vorliegen, müssen wir die Funktion str_split() und anschliessend unnest() verwenden.\ndata |&gt; \n    select(id, comment_text, word_src) |&gt; \n    mutate(\n        code = comment_text |&gt; str_split(\",\")\n    ) |&gt; \n    unnest(code) -&gt; allgemeinereExtraktion\n\n\n9.9.1.2 Schritt 2: Word Hyperlinks entfernen\nIn diesem Beispiel enthalten die markierten Texte Hyperlinks zu externen Seiten. Diese Links stören uns bei der Analyse und deshalb entfernen wir sie aus den Textstellen.\nkodierteDaten |&gt;\n    mutate(\n        word_src = word_src |&gt; str_remove(\"HY\\\\s?\\\\S+ \\\"[^\\\"]+\\\"[^\\\"]+\\\"[^\\\"]+\\\" \"),\n    ) -&gt; kodierteDaten2\n\n\n9.9.1.3 Schritt 3: Kategorien organisieren\nkodierteDaten2 |&gt; \n    count(kategorie)\n\n\n\nkategorie\ncount\n\n\n\n\naktivität\n7\n\n\naufgabe\n1\n\n\ncas\n10\n\n\neigenschaft\n4\n\n\nfähigkeit\n1\n\n\nfunktion\n5\n\n\ngruppe\n12\n\n\ninformation\n1\n\n\nkontext\n1\n\n\nkonzept\n1\n\n\norganisation\n1\n\n\nperson\n6\n\n\nprodukt\n3\n\n\ntechnik\n1\n\n\nzeit\n7\n\n\n\nBeachten Sie, dass der vorherige Teilschritt in der Regel nicht berichtet wird, weil das Ergebnis nur dazu dient, die Codes den richtigen Variablen zuzuordnen.\nDie Codes im Vektor Kategorie gehören zu verschiedenen Variablen. Diese Zuordnung muss explizit erfasst werden.\nAkteure = c(\"person\", \"organisation\", \"gruppe\")\n\nStudiengang = c(\"cas\", \"bsc\", \"mas\", \"msc\")\n\nFunktion = c(\"aktivität\", \"eigenschaft\", \"fähigkeit\",\n            \"möglichkeit\", \"funktion\", \"produkt\", \"anwendung\")\n\nKontext = c(\"kontext\", \"konzept\", \"technik\", \"zeit\", \"information\")\nWir können so die Kodierungen als Merkmalsausprägungen nominalskalierter Variablen verwenden, beschreiben und auswerten.\n\n\n9.9.1.4 Weiterführende Textanalyse\nWir können nun weiter analysieren und besonders häufige Worte für unsere Codes auswerten.\nWir extrahieren die einzelnen Worte aus der jeweiligen Markierung und entfernen Artikel und andere oft benutzte Worte aus unseren Daten.\nAnschliessend zählen wir die verbleibenden Worte nach Kategorien und Gender.\nDamit das Ergebnis einfacher zu lesen ist, wird das Ergebnis mit arrange() sortiert. Weil in unserem Fall sehr viele Worte nur einmal vorkommen, tragen diese nicht viel zum Gesamtinhalt bei. Daher werden diese Worte mit dem abschliessenden Filter für die Darstellung entfernt.\nlibrary(tidytext)\n\nstopwords_DE = tibble(\n    word = stopwords::stopwords(\"de\", source = \"stopwords-iso\")\n)\n\nkodierteDaten2 |&gt; \n    unnest_tokens(word, word_src) |&gt;\n    anti_join(stopwords_DE) |&gt; \n    count(word, kategorie, gender) |&gt; \n    arrange(desc(n)) |&gt; \n    filter(n &gt; 1)\n\n\n\nword\nkategorie\ngender\nn\n\n\n\n\ncas\ncas\nmaskulin\n9\n\n\nmarketing\nfunktion\nneutral\n3\n\n\nmitstudierenden\ngruppe\nneutral\n3\n\n\naustausch\naktivität\nmaskulin\n2\n\n\ndigital\ncas\nmaskulin\n2\n\n\nmarketing\ncas\nmaskulin\n2\n\n\nnetzwerk\ngruppe\nneutral\n2\n\n\nnpo\ncas\nmaskulin\n2\n\n\nreferenten\ngruppe\nmaskulin\n2\n\n\n\nSolche Auswertungen geben zusätzliche Einblicke in die Inhalte und helfen bei der Interpretation der Daten.\n\n\n\n9.9.2 Word als Datenquelle\nKodierte Texte sind keine Tabellen, sondern liegen als Word-Dokumente auf unserem Rechner. In diesen Word-Dokumenten sind unsere Daten Paare von markierten Textstellen und Kommentaren . Diese Paare wollen wir extrahieren.\nDieses Beispiel hat vier Beiträge vom offiziellen Blog des Studienschwerpunkts Marketing der ZHAW kopiert und in MS Word kodiert. Dabei wurden Bilder entfernt. Mit diesem Beispiel untersuchen wir, ob diese Beiträge eine genderneutrale Sprache verwenden. Dazu wurden Substantive jeweils kategorisiert und mit der jeweiligen Geschlechtlichkeit (feminin, maskulin, neutral) kodiert.\n\n9.9.2.1 Schritt 1: Datei einlesen und bereinigen\nWenn wir unsere Texte mit Word kodiert haben, können wir sie mit Hilfe der docxtractr Bibliothek einlesen.\nlibrary(tidyverse)\nlibrary(docxtractr)\nNun können wir kodierte Dokumente in unsere R-Umgebung importieren. Dazu verwenden wir die besondere Funktion read_docx(). Diese Funktion liest das ganze Word-Dokument ein. Mit Hilfe der Funktion docx_extract_all_cmnts() sammeln wir unsere markierten Textstellen ein.\nread_docx(\"kodiert/marketing_1.docx\") |&gt; \n    docx_extract_all_cmnts(include_text = TRUE) -&gt; documentCodes\nDrei Vektoren sind für uns von besonderer Bedeutung:\n\nDer Vektor comment_text enthält nun unsere Kodierungen.\nDer Vektor id zeigt uns die Reihenfolge der Kommentare im Dokument.\nDer Vektor word_src enthält den beim Kodieren markierten Text.\n\nOft müssen wir unsere Codes und Texte noch bereinigen. In diesem Fall, sind die Codes nicht durchgehend einheitlich geschrieben und in jedem Kommentar stehen zwei Codes. Wir wollen deshalb die Codes trennen und vereinheitlichen. In unserem Fall sind enthalten die Kommentartexte immer zwei Kodierungen. Weil immer die gleiche Kode-Anzahl in den Kommentaren vorliegt, können wir die Funktion separate() verwenden.\n\n\n\n\n\n\nTipp\n\n\n\nDie Funktion separate() trennt einen Zeichenketten Vektor in mehrere Zeichenkettenvektoren auf.\n\n\n\n\n\n\n\n\nWarnung\n\n\n\nDie separate()-Funktion darf nur verwenden werden, wenn alle Kommentare die gleiche Anzahl von Codes enthalten!\n\n\ndocumentCodes |&gt;\n    select(id, comment_text, word_src) |&gt; \n    separate(comment_text, into =c(\"kategorie\", \"gender\"), sep =\",\") |&gt;\n    mutate(\n        gender = gender |&gt; str_trim() |&gt; str_to_lower(),\n        kategorie = kategorie |&gt; str_trim() |&gt; str_to_lower()\n    ) -&gt; kodierteDaten\nNach diesem Schritt sind unsere Codes vereinheitlicht und für jede Textstelle können nun die Codes bearbeitet werden.\nFalls wir unterschiedlich viele Kodierungen in den Kommentaren vorliegen, müssen wir die Funktion str_split() und anschliessend unnest() verwenden.\ndata |&gt; \n    select(id, comment_text, word_src) |&gt; \n    mutate(\n        code = comment_text |&gt; str_split(\",\")\n    ) |&gt; \n    unnest(code) -&gt; allgemeinereExtraktion\n\n\n9.9.2.2 Schritt 2: Word Hyperlinks entfernen\nIn diesem Beispiel enthalten die markierten Texte Hyperlinks zu externen Seiten. Diese Links stören uns bei der Analyse und deshalb entfernen wir sie aus den Textstellen.\nkodierteDaten |&gt;\n    mutate(\n        word_src = word_src |&gt; str_remove(\"HY\\\\s?\\\\S+ \\\"[^\\\"]+\\\"[^\\\"]+\\\"[^\\\"]+\\\" \"),\n    ) -&gt; kodierteDaten2\n\n\n9.9.2.3 Schritt 3: Kategorien organisieren\nkodierteDaten2 |&gt; \n    count(kategorie)\n\n\n\nkategorie\ncount\n\n\n\n\naktivität\n7\n\n\naufgabe\n1\n\n\ncas\n10\n\n\neigenschaft\n4\n\n\nfähigkeit\n1\n\n\nfunktion\n5\n\n\ngruppe\n12\n\n\ninformation\n1\n\n\nkontext\n1\n\n\nkonzept\n1\n\n\norganisation\n1\n\n\nperson\n6\n\n\nprodukt\n3\n\n\ntechnik\n1\n\n\nzeit\n7\n\n\n\nBeachten Sie, dass der vorherige Teilschritt in der Regel nicht berichtet wird, weil das Ergebnis nur dazu dient, die Codes den richtigen Variablen zuzuordnen. Die Codes im Vektor Kategorie gehören zu verschiedenen Variablen. Diese Zuordnung muss explizit erfasst werden.\nAkteure = c(\"person\", \"organisation\", \"gruppe\")\n\nStudiengang = c(\"cas\", \"bsc\", \"mas\", \"msc\")\n\nFunktion = c(\"aktivität\", \"eigenschaft\", \"fähigkeit\",\n            \"möglichkeit\", \"funktion\", \"produkt\", \"anwendung\")\n\nKontext = c(\"kontext\", \"konzept\", \"technik\", \"zeit\", \"information\")\nWir können so die Kodierungen als Merkmalsausprägungen nominalskalierter Variablen verwenden, beschreiben und auswerten.\n\n\n9.9.2.4 Weiterführende Textanalyse\nWir können nun weiter analysieren und besonders häufige Worte für unsere Codes auswerten.\nWir extrahieren die einzelnen Worte aus der jeweiligen Markierung und entfernen Artikel und andere oft benutzte Worte aus unseren Daten.\nAnschliessend zählen wir die verbleibenden Worte nach Kategorien und Gender.\nDamit das Ergebnis einfacher zu lesen ist, wird das Ergebnis mit arrange() sortiert. Weil in unserem Fall sehr viele Worte nur einmal vorkommen, tragen diese nicht viel zum Gesamtinhalt bei. Daher werden diese Worte mit dem abschliessenden Filter für die Darstellung entfernt.\nlibrary(tidytext)\n\nstopwords_DE = tibble(\n    word = stopwords::stopwords(\"de\", source = \"stopwords-iso\")\n)\n\nkodierteDaten2 |&gt; \n    unnest_tokens(word, word_src) |&gt;\n    anti_join(stopwords_DE) |&gt; \n    count(word, kategorie, gender) |&gt; \n    arrange(desc(n)) |&gt; \n    filter(n &gt; 1)\n\n\n\nword\nkategorie\ngender\nn\n\n\n\n\ncas\ncas\nmaskulin\n9\n\n\nmarketing\nfunktion\nneutral\n3\n\n\nmitstudierenden\ngruppe\nneutral\n3\n\n\naustausch\naktivität\nmaskulin\n2\n\n\ndigital\ncas\nmaskulin\n2\n\n\nmarketing\ncas\nmaskulin\n2\n\n\nnetzwerk\ngruppe\nneutral\n2\n\n\nnpo\ncas\nmaskulin\n2\n\n\nreferenten\ngruppe\nmaskulin\n2\n\n\n\nSolche Auswertungen geben zusätzliche Einblicke in die Inhalte und helfen bei der Interpretation der Daten.\n\n\n\n9.9.3 Kodierte Daten aus mehreren Word-Dateien einlesen.\nKodierte Texte sind keine Tabellen, sondern liegen in mehrere Dateien auf unserem Rechner. Diese Dateien sollen in einem Schritt eingelesen werden und in ein Stichprobenobjekt umgewandelt werden.\n\n9.9.3.1 Lösung\nlibrary(tidyverse)\nlibrary(docxtractr)\n\ndatenordner = \"kodiert\"\n\ntibble(\n    datei = list.files(\n                    path = datenordner, \n                    pattern = \"^[^~]+.docx$\"  \n               )\n) |&gt; \n    group_by(datei) |&gt; \n    mutate(\n        pfad = str_c(datenordner, \"/\", datei),\n        codes = read_docx(pfad) |&gt; \n                    docx_extract_all_cmnts(include_text = TRUE) |&gt; list()\n    ) |&gt; \n    ungroup() |&gt; \n    unnest(codes) -&gt; alleCodes\n\n\n9.9.3.2 Erklärung\nDie Code-Beispiele basieren auf Dateien aus dem Beispieldaten\nWenn wir unsere Texte mit Word kodiert haben, können wir sie mit Hilfe der docxtractr Bibliothek einlesen.\nlibrary(tidyverse)\nlibrary(docxtractr)\nDazu erstellen wir uns ein Stichprobenobjekt zur Unterstützung, in das wir die Namen der Dateien einlesen.\ndatenordner = \"kodiert\"\n\ntibble(\n    datei = list.files(\n                    path = datenordner, \n                    pattern = \"^[^~]+.docx$\"  # nur reguläre Word Dokumente auswählen\n               )\n)  -&gt; dateinamen\nDie Funktion list.files() gibt einen Vektor mit allen Datennamen im angegebenen Verzeichnis path zurück. Mit dem Parameter pattern können Dateien nach ihrem Namen noch gezielter ausgewählt werden. Der hier gezeigte reguläre Ausdruck wird als Teil eines logischen Ausdrucks verwendet, um reguläre Word-Dokumente zu erhalten. Hier müssen wir aufpassen, denn die Dateiendung reicht nicht aus. Word erzeugt beim Bearbeiten einer Datei Hilfsdokumente, die ebenfalls auf docx enden, aber im vorderen Teil des Dateinamens eine Tilde (~) haben. Diese Dateien können wir nicht verwenden und sie dürfen deshalb nicht in unserer Dateiliste vorkommen.\nAnschliessend können wir die kodierten Dokumente einzeln einlesen. Dabei müssen wir beachten, dass die Funktion read_docx() nur eine Datei gleichzeitig einlesen kann. Wir müssen deshalb über die Dateinamen mit group_by() gruppieren. Dadurch erhalten wir Teilstichproben mit genau einen Dateinamen.\ndateinamen |&gt; \n    group_by(datei) |&gt; \n    mutate(\n        pfad = str_c(datenordner, \"/\", datei),\n        codes = read_docx(pfad) |&gt; \n                    docx_extract_all_cmnts(include_text = TRUE) |&gt; list()\n    ) |&gt; \n    ungroup() |&gt; \n    unnest(codes) -&gt; alleCodes\n\n\n\n\n\n\nWarnung\n\n\n\nBeachten Sie, dass Sie mit dem Parameter include_text = TRUE nicht nur die Kodierung einlesen, sondern auch den Text, der beim Kodieren markiert wurde.\n\n\nMit dieser Operation lesen wir jede einzelne Datei ein. In der Variablen alleCodes liegen nun alle vorgenommenen Kodierungen mit den relevanten Zusatzinformationen. Weil die Dateinamen Teil der Stichprobe ist, kann jeder Code und jeder markierte Text der Ursprungsdatei zugeordnet werden.\n\n\n9.9.3.3 Lösung für normale Textdateien\nDas gleiche Prinzip funktioniert auch für beliebige Textdateien.\ndatenordnet = \"texte\"\ndateiendung = \"txt\"\n\ntibble(\n    datei = list.files(\n                    path = datenordner, \n                    pattern = str_c(\"\\\\.\", dateiendung, \"$\")\n               )\n) |&gt; \n    group_by(datei) |&gt; \n    mutate(\n        pfad = str_c(datenordner, \"/\", datei),\n        codes = read_file(pfad)\n    ) |&gt; \n    ungroup() -&gt; eingeleseneTexte\n\n\n\n\nWickham, H. (2023). stringr: Simple, Consistent Wrappers for Common String Operations. https://stringr.tidyverse.org"
  },
  {
    "objectID": "kapitel/faktoren/kapitel.html#verwendung-von-faktoren-in-r",
    "href": "kapitel/faktoren/kapitel.html#verwendung-von-faktoren-in-r",
    "title": "10  Faktoren",
    "section": "10.1 Verwendung von Faktoren in R",
    "text": "10.1 Verwendung von Faktoren in R\nNeben der Bedeutung für die Empirie sind Faktoren in R auch für die Darstellung von Daten von Bedeutung. Dabei wird die Ordnung der Faktorstufen für die Anordnung von Ergebnissen verwendet, die mit Hilfe eines Faktors berechnet wurden. Diese Ordnung wird von ggplot() und für die Sortierung der Ergebnisse gruppierter Daten verwendet. Die Verwendung von Faktoren für solche Aufgaben hat den Vorteil, dass die Reihenfolge der Datensätze nicht verändert werden muss.\nIm folgenden werden die Funktionen der tidyverse-Bibliothek forcats (Wickham, 2023) vorgestellt.\nDie folgenden Beispiele verwenden die Stichprobe digitales_umfeld.csv\ndigitales_umfeld = read_csv(\"digitales_umfeld1.csv\")\nWenn wir zum Beispiel die Anzahl der Mobilgerätetypen bestimmen möchten, dann können wir naiv vorgehen:\ndigitales_umfeld |&gt; \n    group_by(mobilgeraet) |&gt; \n    count()\n\n\n\nmobilgeraet &lt;chr&gt;\nn &lt;int&gt;\n\n\n\n\nAndroid Smartphone\n64\n\n\niPhone\n69\n\n\nMobiltelefon\n2\n\n\n\nWenn wir die häufigste Nennung eines Mobilgeräts als erstes in dieser Tabelle stehen haben möchten, dann bietet sich die Verwendung eines Faktors mit organisierten Faktorstufen an.\ndigitales_umfeld |&gt; \n    mutate(\n        mobilgeraet = mobilgeraet |&gt; as_factor() |&gt; fct_infreq()\n    ) |&gt; \n    group_by(mobilgeraet) |&gt; \n    count()\n\n\n\nmobilgeraet &lt;chr&gt;\nn &lt;int&gt;\n\n\n\n\niPhone\n69\n\n\nAndroid Smartphone\n64\n\n\nMobiltelefon\n2"
  },
  {
    "objectID": "kapitel/faktoren/kapitel.html#erstellen-von-faktoren",
    "href": "kapitel/faktoren/kapitel.html#erstellen-von-faktoren",
    "title": "10  Faktoren",
    "section": "10.2 Erstellen von Faktoren",
    "text": "10.2 Erstellen von Faktoren\nFaktoren sind ein zentraler Bestandteil von R. Ohne die tidyverse Bibliothek kann ein Faktor mittels der Funktion factor() erstellt werden.\nGegeben sei zum Beispiel der Vektor mit den Namen der Studiengänge des ZHAW Departements LSFM:\nStudiengaenge = c(\n    \"Chemie\", \n    \"Umweltingenieurwesen\", \n    \"Facility Management\", \n    \"Biotechnologie\", \n    \"Lebensmitteltechnology\",\n    \"Applied Digital Life Sciences\", \n    \"Biomedical Labordiagnostik\"\n)\nDieser Vektor enthält nur Zeichenketten und ist daher ein Zeichenkettenvektor. Der Funktionsaufruf is.factor(Studiengaenge) gibt entsprechend FALSE als Ergebnis zurück.\nDieser Vektor kann einfach in einen Faktor umgewandelt werden.\nstgFaktor = Studiengaenge |&gt; factor()\n\nstgFaktor\n\nChemie\nUmweltingenieurwesen\nFacility Management\nBiotechnologie\nLebensmitteltechnology\nApplied Digital Life Sciences\nBiomedical Labordiagnostik\n\nDas Ergebnis unterscheidet sich nicht wesentlich vom ursprünglichen Vektor. Wir können mit dem Aufruf is.factor(stgFaktor) überprüfen, ob es sich nun um einen Faktor handelt. Wir erhalten nun TRUE als Ergebnis.\nWir können nun mit der Funktion levels() die Faktorstufen abfragen. Diese Funktion gibt uns einen Vektor mit allen Faktorstufen zurück.\nstgFaktor |&gt; \n    levels()\n\nApplied Digital Life Sciences\nBiomedical Labordiagnostik\nBiotechnologie\nChemie\nFacility Management\nLebensmitteltechnology\nUmweltingenieurwesen\n\nDieses Ergebnis ist etwas überraschend, weil die Reihenfolge der Faktorstufen nicht mehr mit der Reihenfolge der Werte in unserem Vektor übereinstimmt. Wir sehen am Ergebnis, dass die Funktion factor() die Annahme macht, dass unsere Faktorstufen alphabetisch sortiert sind. Leider ist das oft nicht der Fall und gerade bei unsortierten Faktoren müssen die Werte Präsentationen oft neu arrangiert werden. Deshalb hat sich die Konvention eingebürgert, für die initiale Reihenfolge von Faktorstufen das erste Auftreten des jeweiligen Werts zu wählen. Dazu müssen wir der factor()-Funktion auch die Faktorstufen mitgeben.\nstgFaktor = Studiengaenge |&gt;\n    factor(\n         # erzeugt alle Faktorstufen in der Reihenfolge des ersten Auftretens, \n         # selbst wenn Werte doppelt auftreten. \n        Studiengaenge |&gt; unique() \n    )\nNun können wir mit der levels()-Funktion die Reihenfolge der Faktorstufen überprüfen.\nWeil diese Vorgehensweise eine Konvention moderner R-Programmierung ist, gibt es eine Funktion, die uns diesen Schritt kompakter schreiben lässt. Dazu verwenden wir die Funktion as_factor().\nstgFaktor = Studiengaenge |&gt;\n    as_factor()\nWenn wir einzelne Vektoren in einem Stichprobenobjekt in Faktoren umwandeln wollen, dann führen wir eine Umwandlung mit mutate() durch.\nWir wollen nur den Vektor mobilgeraet, geschlecht und digitalisiert in Faktoren umwandeln.\ndigitales_umfeld |&gt; \n    mutate(\n        mobilgeraet = mobilgeraet |&gt; as_factor(),\n        geschlecht = geschlecht |&gt; as_factor(),\n        digitalisiert = digitalisiert |&gt; as_factor()\n    ) -&gt; duFaktorisiert \n\nduFaktorisiert\n\n\n\n\n\n\n\n\n\n\n\n\ngeschlecht &lt;fct&gt;\nalter &lt;dbl&gt;\ntage &lt;dbl&gt;\nmonate &lt;dbl&gt;\ngeburtsjahr &lt;dbl&gt;\ndigitalisiert &lt;fct&gt;\nmobilgeraet &lt;fct&gt;\n\n\n\n\nMännlich\n23\n8474\n278\n1998\n3\niPhone\n\n\nMännlich\n27\n9970\n327\n1994\n6\nAndroid Smartphone\n\n\nMännlich\n27\n10131\n332\n1994\n6\niPhone\n\n\nWeiblich\n25\n9253\n304\n1996\n5\nAndroid Smartphone\n\n\nMännlich\n25\n9363\n307\n1996\n6\niPhone\n\n\nAndere\n23\n8750\n287\n1997\n2\niPhone\n\n\n…\n…\n…\n…\n…\n…\n…\n\n\n\nWir sehen nun, dass die faktorisierten Vektoren nun den Datentyp Factor (fct) haben."
  },
  {
    "objectID": "kapitel/faktoren/kapitel.html#forcats---faktoren-leicht-gemacht",
    "href": "kapitel/faktoren/kapitel.html#forcats---faktoren-leicht-gemacht",
    "title": "10  Faktoren",
    "section": "10.3 forcats - Faktoren leicht gemacht",
    "text": "10.3 forcats - Faktoren leicht gemacht\nDie Arbeit mit Faktoren ist in Base-R nicht immer ganz einfach. Wollschläger (2017, Kap. 2.6) zeigt detailliert, wie Faktoren mit R erstellt und manipuliert werden. Das ist zum Teil recht komplex und aufwändig. Zum Glück versteckt die forcats-Bibliothek die Komplexität von R-Faktoren vor uns, sodass wir präzise ausdrücken können, wie wir die interne Struktur unserer diskreten Daten organisieren möchten.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Funktionen der forcats-Bibliothek sind verfügbar, sobald Sie die tidyverse-Bibliothek eingebunden haben.\n\n\nDie forcats-Bibliothek bietet neun Funktionen zum Umorganisieren von Faktoren."
  },
  {
    "objectID": "kapitel/faktoren/kapitel.html#organisieren-von-faktorstufen",
    "href": "kapitel/faktoren/kapitel.html#organisieren-von-faktorstufen",
    "title": "10  Faktoren",
    "section": "10.4 Organisieren von Faktorstufen",
    "text": "10.4 Organisieren von Faktorstufen\nDie zentrale Funktion in R von Faktorstufen ist ihre Bedeutung für die Ordnung der Werte des jeweiligen Faktors. Indem wir die Faktorstufen organisieren, können wir die Werte des Vektors strukturieren, ohne ihre Reihenfolge zu ändern.\nFür die Organisation von Faktorstufen gibt es vier häufig vorkommende Aufgaben:\n\nOrganisation entlang einer vordefinierten Reihenfolge (Skala),\nOrganisation entlang der internen Organisation eines Datentyps,\nOrganisation entlang der Häufigkeit eines Werts,\nOrganisation entlang des Auftretens in der Stichprobe.\n\nDie erste Aufgabe tritt immer ein, wenn wir mit etablierten Methoden arbeiten. In diesem Fall ist die Reihenfolge der Faktorstufen bereits bekannt. In solchen Fällen sprechen wir von der Zuordnung einer Skala. Für solche Zuordnungen verwenden wir die Funktion fct_relevel().\nZum Beispiel wollen wir die Faktorstufen in der Stichprobe digitales Umfeld nach einer externen Vorgabe festlegen, sodass die folgende “Ladies-First” Reihenfolge gilt:\ngeschlecht_faktorstufen = c( \"Weiblich\", \"Andere\", \"Keine Angabe\", \"Männlich\" )\nNun können wir den Faktor geschlecht entsprechend umformen.\nduFaktorisiert |&gt; \n    mutate(\n        geschlecht = geschlecht |&gt; fct_relevel( geschlecht_faktorstufen )\n    ) -&gt; digitales_umfeld_externe_skala\n\n\n\n\n\n\nWarnung\n\n\n\nWenn Sie mit fct_relevel() eine vorgegebene Skala als Vektor übergeben, die nicht vollständig in der Stichprobe abgedeckt wurde, dann erhalten Sie eine kryptische Warnung, die auf Unknown levels in `f`: endet. Diese Warnung können Sie ignorieren. R fügt die fehlenden Faktorstufen nicht ein, behält aber deren innere Organisation bei.\n\n\nDie zweite Aufgabe ist die Organisation der Faktorstufen nach der internen Organisation des jeweiligen Datentyps. Liegen die Werte als Zahlen vor, dann werden die Faktorstufen entsprechend des jeweiligen Nennwerts sortiert. Liegen die Werte als Zeichenketten vor, dann werden die Faktorstufen alphabetisch sortiert. Diese Organisation entspricht der Vorgehensweise der meisten Base-R Funktionen. Falls unsere Daten als Zahlen (oder Wahrheitswerte) vorliegen, können wir für diese Vorgehensweise die Funktion fct_inseq() verwenden.\nduFaktorisiert |&gt; \n    mutate(\n        digitalisiert = digitalisiert |&gt;  fct_inseq()\n    ) -&gt; duFaktorisiert_sequenziell\nIm Fall von Zeichenketten als Faktorstufen, müssen wir die bestehenden Faktorstufen selbst umsortieren und dann als neue Vorgabe mit fct_relevel() übergeben. Im folgenden Beispiel ist das alphabetische Sortieren der Faktorstufen eine eingebettete Funktionskette.\nduFaktorisiert |&gt; \n    mutate(\n        mobilgeraet = mobilgeraet |&gt; fct_relevel( mobilgeraet |&gt; levels() |&gt; sort() )\n    ) -&gt; duFaktorisiert_alphabetisch\nDie dritte Aufgabe ist die Organisation nach der Häufigkeit eines Werts in einer Stichprobe. Diese Vorgehensweise ist besonders für nominalskalierte Daten interessant, um über die Häufigkeiten die Reihenfolge der Faktorstufen festzulegen. Hierbei hilft die Funktion fct_infreq(). Die Faktorstufen werden so den Häufigkeiten entsprechend in der Stichprobe ab- bzw. aufsteigend organisiert.\nduFaktorisiert |&gt; mutate(\n        mobilgeraet = mobilgeraet |&gt;  fct_infreq()\n    ) -&gt; duFaktorisiert_frequenz\nBei der vierten Aufgabe sollen die Faktorstufen entlang der Reihenfolge des ersten Auftretens in der Stichprobe erfolgen. Dieser Fall tritt meistens dann ein, wenn die Faktorstufen umorganisiert wurden und wieder in die ursprüngliche Reihenfolge gebracht werden müssen. Die Funktion fct_inorder() übernimmt diese Aufgabe.\nduFaktorisiert |&gt; mutate(\n        mobilgeraet = mobilgeraet |&gt;  fct_inorder()\n    ) -&gt; duFaktorisiert_reihenfolge\n\n10.4.1 Faktorstufen an den Werten eines anderen Vektors ausrichten\nMit der Funktion fct_reorder() können wir die Faktorstufen eines Vektors über die Werte eines anderen Vektors organisieren. Solche Ausrichtungen sind oft nach Aggregationen sinnvoll, wenn für jede Faktorstufe eines nominalskalierten Vektors genau ein Wert in einem anderen Vektor festliegt. Dabei muss aber immer genau ein Wert einer Faktorstufe entsprechen. Dabei wird für die Faktorstufen eine absteigende bzw. (optional) aufsteigende Reihenfolge des Referenzvektors angenommen.\nmsleep |&gt; \n    mutate(\n        name = name |&gt; as_factor() |&gt; fct_reorder(sleep_total)\n    )\nÄhnlich wie beim Gruppieren, ändert sich die sichtbare Struktur des Stichprobenobjekts nicht. Es wird lediglich die interne Reihenfolge der Faktorstufen angepasst. Solche Schritte sind für aussagekräftige Visualisierungen sehr hilfreich."
  },
  {
    "objectID": "kapitel/faktoren/kapitel.html#faktorstufen-und-visualisierung",
    "href": "kapitel/faktoren/kapitel.html#faktorstufen-und-visualisierung",
    "title": "10  Faktoren",
    "section": "10.5 Faktorstufen und Visualisierung",
    "text": "10.5 Faktorstufen und Visualisierung\nFaktoren erleichtern das Veranschaulichen von Daten. Der grosse Vorteil bei der Verwendung von Faktoren ist, dass sich der Code für die Visualisierung nicht ändert. Mit Hilfe der Faktorstufen geben wir ggplot Hinweise über die Struktur der Werte in einem Vektor. Dadurch werden unsere Visualisierungen aussagekräftiger.\n\n10.5.1 Überzählige Achsenbeschriftungen entfernen\nFaktoren werden regelmässig für die Datenvisualisierung verwendet, um diskrete Daten richtig darzustellen. Das ist besonders dann notwendig, wenn die Werte im entsprechenden Vektor mit Zahlen dargestellt werden und die Reihenfolge dieser Zahlen vom Üblichen abweicht.\nNehmen wir zum Beispiel die Stichprobe mtcars und den Vektor cyl (Zylinder) . Dieser Vektor nimmt nur die folgenden diskreten Werte an.\nmtcars |&gt; \n    summarise( cyl = unique(cyl) )\n\n\n\ncyl  &lt;dbl&gt;\n\n\n\n\n6\n\n\n4\n\n\n8\n\n\n\nIn beiden Fällen haben wir also diskrete Daten. Wenn wir die Daten darstellen, dann ergibt sich das folgende Bild.\nmtcars |&gt; \n   ggplot(aes(x = cyl )) + \n      geom_bar()\n\n\n\nAbbildung 10.1: mtcars cyl ohne Faktorisierung\n\n\nHier erkennen wir, dass die X-Achse Werte anzeigt, die gar nicht vorkommen können. Dieses Problem können wir leicht beheben, indem wir den Vektor faktorisieren.\nmtcars |&gt; \n   mutate( cyl = cyl |&gt; as_factor() )  |&gt;\n   ggplot(aes(x = cyl )) + \n      geom_bar()\n\n\n\nAbbildung 10.2: mtcars cyl mit Faktorisierung\n\n\n\n\n10.5.2 Sortierte Balkendiagramme\nDas Arrangieren von Daten erreichen wir ebenfalls mit Faktoren. Hierzu betrachten wir die Vektoren name und sleep_total aus der Stichprobe msleep. Stellen wir die beiden Vektoren in einem Balkendiagramm gegenüber, dann können wir kaum die verschiedenen Spezies vergleichen.\nmsleep |&gt; \n    ggplot(aes(name, sleep_total)) + \n        geom_col() +\n        coord_flip()\n\n\n\nAbbildung 10.3: msleep data ohne Faktorisierung\n\n\nWesentlich anschaulicher wird dieses Balkendiagramm, wenn wir den name-Vektor vor der Visualisierung in einen Faktor umwandeln und die Faktorstufen entlang der Gesamtschlafdauer organisieren.\nmsleep |&gt; \n    mutate(\n        name = name |&gt; as_factor() |&gt; fct_reorder(sleep_total)\n    ) |&gt;  \n    ggplot(aes(name, sleep_total)) + \n        geom_col() +\n        coord_flip()\n\n\n\nAbbildung 10.4: msleep data mit Faktorisierung\n\n\n\n\n\n\nWickham, H. (2023). forcats: Tools for Working with Categorical Variables (Factors). https://forcats.tidyverse.org/"
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#logische-aggregationen-mit-reduce",
    "href": "kapitel/boolsche-operationen/kapitel.html#logische-aggregationen-mit-reduce",
    "title": "11  Boole’sche Operationen",
    "section": "11.1 Logische Aggregationen mit reduce()",
    "text": "11.1 Logische Aggregationen mit reduce()\n\n\n\n\n\n\nMerke\n\n\n\nUm logische Vektoren in R zu aggregieren, muss der Vektor reduziert (engl. reduce) werden. Das Reduzieren ist eine besondere Aggregation über eine Reihe von Werten, bei der jeder Wert gemeinsam mit dem Ergebnis der Vorgängerwerte an eine Funktion übergeben wird.\n\n\n\nBeispiel 11.3 (Aggregation logischer Vektoren)  \n\nbeispielWerte = c(TRUE, TRUE, FALSE, TRUE)\n\nbeispielWerte |&gt; reduce(`&`)   \n\n[1] FALSE\n\nbeispielWerte |&gt; reduce(`|`)   \n\n[1] TRUE\n\nbeispielWerte |&gt; reduce(`xor`) \n\n[1] TRUE\n\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nBeim Reduzieren muss beachtet werden, dass eine Funktion und nicht den Operator übergeben wird. Deshalb muss der jeweilige logische Operator in Backticks (`) gesetzt und so als Funktionsbezeichner markiert werden."
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#vergleiche",
    "href": "kapitel/boolsche-operationen/kapitel.html#vergleiche",
    "title": "11  Boole’sche Operationen",
    "section": "11.2 Vergleiche",
    "text": "11.2 Vergleiche\nNeben den logischen Operationen sind Vergleiche ein wichtiges Konzept, das wir in logischen Ausdrücken regelmässig anwenden.\nEs gibt genau sechs (6) Vergleichsoperatoren:\n\nGleich (==)\nUngleich (!=)\nGrösser als (&gt;)\nGrösser gleich (&gt;=)\nKleiner als (&lt;)\nKleiner gleich (&lt;=)\n\n\n\n\n\n\n\nWarnung\n\n\n\nVergleiche erfordern, dass beide Werte vom gleichen Datentyp sind.\n\n\nDie Vergleiche funktionieren für alle fundamentalen Datentypen.\nBei Zeichenketten wertet R die alphabetische Reihenfolge der Symbole vom Beginn einer Zeichenkette aus, um grösser oder kleiner Vergleiche durchzuführen.\n\n11.2.1 Die Existenz eines Werts in einem Vektor überprüfen\nHäufig müssen Sie überprüfen, ob ein Wert in einer Liste vorkommt. Grundsätzlich können Sie das mit komplizierten logischen Verknüpfungen in der Art von Beispiel 11.4 schreiben.\n\nBeispiel 11.4 (Existstenzprüfung ohne %in%)  \n\nmeinWert = 3\nwertVektor = c(8, 2, 3)\n\nmeinWert == wertVektor[1] | meinWert == wertVektor[2] | meinWert == wertVektor[3]\n\n[1] TRUE\n\n\n\nEinfacher ist aber ein sogenannter Existenztest. Dabei wird überprüft, ob ein Wert in einem Vektor vorkommt. Ein solcher Test lässt sich wie in Beispiel 11.5 schreiben:\n\nBeispiel 11.5 (Existstenzprüfung mit %in%)  \n\nmeinWert = 3\nwertVektor = c(8, 2, 3)\n\nmeinWert %in% wertVektor\n\n[1] TRUE\n\n\n\nEntsprechend der Definition des Existenzvergleichs \\in funktioniert R’s %in%-Operator auch für Vektoren als linker Operand."
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#fälle-unterscheiden",
    "href": "kapitel/boolsche-operationen/kapitel.html#fälle-unterscheiden",
    "title": "11  Boole’sche Operationen",
    "section": "11.3 Fälle unterscheiden",
    "text": "11.3 Fälle unterscheiden\n\n11.3.1 Bedingte Operationen\nR kennt die beiden Schlüsselworte if und else, um die Ausführung Operationsblöcken an Bedingungen zu knüpfen. Das Schlüsselwort if erwartet einen logischen Ausdruck, der genau einen Wahrheitswert zurückgibt. Logische Ausdrücke mit Vektoren sind damit nicht möglich.\nSoll sowohl die Bedingung als auch die Alternative behandelt werden, dann muss das Schlüsselwort else in der gleichen Zeile stehen, wie das Ende des Blocks für die Bedingung.\n\nBeispiel 11.6 (Ungültige Vektorbedingung mit if)  \n\nwerte = c(-1, 2, 0, 1)\n\nif (werte &gt; 1) {\n    werte = werte - 1\n} else {\n    werte = 0\n}\n\nError in if (werte &gt; 1) {: Bedingung hat Länge &gt; 1\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nBedingte Operationen sind in R nur selten notwendig. Die einzige relevandte Anwendung ist Datentypkontrolle für Parameter bevor die eigentliche Operation durchgeführt wird.\n\n\n\nBeispiel 11.7 (Datentypprüfung mit if)  \n\nif (!is.list(werte)) {\n    stop(\"Variable enthält keine Liste\")\n}\n\nError in eval(expr, envir, enclos): Variable enthält keine Liste\n\n\n\n\n\n11.3.2 Vektorisierte Unterscheidungen\nHäufiger als Bedingungen kommen in R vektorisierte Unterscheidungen vor. Dafür stehen zwei Funktionen zur Verfügung:\n\nifelse()\ncase_when()\n\nDie Funktion ifelse() hat drei Parameter und immer einen Vektor als Ergebnis. Die Parameter sind:\n\nEinen vektorisierten logischen Ausdruck.\nEine Operation für den Fall, dass der logische Ausdruck Wahr (TRUE) ergibt.\nEine Opearation für den Fall, dass der logische Ausdruck Falsch (FALSE) ergibt.\n\nDie Ergebnisse der beiden Operationen stehen im Ergebnisvektor an den Positionen, an denen der logische Ausdruck Wahr oder Falsch ergab.\n\nBeispiel 11.8 (Vektorisierte Unterscheidung mit ifelse())  \n\nifelse(werte &gt; 1, werte * 2, 0)\n\n[1] 0 4 0 0\n\n\n\nDie Funktion case_when() erlaubt es, mehrere miteinander verbundene vektorisierte Unterscheidungen in einer Operation durchzuführen. Dazu werden logische Ausdrücke mit Ergebnisoperationen bzw. -Werten verknüpft. Eine Ergebnisoperation wird dann ausgeführt, wenn der zugehörige logische Ausdruck Wahr (TRUE) ergibt. Die logischen Ausdrücke werden in der angegebenen Reihenfolge geprüft, wobei die Operation abbricht, sobald ein logischer Ausdruck Wahr ergibt.\n\nBeispiel 11.9 (case_when() über einen Vektor)  \n\ncase_when(\n    werte &gt; 0 ~ \"positiv\",\n    werte == 0 ~ \"null\",\n    werte &lt; 0 ~ \"negativ\" \n)\n\n[1] \"negativ\" \"positiv\" \"null\"    \"positiv\"\n\n\n\nFür den Fall, dass für einen Wert kein logischer Ausdruck Wahr ergibt, kann ein Rückfallergebnis angegeben werden. Dieses Rückfallergebnis muss mit .default = eingeleitet werden.\n\nBeispiel 11.10 (case_when() mit Rückfallergebnis)  \n\ncase_when(\n    werte &gt; 0 ~ \"positiv\",\n    werte &lt; 0 ~ \"negativ\",\n    .default = \"null\"\n)\n\n[1] \"negativ\" \"positiv\" \"null\"    \"positiv\""
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#filtern",
    "href": "kapitel/boolsche-operationen/kapitel.html#filtern",
    "title": "11  Boole’sche Operationen",
    "section": "11.4 Filtern",
    "text": "11.4 Filtern\nDas Filtern von Werten in Vektoren und Stichproben ist ein zentrales Element von R. Dafür stehen viele Funktionen bereit. Es ist auch möglich über die Index-Operatoren zu filtern.\nIn der Praxis wird meistens die Funktion filter() zum Auswählen von Datensätzen verwendet. Diese Funktion ermöglicht es, einen Datenrahmen mittels eines logischen Ausdrucks einzuschränken. Die Funktion filter() hat zwei Parameter:\n\nDen Datenrahmen und\nDen logischen Ausdruck für die Auswahl der Datensätze.\n\nDas Ergebnis ist ein Datenrahmen, der nur Datensätze enthält, für die der logische Ausdruck Wahr (TRUE) ergibt.\n\n\nBeispiel 11.11 (Filtern)  \n\n\n\n\nA\nB\nC\n\n\n\n\n1\nName\nSprache\nEinwohner:innen\n\n\n2\nBasel\ndeutsch\n173863\n\n\n3\nGenf\n französisch\n203856\n\n\n4\nLugano\nitalienisch\n62315\n\n\n5\nZug\ndeutsch \n30934\n\n\n6\nZürich\ndeutsch \n421878\n\n\n\nFür diese Stichprobe möchten wir wissen, wie viele Einwohner in Städten mit mehr als 100000 Einwohnenden leben?\nDiese Frage beantworten wir mit der folgenden Logik:\n\nAlle Städte mit mehr als 100000 Einwohner:innen filtern.\n\nDie Einwohner:innen der gefilterten Städte zusammenzählen.\n\nDer logische Ausdruck zum Filtern ist `Einwohner:innen` &gt; 100000, weil dieser Ausdruck nur für die Datensätze Wahr wird, wenn im Vektor Einwohner:innen der Wert grösser als 100000 ist. Nach dem Filtern im ersten Schritt liegt nur noch die folgende Stichprobe vor:\n\n\n\n\nA\nB\nC\n\n\n\n\n1\nName\nSprache\nEinwohner:innen\n\n\n2\nBasel\ndeutsch\n173863\n\n\n3\nGenf\n französisch\n203856\n\n\n6\nZürich\ndeutsch \n421878\n\n\n\nFür diese Teilstichprobe muss im zweiten Schritt nur noch die Summe über den Vektor Einwohner:innen gebildet werden.\nDaraus ergibt sich die folgende Funktionskette:\n\n1read_delim(\"daten/einwohnende.psv\",\n           delim = \"|\",\n           trim_ws = T,\n           show_col_types = F) |&gt;\n2    filter(`Einwohner:innen` &gt; 100000) |&gt;\n    summarise(\n        Gesamteinwohnende = sum(`Einwohner:innen`)\n    )\n\n\n1\n\nread_delim() muss verwendet werden, weil ein besonderes Trennzeichen benutzt wird.\n\n2\n\nFilter operation.\n\n\n\n\n# A tibble: 1 × 1\n  Gesamteinwohnende\n              &lt;dbl&gt;\n1            799597\n\n\n\n\n\n11.4.1 NA-Werte filtern\nDie Funktion drop_na() ist eine spezielle Filterfunktion, deren Ergebnis nur Datensätze enthält, in denen bei keinem Vektor den Wert NA vorkommt. Die Funktion hat keinen Effekt, wenn ein Datenrahmen nur gültige Werte enthält (Beispiel 11.12).\n\nBeispiel 11.12 (drop_na() ohne Effekt)"
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#selektieren",
    "href": "kapitel/boolsche-operationen/kapitel.html#selektieren",
    "title": "11  Boole’sche Operationen",
    "section": "11.5 Selektieren",
    "text": "11.5 Selektieren\n\n\n\n\n\n\nPraxis\n\n\n\nDie tidyverse Bibliothek umfasst die tidyselect-Funktionen. Dabei handelt es sich um eine Reihe von Hilfsfunktionen, die die Vektorenauswahl nachvollziehbarer macht. Auf der tidyselect-Homepage finden sich ausführliche Code-Beispiele.\n\n\nIn R können Vektoren mit der Funktion select() selektiert werden. Dieser Funktion werden Regeln übergeben, nach denen die Vektoren auswählt werden sollen. Die einfachste Regel ist die direkte Eingabe der Vektorennamen. Ein typischer Anwendungsfall ist die Datenbereinigung, damit die Funktion drop_na() nicht zu viele Datensätze löscht. Diese Situation kommt vor, wenn ein Datenrahmen viele fehlende Werte enthält, die ungleichmässig in den Vektoren vorkommen. Die Analyse muss deshalb auf die gewünschten Vektoren beschränkt werden.\nFür die folgenden Beispiele verwenden wir die Daten der Befragung zum digitalen Umfeld, die mit der read_csv()-Funktion eingelesen wird.\n\nstichprobe = read_csv(\"daten/befragung_digitales_umfeld/deviceuse.csv\") \n\nRows: 76 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): q00_demo_gen, q00_demo_studyload, q01_mob_typ, q12_fav_apps\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n11.5.1 Vektoren direkt selektieren\nWir wollen die Vektoren q00_demo_gen (Gender), q00_demo_studyload (Studienmodell) und q01_mob_typ (Mobile OS des Smartphones) auswählen.\n\nBeispiel 11.13 (Direktes selektieren)  \n\nstichprobe |&gt;\n    select(q00_demo_gen, q00_demo_studyload, q01_mob_typ) |&gt;\n    head()\n\n# A tibble: 6 × 3\n  q00_demo_gen q00_demo_studyload q01_mob_typ       \n  &lt;chr&gt;        &lt;chr&gt;              &lt;chr&gt;             \n1 Weiblich     Vollzeit           iPhone            \n2 Weiblich     Vollzeit           iPhone            \n3 Weiblich     Teilzeit           iPhone            \n4 Weiblich     Teilzeit           iPhone            \n5 Männlich     &lt;NA&gt;               Android Smartphone\n6 Weiblich     Vollzeit           iPhone            \n\n\n\nDurch diesen Aufruf von select() wird der Datenrahmen auf die drei ausgewählten Vektoren reduziert.\n\n\n11.5.2 Alle ausser die benannten Vektoren selektieren\nVektoren direkt zu benennen ist eine einfache direkte Methode. Wenn man sehr viele Vektoren auswählen möchte, dann ist es manchmal einfacher, nur die Vektoren anzugeben, die nicht in der Ergebnisstichprobe enthalten sein sollen. Mit select() erreichen wir das, indem wir ein - den ungewollten Vektoren voranstellen.\nDas folgende Beispiel selektiert alle Vektoren ausser q00_demo_gen aus der Stichprobe.\n\nBeispiel 11.14 (Selektieren durch Ausschliessen)  \nstichprobe |&gt;\n    select(-q00_demo_gen) |&gt;\n    head()\n\nWenn mehrere Vektoren ausgeschlossen werden sollen, dann müssen diese zu einem Vektor zusammengefasst werden.\n\nBeispiel 11.15 (Selektieren durch mehrfaches Ausschliessen)  \nstichprobe |&gt;\n    select(- c(q00_demo_gen, q00_demo_studyload)) |&gt;\n    head()\n\nDiese Vektorenauswahl wählt alle Vektoren ausser das Geschlecht und das Studienmodell.\n\n\n11.5.3 Vektoren mit ähnlichen Namen auswählen\nDrei leistungsfähige Hilfsfunktionen für select() sind:\n\nstarts_with(),\nends_with() sowie\ncontains()\n\nDiesen Funktionen akzeptieren einen Teilnamen, über den mehrere Vektoren ausgewählt werden, in denen der angegebene Teil im Vektornamen vorkommt.\nDiese Funktionen lassen sich mittels der iris-Stichprobe veranschaulichen.\n\nBeispiel 11.16 (Selektieren mit starts_with())  \n\niris |&gt;\n    select(starts_with(\"Sepal\")) |&gt;  # wählt die Vektoren Sepal.Width und Sepal.Length aus\n    head()\n\n  Sepal.Length Sepal.Width\n1          5.1         3.5\n2          4.9         3.0\n3          4.7         3.2\n4          4.6         3.1\n5          5.0         3.6\n6          5.4         3.9\n\n\n\n\nBeispiel 11.17 (Selektieren mit ends_with())  \n\niris |&gt;\n    select(ends_with(\"Length\")) |&gt; # wählt die Vektoren Petal.Length und Sepal.Length aus\n    head()\n\n  Sepal.Length Petal.Length\n1          5.1          1.4\n2          4.9          1.4\n3          4.7          1.3\n4          4.6          1.5\n5          5.0          1.4\n6          5.4          1.7\n\n\n\n\n\n11.5.4 Alle Vektoren zwischen zwei benannten Vektoren auswählen\nEine weitere Möglichkeit schneller viele Vektoren auszuwählen ist der :-Operator. Damit können wir alle Vektoren zwischen zwei Vektoren inklusive der benannten Vektoren auswählen.\nDer folgende Aufruf veranschaulicht dies: ::: {#exm-select-range} ## Vektorenbereich selektieren\n\nstichprobe |&gt;\n    select(q00_demo_gen:q01_mob_typ) |&gt;\n    head()\n\n# A tibble: 6 × 3\n  q00_demo_gen q00_demo_studyload q01_mob_typ       \n  &lt;chr&gt;        &lt;chr&gt;              &lt;chr&gt;             \n1 Weiblich     Vollzeit           iPhone            \n2 Weiblich     Vollzeit           iPhone            \n3 Weiblich     Teilzeit           iPhone            \n4 Weiblich     Teilzeit           iPhone            \n5 Männlich     &lt;NA&gt;               Android Smartphone\n6 Weiblich     Vollzeit           iPhone            \n\n\n:::\nDiese Vektorenauswahl wählt die Vektoren q00_demo_gen, q00_demo_studyload und q01_mob_typ für das Ergebnis aus.\n\n\n\n\n\n\nWarnung\n\n\n\nDie Reihenfolge von Vektoren kann durch andere Transformationen geändert werden. Deshalb sollte das Selektieren mit Vektorbereichen vermieden werden."
  },
  {
    "objectID": "kapitel/boolsche-operationen/kapitel.html#sortieren",
    "href": "kapitel/boolsche-operationen/kapitel.html#sortieren",
    "title": "11  Boole’sche Operationen",
    "section": "11.6 Sortieren",
    "text": "11.6 Sortieren\nR erlaubt kein Sortieren über logische Ausdrücke. Es ist nur möglich, Werte nach vorgegebenen grösser-kleiner Beziehungen zu sortieren. Deshalb muss für komplexe Sortierungen ein numerischer Hilfsvektor erzeugt werden, der anschliessend sortiert werden kann.\nDie Werte eines Vektors werden mit sort() sortiert.\n\nBeispiel 11.18 (Vektorsortierung für zufällige Ganzzahlen)  \n\nset.seed(10)\nrunif(10, min = 1, max = 10) |&gt; trunc() |&gt; sort()\n\n [1] 1 3 3 3 3 4 4 5 6 7\n\n\n\nDie sort()-Funktion kann nur einzelne Vektoren sortieren. Das ist unpraktisch, wenn Daten in einem Datenrahmen vorliegen. In diesem Fall lassen sich die Datensätze mithilfe der Funktion arrange() sortieren. Der Funktion werden die Vektoren übergeben, über die eine neue Reihenfolge festgelegt werden soll. Standardmässig sortiert arrange() aufsteigend. Mit der Hilfsfunktion desc() (engl. descending = absteigen) werden Datensätze entsprechend der Werte im Sortiervektor absteigend sortiert.\n\nBeispiel 11.19 (Absteigende Datenrahmensortierung mit arrange())  \n\nmtcars |&gt;\n    as_tibble(rownames = \"model\") |&gt; \n    select(model, hp, disp, mpg, am) |&gt; \n    arrange(desc(hp)) |&gt; \n    head()\n\n# A tibble: 6 × 5\n  model                  hp  disp   mpg    am\n  &lt;chr&gt;               &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Maserati Bora         335   301  15       1\n2 Ford Pantera L        264   351  15.8     1\n3 Duster 360            245   360  14.3     0\n4 Camaro Z28            245   350  13.3     0\n5 Chrysler Imperial     230   440  14.7     0\n6 Lincoln Continental   215   460  10.4     0"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#konkatenation",
    "href": "kapitel/vektor-operationen/kapitel.html#konkatenation",
    "title": "12  Vektoroperationen",
    "section": "12.1 Konkatenation",
    "text": "12.1 Konkatenation\nVektoren werden in R mit der Funktion c() erzeugt (Beispiel 12.1).\n\nBeispiel 12.1 (Einen Vektor aus Skalaren erstellen)  \n\nvektor = c(2, 3, 1, 5, 4, 6)\nvektor\n\n[1] 2 3 1 5 4 6\n\n\n\nDie Funktion c() dient nicht nur zum erzeugen von Vektoren, sondern auch zur Konkatenation von Vektoren (Beispiel 12.2). Anders als mit der list-Funktion, können mit der c()-Funktion keine komplexen Datenstrukturen erzeugt werden.\n\nBeispiel 12.2 (Konkatenation von Vektoren)  \n\nc(vektor, c(6, 7))\n\n[1] 2 3 1 5 4 6 6 7\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nDie Funktion c() sollte nur zur Konkatenation von alleinstehenden Vektoren eingesetzt werden und nie für Vektoren, die zu einem Datenrahmen gehören!"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#vektorlänge",
    "href": "kapitel/vektor-operationen/kapitel.html#vektorlänge",
    "title": "12  Vektoroperationen",
    "section": "12.2 Vektorlänge",
    "text": "12.2 Vektorlänge\nDie Länge eines R-Vektors wird mit der Funktion length() bestimmt. Diese Funktion liefert immer eine ganze Zahl mit der Anzahl der Vektorelemente (Beispiel 12.3).\n\nBeispiel 12.3 (Vektorlänge bestimmen)  \n\nc(1, 3, 2, 4) |&gt; length()\n\n[1] 4\n\n\n\nR kennt den leeren Vektor. Dieser Vektor hat die Länge 0. Er wird durch den argumentlosen Aufruf der Funktion c() erzeugt (Beispiel 12.4).\n\nBeispiel 12.4 (Vektorlänge des leeren Vektors)  \n\nc() |&gt; length()\n\n[1] 0"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#wertereferenzierung",
    "href": "kapitel/vektor-operationen/kapitel.html#wertereferenzierung",
    "title": "12  Vektoroperationen",
    "section": "12.3 Wertereferenzierung",
    "text": "12.3 Wertereferenzierung\nJeder Wert in einem Vektor hat eine eindeutige Position. Der erste Wert hat die Position 1 und alle weiteren Positionen sind fortlaufend nummeriert. Der Wert der Position wird auch als Vektorindex bezeichnet.\nDer Index eines Vektors wird in eckigen Klammern (bzw. Blockklammern: [ und ]) gerahmt angegeben. Die Blockklammern sind R’s Indexoperator. Ein Index wird als Referenz für einen Wert verwendet. Ein Wert in einem Vektor wird über den Index referenziert.\nEs werden drei Varianten der Wertereferenzierung unterschieden. Alle Varianten sind gleichwertig, dürfen aber nicht gemischt werden.\n\nDie Indexreferenz\nDie negative Indexreferenz\nDie Referenz mit Wahrheitsvektoren\n\n\n12.3.1 Indexreferenz\n\nBeispiel 12.5 (Index eines Vektors)  \n\nvektor[2]\n\n[1] 3\n\n\n\nWeil alle Werte gleichzeitig Vektoren sind, können Indizes ebenfalls als Vektoren angegeben werden, um mehrere Vektorwerte gleichzeitig abzufragen. Der Ergebnisvektor enthält die Werte in der Reihenfolge\n\n\n\n\n\n\nAchtung\n\n\n\nWerden ungültige Indizes angegeben, füllt R diese nicht existierenden Werte mit NA auf.\n\n\n\nBeispiel 12.6 (Vektorwerte über einen Indexvektor abfragen)  \n\nvektor[c(2, 7, 4)]\n\n[1]  3 NA  5\n\n\n\nEin Indexvektor kann länger als der Wertevektor sein, ausserdem können Indexwerte wiederholt werden. Dadurch lassen sich Vektoren systematisch erzeugen.\n\nBeispiel 12.7 (Vektorwerte über einen Indexvektor wiederholt abfragen)  \n\nvektor[c(2, 4, 4, 2)]\n\n[1] 3 5 5 3\n\n\n\n\n\n12.3.2 Negative Indexreferenz\nAlternativ können negative Indizes verwendet werden. Das Vorzeichen bedeutet in diesem Fall “ausser”. Es werden also alle Indizes, ausser dem angegebenen, zurückgegeben (Team et al., 2023).\n\n\n\n\n\n\nAchtung\n\n\n\nNegative und positive Indizes dürfen nicht gemischt werden!\n\n\n\n\n\n\n\n\nJargon\n\n\n\nDiese Verwendung von negativen Referenzen ist eine Eigenheit von R und wird in den meisten anderen Programmiersprachen nicht bzw. nicht so unterstützt.\n\n\n\nBeispiel 12.8 (Negative Indizes)  \n\nvektor[-2]\n\n[1] 2 1 5 4 6\n\n\n\n\n\n12.3.3 Referenz durch Wahrheitsvektoren\nDie letzte Variante des Wertezugriffs ist der Zugriff mit einem Wahrheitsvektor. Ein Wahrheitsvektor zum Wertezugriff muss die gleiche Länge haben, wie der Wertevektor. Das Ergebnis dieser Operation ist ein Vektor, der nur Werte enthält, die an den Positionen stehen, an welchen im Wahrheitsvektor TRUE steht.\n\nBeispiel 12.9 (Negative Indizes)  \n\nvektor[c(TRUE, FALSE, TRUE, FALSE, TRUE)]\n\n[1] 2 1 4 6\n\n\n\nDiese Art des Wertereferenzierung wird häufig mit einer Transformation (Abschnitt 12.6) als Teil eines logischen Ausdrucks kombiniert. Beispiel 12.10 referenziert nur die gereaden Werte in vektor.\n\n\n\n\n\n\nMerke\n\n\n\nDas Referenzieren mit einem logischen Ausdruck ist eine Variante des Filterns.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nDas Filtern durch Referenzieren sollte nur für alleinstehende Vektoren eingesetzt werden. Zum Filtern von Vektoren in Datenrahmen sollte immer die dplyr-Funktion filter() verwendet werden.\n\n\n\nBeispiel 12.10 (Gerade Werte aus einem Vektor auswählen)  \n\nvektor[vektor %% 2 == 0]\n\n[1] 2 4 6"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#sequenzen",
    "href": "kapitel/vektor-operationen/kapitel.html#sequenzen",
    "title": "12  Vektoroperationen",
    "section": "12.4 Sequenzen",
    "text": "12.4 Sequenzen\nSequenzen werden mit der Funktion seq() erstellt. Die Funktion hat fünf Parameter. Die drei wichtigsten Parameter sind:\n\nfrom: Der Initialwert der Sequenz.\nlength: Die Länge der Sequenz.\nby: Die Schrittweite der Sequenz.\n\nNeben diesen Parameter gibt es noch die beiden Parameter:\n\nto: Der Endwert der Sequenz\nalong.with: Übernimmt die Länge der Sequenz der Länge des angegebenen Vektors.\n\n\nBeispiel 12.11 (Sequenzen erstellen)  \n\nseq(5) # seq(length = 5)\n\n[1] 1 2 3 4 5\n\nseq(2, 5) # seq(from = 2, to = 5)\n\n[1] 2 3 4 5\n\nseq(from = 2, length = 5, by = 2)\n\n[1]  2  4  6  8 10\n\n\n\nNeben der seq()-Funktion kennt R den Sequenzoperator :. Die Operanden des Squenzoperators sind der Initial- und Endwert, wobei eine Schrittweite von 1 angenommen wird (Beispiel 12.12).\n\nBeispiel 12.12 (Sequenzoperator verwenden)  \n\n3:8  # identisch mit seq(from = 3, to = 8, by = 1)\n\n[1] 3 4 5 6 7 8"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#wiederholungen",
    "href": "kapitel/vektor-operationen/kapitel.html#wiederholungen",
    "title": "12  Vektoroperationen",
    "section": "12.5 Wiederholungen",
    "text": "12.5 Wiederholungen\nVektoren mit gleichen Werten an allen Positionen können als Sequenzen mit der Schrittweite von 0 verstanden werden. Genauso lassen sich solche Vektoren als Wiederholungen eines Werts beschreiben. Diesen Weg geht R mit der rep()-Funktion (rep für engl. repeat).\nDie rep()-Funktion hat zwei Parameter:\n\nx: Der Wiederholungswert\nlength: Die Länge des Zielvektors\n\nMit dieser Funktion lassen sich Vektoren wie der Nullvektor oder der Einsvektor leicht erzeugen (Beispiel 12.13).\n\nBeispiel 12.13 (Null- und Einsvektor der Länge fünf erzeugen)  \n\nrep(0, 5)\n\n[1] 0 0 0 0 0\n\nrep(1, 5)\n\n[1] 1 1 1 1 1\n\n\n\nWeil die Datengrundstruktur in R Vektoren sind, können Vektoren mit der rep()-Funktion vervielfacht werden. So lassen sich Vektoren mit Wertemustern erzeugen (Beispiel 12.14).\n\nBeispiel 12.14 (Mustervektor erzeugen)  \n\nrep(c(1,0), 3)\n\n[1] 1 0 1 0 1 0"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#sec-transformationen",
    "href": "kapitel/vektor-operationen/kapitel.html#sec-transformationen",
    "title": "12  Vektoroperationen",
    "section": "12.6 Transformationen",
    "text": "12.6 Transformationen\nVektortransformationen bedeuten in R das wiederholte Ausführen einer Funktion für jeden Wert eines Vektors. Alle arithmetischen, logischen und Vergleichsoperatoren sind automatisch Vektortransformationen (Beispiel 12.15).\n\nBeispiel 12.15 (Einfache Vektortransformationen)  \n\n# Arithmetische Operationen\nvektor + 4\n\n[1]  6  7  5  9  8 10\n\nvektor %% 2\n\n[1] 0 1 1 1 0 0\n\n# Logische und Vergleichsoperationen\nvektor &lt;= 3\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\n2 &lt; vektor & vektor &lt; 5\n\n[1] FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n\n\nEine Besonderheit von R ist die Verallgemeinerung von Skalaroperationen auf Vektoren mit unterschiedlicher Länge. Dabei wird der kürzere Vektor auf die Länge des längeren Vektors durch Wiederholung erweitert, so dass eine Vektortransforamtion möglich wird (Beispiel 12.16). Bei einer Vektortransformation werden die Werte an den gleichen Positionen aus zwei Vektoren paarweise miteinander verknüpft.\n\nBeispiel 12.16 (Erweiterte Vektortransformationen)  \n\nvektor\n\n[1] 2 3 1 5 4 6\n\nvektor + 4 # vektor + rep(4, length(vektor))\n\n[1]  6  7  5  9  8 10\n\nvektor + c(1, 2) # vektor + rep(c(1, 2), 3)\n\n[1] 3 5 2 7 5 8\n\n\n\nIm Beispiel 12.16 werden Vektoren mit Längen, die Vielfache des kürzesten Vektors sind. Dadurch ist sichergestellt, dass keine überzähligen Werte bleiben. Die Wiederholung des kürzeren Vektors wird auch dann ausgeführt, wenn die Vektorenlängen keine Vielfachen voneinander sind. Dabei wird die Operation nur für alle die Werte im ursprünglich längsten Vektor ausgeführt. Dadurch bleiben nicht verwendete Werte im wiederholten Vektor. Diese überbleibenden Werte erzeugen eine Warnmeldung (Beispiel 12.17).\n\nBeispiel 12.17 (Unvollständige Vektortransformationen)  \n\nvektor\n\n[1] 2 3 1 5 4 6\n\nvektor + c(1, 2, 3, 4, 5) # vektor + c(1, 2, 3, 4, 5, 1)\n\nWarning in vektor + c(1, 2, 3, 4, 5): Länge des längeren Objektes\n     ist kein Vielfaches der Länge des kürzeren Objektes\n\n\n[1] 3 5 4 9 9 7\n\n\n\nDie Vektoroperationen von R sind sehr flexibel und leistungsfähig. Allerdings lassen sich auch damit nicht alle beliebigen Vektortransformationen durchführen.\n\n\n\n\n\n\nMerke\n\n\n\nBeliebige Transformationen lassen sich mit map() aus der Bibliothek purrr() umsetzen.\n\n\nDie map()-Funktion hat immer eine Liste als Ergebnis einer Vektortransforamtion. Der eigentliche Vektor ist in dieser Liste geschachtelt und muss mit unlist() extrahiert werden (Beispiel 8.22)."
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#aggregationen",
    "href": "kapitel/vektor-operationen/kapitel.html#aggregationen",
    "title": "12  Vektoroperationen",
    "section": "12.7 Aggregationen",
    "text": "12.7 Aggregationen\nAggregationen fassen mehrere Werte eines Vektors zusammen.Das Ergebnis ist ein Vekter, der höchstens so lang ist, wie der aggregierte Vektor. Alle Aggregationen werden in R durch Funktionen realisiert. Eine solche Funktion heisst Aggregator.\nHäufig verwendete Aggregatoren sind:\n\nsum(), zum Addieren aller Werte eines Vektors.\nmean(), zur Mittelwertbildung.\nmax(), zum Finden des grössten Werts eines numerischen Vektors\nmin(), zum Finden des kleinsten Werts eines numerischen Vektors\n\nDas Filtern ist eine spezielle Aggregation, die zu einem neuen und oft kürzeren Vektor führt. Das Filtern von Werten eines einzelnen Vektors erfolgt über die Wertereferenzierung mit einem logischen Ausdruck (Beispiel 12.10).\nFür häufig verwendete Aggregationen finden sich in R eigene Funktionen. Sollte eine spezielle Aggregation ausnahmsweise nicht existieren, dann kann eine spezieller Aggregator implementiert werden.\n\n\n\n\n\n\nMerke\n\n\n\nBeliebige Vektoraggregationen lassen sich mit reduce() aus der Bibliothek purrr umsetzen.\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nImplementieren Sie keinen Aggregator, falls eine entsprechende Funktion bereits existiert. Die meisten vordefinierten Aggregatoren sind effizienter umgesetzt, als es mit einer naiven Umsetzung in R möglich wäre.\n\n\nBeim Reduzieren wird eine Reduktionsfunktion nacheinander auf die Werte eines Vektors ausgeführt, wobei das Zwischenergebnis im nächsten Schritt als Argument verwendet wird.\nDie reduce()-Funktion erwartet einen Vektor .x und eine Reduktionsfunktion .f als Parameter. Die Reduktionsfunktion ist eine zwei-parametrige Funktion (bzw. Operator), wobei der erste Parameter als Akkumulator bezeichnet wird und das Zwischenergebnis des vorangegangenen Reduktionsschritts enthält.\n\nBeispiel 12.18 (Summe als Reduktion)  \n\nvektor |&gt; reduce(function(acc, wert) { acc + wert }) \n\n[1] 21\n\n# oder kürzer \nvektor |&gt; reduce(`+`)\n\n[1] 21\n\n\n\nFalls die Reduktionsfunktion auch für den ersten Wert in einem Vektor ausfgeführt werden soll, muss zusätzlich ein Initialwert angegeben werden. Typische Initialwerte für eine Reduktionsfunktion sind die neutralen Elemente der wichtigsten Operationen:\n\n0 (neutrales Element der Addition)\n1 (neutrales Element der Multiplikation)\nTRUE (neutrales Element des logischen Und)\nFALSE (neutrales Element des logischen Oder)\n\"\" (leere Zeichenkette, neutrales Element der Textverkettung)\nc() (leerer Vektor, neutrales Element der Konkatenation)\n\nEine spezielle Form der Reduktion steht mit der purrr-Funktion accumulate(). Während reduce() nur das Endergebnis der Reduktion liefert, gibt accumulate() auch die Zwischenergebnisse. Das Ergebnis der accumulate() Funktion ist immer ein Vektor mit der gleichen Länge wie der ursprüngliche Vektor.\n\nBeispiel 12.19 (Laufende Summe als Reduktion mit accumulate())  \n\nvektor |&gt; accumulate(`+`)\n\n[1]  2  5  6 11 15 21"
  },
  {
    "objectID": "kapitel/vektor-operationen/kapitel.html#zählen",
    "href": "kapitel/vektor-operationen/kapitel.html#zählen",
    "title": "12  Vektoroperationen",
    "section": "12.8 Zählen",
    "text": "12.8 Zählen\nMit der Funktion length() lassen sich die Werte in einem Vektor zählen.\n\n\n\n\n\n\nHinweis\n\n\n\nIn der Literatur wird das Zählen von Werten regelmässig hinter komplexen Algorithmen verborgen. Gelegentlich müssen Werte als Teil einer komplexen Analyse gezählt werden. Um unnötigen Code zu vermeiden oder um übermässig komplexe formulierte Arbeitsschritte zu erkennen, ist es notwendig die wichtigsten Varianten des Zählens zu kennen.\n\n\n\n12.8.1 Zählen durch Summieren\nBeim Zählen durch Summieren werden zählbare Einheiten durch eine 1 markiert und von nicht-zählbaren Einheiten getrennt, die mit einer 0 markiert wurden. Dadurch entsteht ein Vektor, der nur aus den Werten 0 und 1 besteht. Durch das Bilden der Summe ergibt sich die Anzahl der zählbaren Elemente.\nDer erste Schritt lässt sich durch einen logischen Ausdruck umsetzen. Der zweite Schritt wird mit R’s Summe-Funktion sum().\n\n(vektor &gt; 3) |&gt; sum()\n\n[1] 3\n\n\n\n\n12.8.2 Zählen durch Filtern\nBeim Zählen durch Filtern werden die zählbaren Einheiten in einem separaten Vektor isoliert. Anschliessend muss nur die Länge dieses Vektors ermittelt werden.\n\nvektor[vektor &gt; 3] |&gt; length()\n\n[1] 3\n\n\n\n\n12.8.3 Zählen durch Nummerieren\nBeim Zählen durch Nummerieren wird ein zweiter Vektor mit den Nummern der zählbaren Einheiten verwendet. Das Maximum der Nummerierung entspricht der Anzahl der nummerierten Elemente.\n\nvektor2 = 1 : length(vektor)\n\nmax(vektor2)\n\n[1] 6\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nIn der Regel wird dieser Vektor nicht für das Zählen neu erzeugt. Stattdessen wird dieser Vektor oft für eine andere Operation erzeugt und zum Zählen wiederverwendet.\n\n\n\n\n\n\nTeam, R. C., Maechler, M., Gentleman, R., Ihaka, R., Venables, W. N., & Smith, D. M. (2023). An Introduction to R. https://cran.r-project.org/doc/manuals/R-intro.html"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrizen-erstellen",
    "href": "kapitel/matrix-operationen/kapitel.html#matrizen-erstellen",
    "title": "13  Matrix-Operationen",
    "section": "13.1 Matrizen erstellen",
    "text": "13.1 Matrizen erstellen\nEine Matrix wird in R mit der Funktion matrix() erstellt. Diese Funktion erwartet einen Vektor als erstes Argument. Zusätzlich muss mit ncol oder nrow angegeben werden, wie viele Spalten bzw. Zeilen die Matrix haben soll. Der optionale Paramter byrow zeigt an, ob die Werte zeilen- oder spaltenweise in die Matrix übernommen werden sollen. Die Zeilenschreibweise erleichtert die Eingabe einer Matrix (Beispiel 13.1).\n\nBeispiel 13.1 (Matrix in Zeilenschreibweise erzeugen)  \n\n( # Diese Klammer gibt das Ergebnis der Operation aus.\n    matrixA = matrix( \n    c( \n        1, 2, 3,\n        3, 2, 1\n    ), ncol = 3, nrow = 2, byrow = TRUE)\n)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    3    2    1\n\n\n\nIst die Länge des Eingabevektors grösser als die gewünschten Zeilen- oder Spaltenanzahl erlauben, dann werden alle überzähligen Werte verworfen (Beispiel 13.2) und eine Warnung erzeugt.\n\n\n\n\n\n\nPraxis\n\n\n\nEs muss nur die Anzahl der Spalten oder der Zeilen beim Erzeugen einer Matrix angegeben werden. Der jeweils andere Wert wird aus der Länge und dem angegebenen Wert ermittelt.\n\n\n\nBeispiel 13.2 (Matrix mit überlangem Eingabevektor erzeugen)  \n\nmatrix( \n    c( \n        1, 2, 3,\n        3, 2, 1,\n        4, 5, 6\n    ), ncol = 3, nrow = 2, byrow = TRUE)\n\nWarning in matrix(c(1, 2, 3, 3, 2, 1, 4, 5, 6), ncol = 3, nrow = 2, byrow =\nTRUE): Datenlänge [9] ist kein Teiler oder Vielfaches der Anzahl der Zeilen [2]\n\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    3    2    1\n\n\n\nIst die Länge des Eingabevektors kürzer als für eine Matrix mit den gewünschten Dimensionen notwendig wäre, dann wird der Vektor wie bei einer Vektortransformation solange wiederholt, bis alle Positionen in der Matrix besetzt sind (Beispiel 13.3). Ist der Vektor kein Vielfaches der Zeilen- oder der Spaltenzahl, dann werden alle überzähligen Werte mit einer entsprechenden Warnung verworfen.\n\nBeispiel 13.3 (Matrix durch Auffüllen des Eingabevektors erzeugen)  \n\nmatrix( \n    c( \n        1, 2, 3\n    ), ncol = 4, nrow = 3, byrow = TRUE)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    1\n[2,]    2    3    1    2\n[3,]    3    1    2    3\n\n\n\n\n13.1.1 Identitätsmatrix erzeugen\nDie Identitätsmatrix ist eine quadratische Diagonalmatrix, wobei an allen Positionen der Hauptdiagonalen der Wert 1 steht. Diese Matrix wird in R mit der Funktion diag() erzeugt (Beispiel 13.4).\n\nBeispiel 13.4 (5x5 Identitätsmatrix)  \n\ndiag(5)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrixdimensionen",
    "href": "kapitel/matrix-operationen/kapitel.html#matrixdimensionen",
    "title": "13  Matrix-Operationen",
    "section": "13.2 Matrixdimensionen",
    "text": "13.2 Matrixdimensionen\nDie Länge einer Matrix entspricht der Anzahl der Positionen in der Matrix und kann wie bei Vektoren mit der Funktion length() ermittelt werden. Diese Information ist jedoch nicht sehr nützlich.\nDie Dimensionalität einer Matrix wird mit der Funktion dim() ausgegeben. Das Ergebnis dieser Funktion gibt einen Vektor der Länge 2 zurück. Das erste Element dieses Vektors enthält die Anzahl der Zeilen und das zweite Element enthält die Anzahl der Spalten der Matrix.\n\nBeispiel 13.5 (Matrixdimensionen mit dim() abfragen)  \n\nmatrixA |&gt; dim()\n\n[1] 2 3\n\n\n\nDie beiden Werte können separat mit den beiden Funktionen nrow() und ncol() abgefragt werden.\n\nBeispiel 13.6 (Matrixdimensionen mit nrow() und ncol() abfragen)  \n\nmatrixA |&gt; nrow()\n\n[1] 2\n\nmatrixA |&gt; ncol()\n\n[1] 3"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrixwerte-referenzieren",
    "href": "kapitel/matrix-operationen/kapitel.html#matrixwerte-referenzieren",
    "title": "13  Matrix-Operationen",
    "section": "13.3 Matrixwerte referenzieren",
    "text": "13.3 Matrixwerte referenzieren\nDas Referenzieren von Werten einer Matrix erfolgt analog zum Referenzieren von Vektorwerten. Der Index eines Werts einer Matrix ist über die Zeilen und die Spalten definiert.\n\nBeispiel 13.7 (Matrixwerte referenzieren)  \n\nmatrixA[2,1]\n\n[1] 3\n\n\n\nÜber diese Notation ist es möglich eine ganze Zeile oder eine ganze Spalte einer Matrix zu referenzieren.\n\nBeispiel 13.8 (Matrixspalten und -zeilen referenzieren)  \n\nmatrixA[2,]  # Zeile 2\n\n[1] 3 2 1\n\nmatrixA[, 2] # Spalte 2\n\n[1] 2 2\n\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nEine Matrix bleibt im Hintergrund eine Vektorstruktur. Wird der Separator zwischen den Zeilen- und Spaltenindex weggelassen und nur ein Index angegeben, dann behandelt R die Matrix als Vektor in der spaltenweisen Form. Die Reihenfolge der Werte kann mit der Funktion as.vector() angezeigt werden. Das gleiche gilt für die Verwendung der Konkatenation ohne das dimensionstrennende Komma.\n\nmatrixA |&gt; as.vector()\n\n[1] 1 3 2 2 3 1\n\nmatrixA[2,3]\n\n[1] 1\n\nmatrixA[c(2,3)] \n\n[1] 3 2\n\nmatrixA[,c(2,3)]\n\n     [,1] [,2]\n[1,]    2    3\n[2,]    2    1\n\n\n\n\n\n13.3.1 Zeilen- und Spaltenüberschriften\nDie Zeilen- und Spalten einer Matrix können in R mit Überschriften benannt werden. Das Benennen erfolgt über einen sog. Namensvektor. Diese Vektor muss die gleiche Länge haben, wie die Anzahl der zu benennenden Zeilen bzw. Spalten der Matrix, wobei die Zeilen und Spalten nicht gleichzeitig benannt werden können.\n\n\n\n\n\n\nMerke\n\n\n\nDie Zeilen- und Spaltennamen gehören nicht zu den Werten einer Matrix und werden in Operationen in der Regel nicht berücksichtigt.\n\n\n\nBeispiel 13.9 (Zeilennamen zuweisen)  \n\nrownames(matrixA) &lt;- c(\"oben\", \"unten\")\ncolnames(matrixA) &lt;- c(\"links\", \"mitte\", \"rechts\")\n\nmatrixA\n\n      links mitte rechts\noben      1     2      3\nunten     3     2      1\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nGrundsätzlich kann auch die Funktionsverkettung beim Benennen der Zeilen oder Spalten einer Matrix verwendet werden.\nmatrixA |&gt; rownames() &lt;- c(\"oben\", \"unten\")\nDiese Verwendung sollte allerdings vermieden werden, weil die Zuweisung und der Datenstrom in diesen Fällen gegenläufig wären.\n\n\nNachdem eine Zeile oder eine Spalte benannt wurde, werden die Namen in allen nachfolgenden Zugriffen immer in das Ergebnis aufgenommen. Ausserdem können die Namen zur Referenzierung der Werte verwendet werden (Beispiel 13.10).\n\nBeispiel 13.10 (Zeilennamen zur Rerferenzierung verwenden)  \n\nmatrixA[\"oben\",]\n\n links  mitte rechts \n     1      2      3 \n\nmatrixA[\"unten\", \"mitte\"]\n\n[1] 2\n\n\n\nEs ist möglich einzelne Zeilen- oder Spaltennamen zuzuweisen oder zu ändern (Beispiel 13.11).\n\nBeispiel 13.11 (Zeilennamen ändern)  \n\ncolnames(matrixA)[2] &lt;- \"zentrum\"\n\nmatrixA\n\n      links zentrum rechts\noben      1       2      3\nunten     3       2      1\n\n\n\nDie Namen einer Matrix lassen sich entfernen, indem den Zeilen- oder Spaltennamen der Wert NULL zugewiesen wird.\n\nBeispiel 13.12 (Zeilennamen entfernen)  \n\nrownames(matrixA) &lt;- NULL\ncolnames(matrixA) &lt;- NULL\n\nmatrixA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    3    2    1"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#matrizen-transponieren",
    "href": "kapitel/matrix-operationen/kapitel.html#matrizen-transponieren",
    "title": "13  Matrix-Operationen",
    "section": "13.4 Matrizen transponieren",
    "text": "13.4 Matrizen transponieren\nBeim Transponieren einer Matrix werden die Indizes für alle Werte vertauscht. Diese Operation übernimmt die R-Funktion t().\n\nBeispiel 13.13 (Eine Matrix transponieren)  \n\nmatrixA |&gt; t()\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    2\n[3,]    3    1\n\n\n\n\n\n\n\n\n\nMerke\n\n\n\nBeim Transponieren einer Matrix werden die Spalten in Zeilen bzw. die Zeilen in Spalten umgewandelt.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nBeim Transponieren werden vorhandene Zeilen- und Spaltennamen mittransponiert."
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#vektorform",
    "href": "kapitel/matrix-operationen/kapitel.html#vektorform",
    "title": "13  Matrix-Operationen",
    "section": "13.5 Vektorform",
    "text": "13.5 Vektorform\nMatrizen kennen zwei Arten der Vektorform:\n\nDie spaltenweise Vektorform, bei der die Spaltenvektoren einer Matrix zu einem Vektor konkateniert werden.\nDie zeilenweise Vektorform, bei der die Zeilenvektoren einer Matrix zu einem Vektor konkateniert werden.\n\nR speichert eine Matrix intern in ihrer spaltenweisen Vektorform. Die spaltenweise Vektorform kann also direkt über die Funktion as.vector() ermittelt werden. Das gleiche Ergebnis wird erzeugt, wenn die Matrix der Vektorkonkatenation c() als Argument übergeben wird (Beispiel 13.14).\n\n\n\n\n\n\nPraxis\n\n\n\nWeil bei der Verwendung der Funktion c() nicht leicht ersichtlich ist, dass die Vektorform ermittelt wird, sollte für diese Operation immer die Funktion as.vector() verwendet werden.\n\n\n\nBeispiel 13.14 (Spaltenweise Vektorform einer Matrix)  \n\nmatrixA |&gt; as.vector()\n\n[1] 1 3 2 2 3 1\n\nmatrixA |&gt; c()\n\n[1] 1 3 2 2 3 1\n\n\n\nBeim Umwandeln einer Matrix in ihre zeilenweise Vektorform wird in R ausgenutzt, dass diese Vektorform identisch mit der spaltenweisen Vektorform ihrer transponierten Matrix ist. Diese Gleichheit ergibt sich aus dem Transponieren, bei der Zeilen in Spalten umgewandelt werden (Beispiel 13.15).\n\nBeispiel 13.15 (Zeilenweise Vektorform einer Matrix)  \n\nmatrixA |&gt; t() |&gt; as.vector()\n\n[1] 1 2 3 3 2 1\n\nmatrixA |&gt; t() |&gt; c()\n\n[1] 1 2 3 3 2 1"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#skalar--und-vektortransformationen",
    "href": "kapitel/matrix-operationen/kapitel.html#skalar--und-vektortransformationen",
    "title": "13  Matrix-Operationen",
    "section": "13.6 Skalar- und Vektortransformationen",
    "text": "13.6 Skalar- und Vektortransformationen\nBei Skalartransformationen wird ein einzelner Wert mit jedem Wert in der Matrix verknüpft.\n\nBeispiel 13.16 (Skalaraddition mit einer Matrix)  \n\n2 * matrixA\n\n     [,1] [,2] [,3]\n[1,]    2    4    6\n[2,]    6    4    2\n\n\n\nDieses Prinzip lässt sich auf Vektoren und Matrizen verallgemeinern. Bei Vektoren muss der Vektor die gleiche Länge wie die Zeilen der Matrix haben. Der Vektor wird dann spaltenweise mit der Matrix verknüpft (Beispiel 13.17).\n\nBeispiel 13.17 (Vektoraddition mit einer Matrix)  \n\nmatrixA + 1:2\n\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    5    4    3\n\n\n\n\n\n\n\n\n\nAchtung!\n\n\n\nHat der Vektor keine passende Länge, dann wird die Länge des Vektors durch Wiederholung an die Länge der Matrix angepasst. Die Transformation erfolgt in diesem Fall wie eine Vektortransformation, wobei die Zeilen- und Spaltenstruktur der Matrix erhalten bleibt (Beispiel 13.18).\n\n\n\nBeispiel 13.18 (Vektoraddition mit einer Matrix und einem inkompatiblen Vektor)  \n\nmatrixA + 1:3\n\n     [,1] [,2] [,3]\n[1,]    2    5    5\n[2,]    5    3    4\n\n\n\nFür die Transformation einer Matrix mit einer anderen Matrix mit R müssen beide Matrizen die gleiche Dimensionalität haben. Ist diese Voraussetzung gegeben, dann werden die Werte mit dem gleichen Index paarweise miteinander verknüpft (Beispiel 13.19).\n\n\n\n\n\n\nAchtung!\n\n\n\nWerden zwei Matrizen unterschiedlicher Dimensionalität verknüpft, dann erweitert R die kleinere der beiden Matrizen nicht!\n\n\n\nBeispiel 13.19 (Verknüpfung von zwei Matrizen)  \n\nmatrixB = matrix(c(1, 2, 2, 1, 1, 2), nrow = 2)\n\nmatrixA + matrixB\n\n     [,1] [,2] [,3]\n[1,]    2    4    4\n[2,]    5    3    3\n\n\n\n\n13.6.1 Matrizen vergleichen\nUm die Gleichheit zwischen zwei Matrizen zu vergleichen, müssen zwei Bedingungen erfüllt sein:\n\nDie Länge der beiden Matrizen muss gleich sein.\nDie Dimensionalität der beiden Matrizen muss gleich sein.\nAn allen Positionen müssen die Werte gleich sein.\n\nDiese Prüfung übernimmt in R die Funktion all.equal(). Damit diese Funktion in logischen Ausdrücken verwendet werden kann, muss der Wert an der ersten Position des Ergebnisvektors ausgewertet werden, weil diese Funktion alle Unterschiede zwischen zwei Matrizen zurückgibt (Beispiel 13.20).\n\nBeispiel 13.20 (Zwei Matrizen vergleichen)  \n\nall.equal(matrixA, matrixB)\n\n[1] \"Attributes: &lt; Length mismatch: comparison on first 1 components &gt;\"\n[2] \"Mean relative difference: 0.5555556\"                              \n\n# Für logische Ausdrücke\nall.equal(matrixA, matrixB)[1] == TRUE\n\n[1] FALSE"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#kreuzprodukt",
    "href": "kapitel/matrix-operationen/kapitel.html#kreuzprodukt",
    "title": "13  Matrix-Operationen",
    "section": "13.7 Kreuzprodukt",
    "text": "13.7 Kreuzprodukt\nDas Kreuzprodukt (oder Matrixmultiplikation) ist eine Erweiterung der bekannten Multiplikation für Matrizen. Beim Kreuzprodukt muss die linke Matrix genausoviele Spalten haben, wie Zeilenanzahl der rechten Matrix. Das Kreuzprodukt ist dann wie folgt definiert:\n\n\\begin{aligned}\nA \\times B &= \\begin{bmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\cdots & a_{mn} \\\\\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nb_{11} & b_{12} & \\cdots & b_{1p} \\\\\nb_{21} & b_{22} & \\cdots & b_{2p} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nb_{n1} & b_{n2} & \\cdots & b_{np} \\\\\n\\end{bmatrix} \\\\\\\n\\\\\\\n&= \\begin{bmatrix}\n\\sum_{i=1}^{n}{a_{1i} \\cdot b_{i1}} & \\sum_{i=1}^{n}{a_{1i} \\cdot b_{i2}} & \\cdots & \\sum_{i=1}^{n}{a_{1i} \\cdot b_{ip}} \\\\\n\\sum_{i=1}^{n}{a_{2i} \\cdot b_{i1}} & \\sum_{i=1}^{n}{a_{2i} \\cdot b_{i2}} & \\cdots & \\sum_{i=1}^{n}{a_{2i} \\cdot b_{ip}} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\sum_{i=1}^{n}{a_{mi} \\cdot b_{i1}} & \\sum_{i=1}^{n}{a_{mi} \\cdot b_{i2}} & \\cdots & \\sum_{i=1}^{n}{a_{mi} \\cdot b_{ip}} \\\\\n\\end{bmatrix}\n\\end{aligned}\n\nIn R wird das Kreuzprodukt mit dem %*%-Operator durchgeführt.\n\nmatrixA \n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    3    2    1\n\n(matrixC = matrix(\n    c(3, 2, 2, 3, \n      1, 2, 3, 1, \n      1, 2, 1, 1), \n    ncol = 4, \n    byrow = TRUE)\n)\n\n     [,1] [,2] [,3] [,4]\n[1,]    3    2    2    3\n[2,]    1    2    3    1\n[3,]    1    2    1    1\n\nmatrixA %*% matrixC\n\n     [,1] [,2] [,3] [,4]\n[1,]    8   12   11    8\n[2,]   12   12   13   12\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nWerden mehrere Matrizen nacheinander multipliziert, so können bekannte Matrizen vorab miteinander multipliziert werden, wenn sie in der Berechnung direkt aufeinanderfolgen.\n\n\n\n13.7.1 Zeilen- und Spaltensummen\nFür die Zeilensumme ist ein Spaltenvektor notwendig. Dieser Vektor ist ein Einsvektor mit der Länge von der Anzahl der Matrixspalten. Wegen der Regeln für das Kreuzprodukt muss der Einsvektor der rechte Operand des Kreuzprodukts sein (Beispiel 13.21).\n\nBeispiel 13.21 (Zeilensumme)  \n\nmatrixA %*% rep(1, ncol(matrixA))\n\n     [,1]\n[1,]    6\n[2,]    6\n\n\n\nFür die Spaltensumme ist ein Zeilenvektor notwendig. Dieser Vektor ist ein Einsvektor mit der Länge von der Anzahl der Matrixzeilen. Weil R-Vektoren keine Orientierung haben, sondern immer als Spaltenvektoren behandelt werden, muss der Vektor noch transponiert werden. Bei der Zeilensumme ist ausserdem zu beachten, dass der Einsvektor der linke Operand des Kreuzprodukts sein muss (Beispiel 13.22).\n\nBeispiel 13.22 (Zeilensumme)  \n\nt(rep(1, nrow(matrixA))) %*% matrixA\n\n     [,1] [,2] [,3]\n[1,]    4    4    4"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#äusseres-vektorprodukt",
    "href": "kapitel/matrix-operationen/kapitel.html#äusseres-vektorprodukt",
    "title": "13  Matrix-Operationen",
    "section": "13.8 Äusseres Vektorprodukt",
    "text": "13.8 Äusseres Vektorprodukt\nDas äussere Vektorprodukt erlaubt es Matrizen aus den Werte von zwei Vektoren mit einem beliebigen Operators zu erzeugen. Im Gegensatz zum Kreuzprodukt ist die Orientierung der beiden Vektoren durch das äussere Produkt vorgegeben: Der zweite Vektor wird immer als Zeilenvektor angenommen.\nDer Operator des äusseren Produkts ist %o%, wobei als Verknüpfung die Multiplikation verwendet wird. Mit der Funktion outer() können beliebige Operatoren (d.h. Funktionen mit zwei Operatoren) angegeben werden.\n\nBeispiel 13.23 (Äusseres Produkt mit der Addition als Operator)  \n\nouter(1:3, 0:5, `+`)\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    2    3    4    5    6\n[2,]    2    3    4    5    6    7\n[3,]    3    4    5    6    7    8\n\n\n\nIn der Anwendung sind logische Ausdrücke als Operatoren für das äussere Produkt von besonderer Bedeutung. In R müssen alle logischen Ausdrücke, die nicht nur eine Vergleichsoperation umfassen, als Funktion der outer()-Funktion übergeben werden (s. Beispiel 13.25).\n\n\n\n\n\n\nPraxis\n\n\n\nMit dem äusseren Produkt über logische Ausdrücle lassen sich beliebige Matrizenstrukturen aus Sequenzen erzeugen.\n\n\n\n13.8.1 Dreieckmatrizen erzeugen\nDreiecksmatrizen werden in der Regel über das äussere Produkt zweier Sequenzen erzeugt. Es wird zwischen oberen und unteren Dreiecksmatrizen unterschieden. Bei einer oberen Dreiecksmatrix sind alle Positionen mit Zeilenindizes, welche kleiner als der jeweilige Spaltenindex sind, mit dem Wert 1 und alle anderen Position mit 0 belegt. Bei einer unteren Dreieckmatrix sind die Positionen mit dem Wert 1 belegt, an denen der Zeilenindex grösser als der Spaltenindex ist. Alternativ erzeugen die beiden Funktionen upper.tri() und lower.tri() die gewünschte Dreiecksmatrix aus einer existierenden Matrix.\n\nBeispiel 13.24 (Erzeugen einer unteren Dreiecksmatrix)  \n\n1 * outer(1:4, 1:4, `&gt;=`)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    1    1    0    0\n[3,]    1    1    1    0\n[4,]    1    1    1    1\n\n# etwas expressiver\n1 * lower.tri(diag(4), diag = TRUE)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    1    1    0    0\n[3,]    1    1    1    0\n[4,]    1    1    1    1\n\n\n\n\n\n13.8.2 Vorgänger- und Nachfolgersummen\nVorgänger- und Nachfolgersummen bilden die Summe aus aufeinanderfolgenden Werten eines Vektors. Diese Summe kann durch die Kombination einer Matrixmultiplikation mit dem äusseren Produkt errreicht werden. Für diese Summen wird eine Matrix benötigt, in welcher an allen zu summierenden Positionen der Wert 1 (das neutrale Element der Multiplikation) steht.\nBeispiel 13.25 bestimmt die Summe vom Wert und den beiden Vorgängern einer bestimmten Position in einem Vektor. Die Subtraktion mit 2 zeigt an, wie viele Werte vor der aktuellen Position berücksichtigt werden sollen.\n\nBeispiel 13.25 (Vorgängersumme für einen Vektor der Länge 10)  \n\nvektor = 1:10\nvektor %*% outer(\n    1:10, \n    1:10, \n    function (a, b) (b &gt;= a & a &gt;= b - 2)\n)\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]    1    3    6    9   12   15   18   21   24    27"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#co-occurence-matrizen",
    "href": "kapitel/matrix-operationen/kapitel.html#co-occurence-matrizen",
    "title": "13  Matrix-Operationen",
    "section": "13.9 Co-Occurence Matrizen",
    "text": "13.9 Co-Occurence Matrizen\nEine Co-Occurence Matrix oder Kontingenztabelle aus zwei Vektoren lässt sich am leichtesten mit der table()-Funktion erstellen. Diese Funktion zählt das gemeinsame Auftreten von Werten in zwei gleichlangen Vektoren von beliebigen Datentyp.\nDas Ergebnis ist eine benannte Matrix, wobei die Zeilen den Werten im ersten Vektor und die Spalten den Werten im zweiten Vektor entsprechen.\n\nBeispiel 13.26 (Kontingenztabelle für zwei Vektoren)  \n\nv1 = c(1, 2, 4, 3, 2, 1, 1, 2, 4)\nv2 = c(9, 8, 7, 7, 7, 8, 9, 9, 8)\n\n(ctable = table(v1, v2))\n\n   v2\nv1  7 8 9\n  1 0 1 2\n  2 1 1 1\n  3 1 0 0\n  4 1 1 0\n\nctable[,2]\n\n1 2 3 4 \n1 1 0 1 \n\nctable[3,]\n\n7 8 9 \n1 0 0"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#determinanten",
    "href": "kapitel/matrix-operationen/kapitel.html#determinanten",
    "title": "13  Matrix-Operationen",
    "section": "13.10 Determinanten",
    "text": "13.10 Determinanten\nDie Determinante einer quadratischen Matrix A wird mit der det()-Funktion ermittelt.\n\nBeispiel 13.27 (Determinante einer Matrix bestimmen)  \n\n# Eine quadratische Matrix aus matrixA erzeugen\n(matrixQ = matrixA %*% t(matrixA))\n\n     [,1] [,2]\n[1,]   14   10\n[2,]   10   14\n\ndet(matrixQ)\n\n[1] 96"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#eigenwerte",
    "href": "kapitel/matrix-operationen/kapitel.html#eigenwerte",
    "title": "13  Matrix-Operationen",
    "section": "13.11 Eigenwerte",
    "text": "13.11 Eigenwerte\nDie Eigenwerte \\lambda und Eigenvektoren einer quadratischen Matrix A werden mit der Funktion eigen() bestimmt. Diese Funktion gibt eine benannte Liste zurück. Unter values finden sich die Eigenwerte der Matrix und unter vectors sind die Eigenvektoren als Spaltenvektoren gespeichert.\n\nBeispiel 13.28 (Eigenwerte und Eigenvektoren einer Matrix bestimmen)  \n\nbasisQ = eigen(matrixQ)\n\nbasisQ[[\"values\"]] # oder basisQ$values\n\n[1] 24  4\n\nbasisQ[[\"vectors\"]] # oder basisQ$vectors\n\n          [,1]       [,2]\n[1,] 0.7071068 -0.7071068\n[2,] 0.7071068  0.7071068"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#inversematrix",
    "href": "kapitel/matrix-operationen/kapitel.html#inversematrix",
    "title": "13  Matrix-Operationen",
    "section": "13.12 Inversematrix",
    "text": "13.12 Inversematrix\nDie Inverse A^{-1} einer quadratischen Matrix A wird in R mit der Funktion solve() bestimmt (Beispiel 13.29).\n\nBeispiel 13.29 (Inverse Matrix berechnen)  \n\nsolve(matrixQ)\n\n           [,1]       [,2]\n[1,]  0.1458333 -0.1041667\n[2,] -0.1041667  0.1458333"
  },
  {
    "objectID": "kapitel/matrix-operationen/kapitel.html#sec-matrix-bibliothek",
    "href": "kapitel/matrix-operationen/kapitel.html#sec-matrix-bibliothek",
    "title": "13  Matrix-Operationen",
    "section": "13.13 Matrix-Bibliothek",
    "text": "13.13 Matrix-Bibliothek\nDas Kreuzprodukt, das äussere Produkt und das Transponieren werden durch R automatisch bereitgestellt. Für komplexere Aufgaben oder sehr grossere Matrizen dient die Bibliothek Matrix (Bates et al., 2023). Diese Bibliothek gehört zur R-Standardinstallation und ist auf jedem System vorhanden. Die Bibliothek stellt alle relevanten Funktionen für Matrix-Operationen, die für mathematische Matrix-Operationen benötigt werden.\nDiese Bibliothek sollte immer geladen werden, wenn sehr grosse Matrizen oder Matrizen mit vielen 0-Werten verwendet werden. Besonders für den zweiten Fall ist die sog. Sparse Matrix (deutsch “dünnbesetzte Matrix”) von besonderer Bedeutung. Eine dünnbesetzte Matrix ist eine Matrix mit vielen 0-Werten, wobei viel “mehr als ein Drittel der Positionen” bedeutet. In solchen Matrizen lässt R die 0-Werte weg, so dass diese Werte keinen Speicher benötigen und keine Berechnungen für die entsprechenden Operationen (insbesondere beim Kreuzprodukt) durchgeführt werden. Abgesehen von dieser speziellen Behandlung der 0-Werte unterscheiden sich dünnbesetzte Matrizen in R nicht von anderen Matrizen.\n\nBeispiel 13.30 (Dünnbesetzte Matrix erzeugen)  \n\nlibrary(Matrix)\n\n\nAttache Paket: 'Matrix'\n\n\nDie folgenden Objekte sind maskiert von 'package:tidyr':\n\n    expand, pack, unpack\n\nMatrix( matrix(c(0, 1, 0, 0, 0, 1, 2, 0, 0), ncol = 3), sparse = TRUE)\n\n3 x 3 sparse Matrix of class \"dgCMatrix\"\n          \n[1,] . . 2\n[2,] 1 . .\n[3,] . 1 .\n\n\n\nDie Matrix-Bibloiothek stellt ausserdem viele Hilfreiche Funktionen für die Arbeit mit Matrizen bereit. Dazu gehören beispielsweise die Funktionen colSums() und rowSums(), mit denen die Spalten- bzw. die Zeilensummen berechnet werden. Beispiel 13.22 und Beispiel 13.21 lassen sich so vereinfachen (Beispiel 13.31).\n\nBeispiel 13.31 (Zeilen- und Spaltensumme mit der Matrix-Bibliothek)  \n\ncolSums(matrixA)\n\n[1] 4 4 4\n\nrowSums(matrixA)\n\n[1] 6 6\n\n\n\nDie Bibliothek stellt ausserdem mit der band()-Funktion eine komfortable Methode für diagonale Band-Matrizen bereit. Eine Bandmatrix heisst eine quadratische Matrix, die ein diagonales Werteband enthält. Mit dieser Funktion lassen sich Band-Matrize für gleitende Summen (Beispiel 13.25) leichter erzeugen (Beispiel 13.32)\n\nBeispiel 13.32 (Vorgängersumme mit der band()-)  \n\nband(Matrix(1, 10, 10, sparse = TRUE), 0, 2)\n\n10 x 10 sparse Matrix of class \"dtCMatrix\"\n                         \n [1,] 1 1 1 . . . . . . .\n [2,] . 1 1 1 . . . . . .\n [3,] . . 1 1 1 . . . . .\n [4,] . . . 1 1 1 . . . .\n [5,] . . . . 1 1 1 . . .\n [6,] . . . . . 1 1 1 . .\n [7,] . . . . . . 1 1 1 .\n [8,] . . . . . . . 1 1 1\n [9,] . . . . . . . . 1 1\n[10,] . . . . . . . . . 1\n\nvektor %*% band(Matrix(1, 10, 10, sparse = TRUE), 0, 2)\n\n1 x 10 Matrix of class \"dgeMatrix\"\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]    1    3    6    9   12   15   18   21   24    27\n\n\n\n\n\n\n\nBates, D., Maechler, M., Jagan, M., Davis, T. A., Oehlschlägel, J., & Riedy, J. (2023). R Package ’Matrix’ (Version 1.6-3). https://cran.r-project.org/package=Matrix"
  },
  {
    "objectID": "kapitel/indizieren-gruppieren/kapitel.html#indizieren",
    "href": "kapitel/indizieren-gruppieren/kapitel.html#indizieren",
    "title": "14  Indizieren und Gruppieren",
    "section": "14.1 Indizieren",
    "text": "14.1 Indizieren\nEs werden drei Arten von Indizes unterschieden:\n\nDer Primärindex, mit dem ein einzelner Datensatz eindeutig identifiziert werden kann.\nFremdschlüssel sind Sekundärindizes für Querverweise auf eine zweite Datenstruktur (eine sog. Indextabelle oder engl. Lookup-Table).\nGruppenindizes sind Sekundärindizes zur Identifikation von Datensätzen mit gemeinsamen Eigenschaften.\n\nWeil ein Index Werte über einen Datensatz enthält, gehört ein Index zum jeweiligen Datensatz und wird über einen Indexvektor in einer Stichprobe abgebildet.\n\n14.1.1 Hashing eines Primärindex\nDie einfachste Technik zur eindeutigen Indizierung ist das Durchnummerieren der Datensätze einer Stichprobe. Bei dieser Technik wird jedem Datensatz eine Nummer zugewiesen. In R verwenden wir dazu die Funktion row_number(). Diese Funktion ist einer Sequenz vorzuziehen, weil diese Funktion auch bei leeren Stichproben fehlerfrei arbeitet.\n\n\n\n\n\n\nWarnung\n\n\n\nIntuitiv würde man beim Durchnummerieren an seine Sequenz von 1:n() denken. Diese Sequenz führt aber für leere Datenrahmen zu Fehlermeldungen. Die Funktion row_number() kann mit leeren Datenrahmen umgehen und erzeugt dieses Problem nicht.\n\n\n\nBeispiel 14.1 (Primärindex erzeugen)  \n\nmtcars |&gt; \n    as_tibble(rownames = \"modell\") -&gt;\n        mtcars_df\n\nmtcars_df |&gt; \n    mutate(\n        nr = row_number()\n    ) -&gt; \n        mtcars_df_nbr\n\n# Nummerierung zeigen\nmtcars_df_nbr |&gt; \n    head()\n\n# A tibble: 6 × 13\n  modell   mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb    nr\n  &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n1 Mazda…  21       6   160   110  3.9   2.62  16.5     0     1     4     4     1\n2 Mazda…  21       6   160   110  3.9   2.88  17.0     0     1     4     4     2\n3 Datsu…  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1     3\n4 Horne…  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1     4\n5 Horne…  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2     5\n6 Valia…  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1     6\n\n\n\n\n\n14.1.2 Hashing zum Gruppieren\nBeim Hashing zum Gruppieren müssen wir Werte erzeugen, die eine Zuordnung zu einer Gruppe oder einen Wert in einer anderen Stichprobe ermöglichen. Die Hashing-Funktion orientiert sich dabei an den konkreten Analyseanforderungen.\nVier gängige Techniken können dabei unterschieden werden:\n\nKodieren (alle Datentypen)\nReihenfolgen bilden durch Ganzzahldivision (nur Zahlen)\nReihenfolgen bilden durch Modulo-Operation (nur Zahlen)\nReihenfolgen durch Anfangsbuchstaben (nur Zeichenketten)\n\n\n14.1.2.1 Beispiel Hashing zum Gruppieren.\nDas folgende Beispiel bildet einen Index, um die Motorisierung der Fahrzeugtypen in der Stichprobe mtcars zu bestimmen. Dabei sollen die Modelle in schwach-, mittel-, stark- und sehr starkmotorisierte Typen unterschieden werden. Die Motorisierung richtet sich dabei zum einen nach der Leistung (hp). Zum anderen richtet sich die Motorisierung nach dem Fahrzeuggewicht (wt), weil für ein schweres Fahrzeug mehr Leistung zum Bewegen benötigt wird als für ein leichtes. Um beide Werte zu berücksichtigen, wird das Verhältnis der beiden Werte bestimmt. Ein Verhältnis ist eine Division. In diesem Fall wird das Gewicht als Nenner verwendet und die Leistung als Zähler. So ergeben sich immer Werte grösser als 1, weil die Leistung immer viel grösser als das Gewicht ist.\nIn diesem Beispiel besteht die Hashing-Funktion aus zwei Teilen:\n\nDas Verhältnis zwischen Leistung und Gewicht wird bestimmt und im Vektor verhaeltnis abgelegt.\nDie Leistungsklassen werden durch Kodieren den oben festgelegten Klassen zugewiesen und im Vektor klasse gespeichert.\n\n\nmtcars_df |&gt; \n    mutate(\n        verhaeltnis = hp/wt, \n        klasse = case_when( \n            verhaeltnis &gt; 60 ~ \"sehr stark\",\n            verhaeltnis &gt; 50 ~ \"stark\", \n            verhaeltnis &gt; 40 ~ \"mittel\", \n            TRUE ~ \"schwach\") \n    ) |&gt;\n    # nur die relevanten Vektoren zeigen\n    select(modell, hp, wt, verhaeltnis, klasse)\n\n# A tibble: 32 × 5\n   modell               hp    wt verhaeltnis klasse    \n   &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;     \n 1 Mazda RX4           110  2.62        42.0 mittel    \n 2 Mazda RX4 Wag       110  2.88        38.3 schwach   \n 3 Datsun 710           93  2.32        40.1 mittel    \n 4 Hornet 4 Drive      110  3.22        34.2 schwach   \n 5 Hornet Sportabout   175  3.44        50.9 stark     \n 6 Valiant             105  3.46        30.3 schwach   \n 7 Duster 360          245  3.57        68.6 sehr stark\n 8 Merc 240D            62  3.19        19.4 schwach   \n 9 Merc 230             95  3.15        30.2 schwach   \n10 Merc 280            123  3.44        35.8 schwach   \n# ℹ 22 more rows\n\n\n\n\n\n14.1.3 Hashing für Querverweise\nBeim Hashing für Querverweise gibt es zwei Stichproben. Die erste Stichprobe ist die Hauptstichprobe mit den eigentlichen Werten. Die zweite Stichprobe ist die Referenzstichprobe, die zusätzliche Informationen enthält. Ein Indexvektor für Querverweise in der ersten Stichprobe bezieht sich immer auf einen Primärindex aus der zweiten Stichprobe.\nDie Hashing-Funktion muss deshalb einen Verweis zur zweiten Stichprobe herstellen. Diese Verbindung kann mit der gleichen Strategie erzeugt werden, wie beim Gruppieren. Dabei muss jedoch darauf geachtet werden, dass alle Zuordnungen des Primärvektors korrekt abgebildet sind."
  },
  {
    "objectID": "kapitel/indizieren-gruppieren/kapitel.html#randomisieren",
    "href": "kapitel/indizieren-gruppieren/kapitel.html#randomisieren",
    "title": "14  Indizieren und Gruppieren",
    "section": "14.2 Randomisieren",
    "text": "14.2 Randomisieren\nWenn wir mit Teilstichproben arbeiten und diese mit anderen teilen, müssen wir vermeiden, dass zwei Stichproben leicht zusammengesetzt werden können und so Rückschlüsse über die Probanden möglich werden.\n\n\n\n\n\n\nAchtung\n\n\n\nSobald personenbezogene Daten statistisch ausgewertet und zur Publikation vorbereitet werden, müssen die Daten randomisiert werden!\n\n\nDieses Rezept beschreibt eine Technik zur Anonymisierung von Daten durch Mischen. Entscheidend bei dieser Technik ist, dass wir die Werte für unsere Analyse zusammenhalten möchten, sodass unsere Ergebnisse nachvollziehbar bleiben. Gleichzeitig soll es unmöglich werden, diese Daten mit anderen Teilen unserer Studien in Verbindung zu bringen.\nDie Technik der Anonymisierung durch Mischen besteht aus vier Schritten:\n\nAuswahl der Vektoren, die wir in einer Publikation teilen möchten,\nErzeugung eines eindeutigen Vektors,\nzufälliges Mischen,\nEntfernen der eindeutigen Vektoren und exportieren der Daten.\n\n\n14.2.1 Schritt 1: Auswahl der Vektoren\nDie zu veröffentlichenden Vektoren werde mit der select()-Funktion selektiert.\n\n\n14.2.2 Schritt 2: Erzeugung eines eindeutigen Vektors\nAlle Werte müssen zusammengehalten werden,damit nachgereihte Analysen nachvollziehbar bleiben. Dazu werden die Datensätze nummeriert.\n\n\n14.2.3 Schritt 3: Mischen\nDieser Schritt greift auf die Funktion sample() zurück. Wir erzeugen aus den ursprünglichen Nummerierungen eine neue Nummerierung durch daten |&gt; mutate( id_neu = sample(id) ). Nach dieser neuen Nummerierung sind unsere Datensätze aber immer noch in der gleichen Reihenfolge und noch nicht gemischt. Wir müssen also die Reihenfolge so anpassen, dass die neue Nummerierung gilt. Das erreichen wir mit dem Funktionsaufruf daten |&gt; arrange( id_neu ).\n\n\n14.2.4 Schritt 4: Entfernen des eindeutigen Vektors und exportieren der Daten\nAbschliessend müssen wir unbedingt die beiden Hilfsvektoren, die wir zum Mischen verwendet haben, aus unserer Stichprobe wieder entfernen. Das erreichen wir mit einer Vektorauswahl: daten |&gt; select(-c(id, id_neu)).\n\n\n14.2.5 Vollständige Lösung\nWir greifen hier auf eine Stichprobe zurück, die Geschlechtsinformationen, Alter und digitale Nutzungsgewohnheiten umfasst. Wir erstellen zwei getrennte Teilstichproben, von denen eine nur die Nutzungsgewohnheiten und das Geschlecht und eine nur die Nutzungsgewohnheiten und das Alter beinhaltet.\n\ndaten = read_csv(\n    \"daten/befragung_digitales_umfeld/befragung.csv\", \n    show_col_types = F)\n\n# mischen Funktion aus einer Funktionskette erstellen, damit \n#    wir nicht so viel tippen müssen.\nmischen = . %&gt;% \n    mutate( \n        id = row_number(), \n        id_neu = sample(id) # wählt zufällig eine id aus.\n    ) %&gt;%\n    arrange(id_neu) %&gt;%\n    select(-c(id, id_neu))\n\ndaten |&gt;\n    select(q00_2, starts_with(\"q15\")) |&gt;\n    mischen() |&gt;\n    write_csv(\"teilstichprobe_geschlecht_technik.csv\")\n\ndaten |&gt;\n    select(kurs, starts_with(\"q18\")) |&gt;\n    mischen() |&gt;\n    write_csv(\"teilstichprobe_alter_sozial.csv\")\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie Definition der Funktion mischen() verwendet die spezielle Funktionsverkettung von tidyverse, weil damit Funktionen erstellt werden können. In diesem Fall dürfen die Operatoren |&gt; und %&gt;% nicht im gleichen Arbeitsschritt gemischt werden.\n\n\nDie Daten in den beiden Dateien lassen sich nicht mehr zusammenführen. Damit erkennen wir auch die Grenzen dieser Technik: Wenn zwei gemischte Stichproben ausreichend viele gemeinsame oder sehr detaillierte Vektoren haben, die in beiden Teilstichproben vorkommen, dann können diese Stichproben trotz mischen wieder zusammengeführt werden.\nMit den gemischten Daten ist es nun nicht mehr möglich, die Werte mit einem anderen Teil der Stichprobe zu kombinieren und so tiefere Rückschlüsse über die Teilnehmenden (womöglich unwissend) zuzulassen. Nur noch durch den Zugriff auf die ursprünglichen Daten können diese Zusammenhänge hergestellt werden. Daher sind die ursprünglichen Daten oft besonders schützenswert und sollten ohne Randomisierung nicht weitergegeben werden."
  },
  {
    "objectID": "kapitel/indizieren-gruppieren/kapitel.html#gruppieren",
    "href": "kapitel/indizieren-gruppieren/kapitel.html#gruppieren",
    "title": "14  Indizieren und Gruppieren",
    "section": "14.3 Gruppieren",
    "text": "14.3 Gruppieren\nIn R lassen sich grundsätzlich alle Opeationen auch als gruppierte Operationen über einen Datenrahmen durchführen. Dazu wird die group_by()-Funktion verwendet, um gruppierte Operationen anzuzeigen. Dieser Funktion können ein oder mehrere Sekundärindizes als Parameter übergeben werden, die zum Gruppieren verwendet werden.\n\nBeispiel 14.2 (Gruppierte Summe und Mittelwert)  \ndaten |&gt; \n    group_by(index) |&gt;\n    summarise(\n        summe = sum(werte)\n        mittelwert = mean(werte)\n    ) |&gt;\n    ungroup() \n\n\n\n\n\n\n\nAchtung\n\n\n\nWird eine Funktion group_by() ohne eine nachfolgende Operation ausgeführt, dann hat die Funktionen keinen erkennbaren Effekt auf das Ergebnis.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nNach eine gruppierten Operation sollte die Gruppierung immer mit ungroup() aufgehoben werden, damit nachfolgende nichtgruppierte Operationen nicht versehentlich als gruppierte Operationen durchgeführt werden.\n\n\n\n14.3.1 Gruppiertes Zählen\nR verfügt mit der Funktion table() das gemeinsame Auftreten von Werten in zwei diskretskalierten Vektoren zu zählen. Diese Funktion erfordert jedoch zwei voneinander unabhängige Vektoren. Die Funktion count() bietet eine elegante Alternative für Vektoren in Datenrahmen. In diesem Fall werden die Vektoren als Sekundärindizes behandelt.\n\nBeispiel 14.3 (Gruppiertes Zählen)  \ndaten |&gt; \n    count(index)\n\nDas gruppierte Zählen hat gegenüber der Funktion table() den Vorteil, dass mehr als zwei Vektoren zusammengefasst werden können.\n\n\n14.3.2 Gruppiertes Nummerieren\nNummerieren ist eine hilfreiche Funktion, um die Position von Werten zu bestimmen. Das Ergebnis ist ein eindeutige Nummer für jeden Datensatz. Beim Gruppierten Nummerieren werden die Datensätze innerhalb ihrer Gruppe nummeriert.\n\nBeispiel 14.4 (Gruppiertes Nummerieren)  \ndaten |&gt;\n    group_by(index) |&gt;\n    mutate(\n        nr = row_number()\n    ) |&gt;\n    ungroup()"
  },
  {
    "objectID": "kapitel/daten-kodieren/kapitel.html#kodierungstabellen",
    "href": "kapitel/daten-kodieren/kapitel.html#kodierungstabellen",
    "title": "15  Daten kodieren",
    "section": "15.1 Kodierungstabellen",
    "text": "15.1 Kodierungstabellen"
  },
  {
    "objectID": "kapitel/daten-kodieren/kapitel.html#mit-faktoren-kodieren",
    "href": "kapitel/daten-kodieren/kapitel.html#mit-faktoren-kodieren",
    "title": "15  Daten kodieren",
    "section": "15.2 Mit Faktoren kodieren",
    "text": "15.2 Mit Faktoren kodieren"
  },
  {
    "objectID": "kapitel/daten-formen/kapitel.html",
    "href": "kapitel/daten-formen/kapitel.html",
    "title": "16  Daten formen",
    "section": "",
    "text": "Work in Progress"
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#universelle-kennwerte",
    "href": "kapitel/daten-beschreiben/kapitel.html#universelle-kennwerte",
    "title": "17  Daten beschreiben",
    "section": "17.1 Universelle Kennwerte",
    "text": "17.1 Universelle Kennwerte\nIn R ergibt sich dieser Wert direkt aus dem Stichprobenobjekt: Der Stichprobenumfang entspricht der Anzahl der Datensätze in unserem Stichprobenobjekt. Diese Anzahl bestimmen wir mit Hilfe der count()-Funktion oder innerrhalb einer Transforrmation mit mutate() mit Hilfe der n()-Funktion.\nDer Stichprobenumfang ist einer der drei allgemeinen Kennwerte, die jede Stichprobe beschreiben. Wir bestimmen zuerst die numerischen Kennwerte unserer Beispielstichprobe.\n# Stichprobenumfang\nstichprobe |&gt; \n    count() |&gt; \n    pull() -&gt; stichprobenumfang\n\nstichprobenumfang\n\nstichprobe |&gt; \n    names() |&gt; \n    length()\nDabei erkennen wir, dass der Stichprobenumfang 27 beträgt. Wir erkennen zusätzlich, dass wir 53 Vektoren in unserem Stichprobenobjekt vorliegen haben.\nNeben dem Stichprobenumfang unterscheiden wir zusätzlich den Variablenumfang. Der Variablenumfang bezeichnet die Anzahl der gemessenen Merkmalsausprägungen. Damit ist die Gesamtzahl der gemessenen Werte für eine Variable gemeint. Für diesen Wert müssen wir für eine Variable nicht vorhandene Werte aus der Variable entfernen. Diese Werte sind in R mit dem Wert NA gekennzeichnet. Wir entfernen die NA-Werte mit Hilfe der drop_na()-Funktion."
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#fehlende-werte",
    "href": "kapitel/daten-beschreiben/kapitel.html#fehlende-werte",
    "title": "17  Daten beschreiben",
    "section": "17.2 Fehlende Werte",
    "text": "17.2 Fehlende Werte\n\n17.2.1 Fehlende Werte entfernen"
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#lagemasse",
    "href": "kapitel/daten-beschreiben/kapitel.html#lagemasse",
    "title": "17  Daten beschreiben",
    "section": "17.3 Lagemasse",
    "text": "17.3 Lagemasse\n\n17.3.1 Modus\n\n\n17.3.2 Median\n\n\n17.3.3 Mittelwert"
  },
  {
    "objectID": "kapitel/daten-beschreiben/kapitel.html#streumasse",
    "href": "kapitel/daten-beschreiben/kapitel.html#streumasse",
    "title": "17  Daten beschreiben",
    "section": "17.4 Streumasse",
    "text": "17.4 Streumasse\n\n17.4.1 Varianz und Standardabweichung\n\n\n17.4.2 Interquatilsabstand\n\n\n17.4.3 MAD"
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#technischer-aufbau-von-visualisierungen",
    "href": "kapitel/daten-visualisieren/kapitel.html#technischer-aufbau-von-visualisierungen",
    "title": "18  Daten visualisieren",
    "section": "18.1 Technischer Aufbau von Visualisierungen",
    "text": "18.1 Technischer Aufbau von Visualisierungen\nIn der ersten Zeile legen wir fest, welche Daten visualisiert werden sollen. Die Grundlage für jede Datenvisualisierung ist immer ein Transformationsergebnis.\nIn der zweiten Zeile signalisieren wir R mit der Funktion ggplot(), dass wir einen Plot erzeugen wollen. Wir übergeben als Parameter das Ergebnis der aes()-Funktion.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Funktion aes() legt die ästhetischen Voraussetzungen für einen Plot fest. Damit legen wir fest, welche Daten für unsere Datenpunkte verwendet werden sollen.\n\n\nIn diesem Beispiel legen wir den Vektor Sepal.Length für die Koordinaten auf der x-Achse und Petal.Length für die Koordinaten auf der y-Achse fest. Die Datenpunkte werden also durch die beiden gemeinsam auftretenden Werte in diesen Vektoren festgelegt.\nMit der dritten Zeile legen wir die Geometrie der Datenpunkte fest. Alle ggplot2-Funktionsnamen zur Darstellung von Datenpunkten beginnen mit geom_ (für Geometrie). In diesem Beispiel wollen wir unsere Datenpunkte mit Punkten (engl. Points) darstellen. Deshalb verwenden wir die Funktion geom_point().\nDiese drei Schritte zeigen die grundsätzliche Logik zum Erstellen von Plots mit R."
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#sec-visualisation-math-func",
    "href": "kapitel/daten-visualisieren/kapitel.html#sec-visualisation-math-func",
    "title": "18  Daten visualisieren",
    "section": "18.2 Mathematische Funktionen visualisieren",
    "text": "18.2 Mathematische Funktionen visualisieren\nIn der Mathematik werden regelmässig Funktionen besprochen. Diese Funktionen können wir mit R leicht visualisieren.\nDabei nutzen wir aus, dass wir in R neue Funktionen mit dem Schlüsselwort function definieren können. Im folgenden Beispiel verwenden wir die beiden Funktionen.\n\nf1(x) \\to x^2 - 3x\n\nund\n\nf2(x) \\to 4x + 2\n\nIm nächsten Schritt erstellen wir unsere beiden mathematischen Funktionen. Dabei beachten wir, dass wir den Namen der jeweiligen Funktion als eine Variable zuweisen müssen. Die rechte Seite der Zuweisung zeigt R an, dass wir eine neue Funktion mit dem Parameter x erstellen möchten. Nach dieser Funktionsdefinition folgt der sog. Funktionskörper in geschweiften Klammern. Hier schreiben wir die Formel unserer Funktion in der ausführlichen Operatorenschreibweise. Anders als bei der mathematischen Schreibweise dürfen wir keine Operatoren weglassen.\n\nf1 = function (x) {\n    x ^ 2 - 3 * x\n}\n\nf2 = function (x) {\n    4 * x + 2\n}\n\nDamit ggplot “weiss”, welches Intervall für x wir darstellen möchten, erzeugen wir eine Stichprobe mit einem Vektor x, der genau zwei Werte hat. Diesen Vektor weisen wir der Variable Darstellungsbereich zu. Wenn wir die Werte symmetrisch angeben, dann landet die 0 auf der x-Achse in der Mitte unseres Diagramms.\n\nDarstellungsbereich = tibble(x = c(-9, 9)) \n\nJetzt können wir unsere Funktion visualisieren. Wir übergeben die Stichprobe im der Variablen Darstellungsbereich an die ggplot()-Funktion und legen mit dem Aufruf der aes()-Funktion mit dem Vektor x die Grenzen für die x-Achse fest. Anschliessend rufen wir die Funktion geom_line() auf, um einen Graphen zu erzeugen. Weil wir keine Werte für die y-Achse haben, legen wir fest, dass wir die y-Werte aus einer Funktion berechnen wollen. Das erreichen wir mit dem Parameter stat = \"function\". Sobald wir diesen Parameter angeben, erwartet die geom_line() Funktion eine Funktion zur Berechnung der y-Werte. Diese Funktion übergeben wir mit dem Parameter fun = f1, wobei f1 eine unserer vorab definierten Funktionen ist.\n\nDarstellungsbereich |&gt;\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f1)\n\n\n\n\nDiesen Schritt können wir für die Funktion f2 wiederholen.\n\nDarstellungsbereich |&gt;\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f2)\n\n\n\n\nWeil wir mit ggplot Darstellungen überlagern können, dürfen wir die beiden Funktionen selbstverständlich auch in einem Diagramm darstellen.\n\nDarstellungsbereich |&gt;\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f1) + \n        geom_line(stat = \"function\", fun = f2)\n\n\n\n\nWir wollen die beiden Graphen noch visuell hervorheben, damit wir wissen, welcher Graph zu welcher Funktion gehört. Dabei überlassen wir die Auswahl der Farben ggplot, womit wir sicherstellen, dass die Farben nicht zu ähnlich sind. Dazu verwenden wir den Trick, dass wir jeder Geometrie-Funktion ergänzende ästhetische Parameter übergeben dürfen.\n\nDarstellungsbereich |&gt;\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f1, \n                  aes(colour = \"f1(x) = x ^ 2 - 3 * x\")) + \n        geom_line(stat = \"function\", fun = f2, \n                  aes(colour = \"f2(x) = 4 * x + 2\"))\n\n\n\n\nDie Legende für unser Diagramm hat keine schöne Überschrift. Das passen wir noch schnell mit der labs()-Funktion(für labels bzw. Beschriftungen) an. Dort geben wir für den ästhetischen Parameter die richtige Beschriftung an. In unserem Fall ist das colour.\n\nDarstellungsbereich |&gt;\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f1, \n                  aes(colour = \"f1(x) = x ^ 2 - 3 * x\")) + \n        geom_line(stat = \"function\", fun = f2, \n                  aes(colour = \"f2(x) = 4 * x + 2\")) +\n        labs(colour = \"Funktion\")"
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#berechnete-visualisierungen",
    "href": "kapitel/daten-visualisieren/kapitel.html#berechnete-visualisierungen",
    "title": "18  Daten visualisieren",
    "section": "18.3 Berechnete Visualisierungen",
    "text": "18.3 Berechnete Visualisierungen\nWir haben im Abschnitt zu einfachen Visualisieren in R die Funktion ggplot() kennengelernt, um zwei Vektoren zu visualisieren.\nSehr häufig wir einen Vektor und wollen sehen, wie die Werte in diesem Vektor verteilt sind. Wir sollen also die Werte in dem Vektor für die Visualisierung aggregieren. Hierbei handelt es sich um eine so häufige Aufgabe, dass uns ggplot() diese Aufgabe abnimmt.\nFür verschiedene Visualisierungen hat ggplot() vordefinierte Funktionen, mit denen Werte für die Visualisierung aufbereitet werden, wenn die Werte für eine Achse fehlen. Diese Funktionen müssen wir im Detail nicht kennen, denn ggplot() wählt diese automatisch für uns aus.\nWir lernen heute zwei wichtige berechnete Visualisierungen kennen.\n\nDas Histogramm\nDen Box-Plot\n\n\n18.3.1 Histogramm\n\nDefinition 18.1 Als Histogramm werden Balkendiagramme bezeichnet, die die Häufigkeiten von gemessenen Werte darstellen.\n\nDas übliche Balkendiagramm erzeugen wir mit der Funktion geom_bar(). Diese Funktion verwenden wir immer, wenn unsere gemessenen Werte nur auf bestimmte Werte fallen (können). Die geom_bar()-Funktion zählt für jeden gemessenen Wert die Anzahl der Datensätze, in denen dieser Wert vorkommt.\nGelegentlich sind unserer Werte so verteilt, dass nur selten zwei oder mehr Datensätze gleiche Werte haben. In solchen Fällen verwenden wir die Funktion geom_histogram(). Diese Funktion teilt den gesamten Wertebereich in gleichmässige Intervalle und zählt die Anzahl der Datensätze im jeweiligen Intervall.\nDas folgende Beispiel veranschaulicht die Situation.\nWir verwenden die Stichprobe digitales_umfeld1.csv. In dieser Stichprobe gibt es den Vektor tage, der das Alter der beantwortenden Person in Tagen festhält. Dabei handelt es sich rein formell um diskrete Werte. Wenn wir die Verteilung dieser Werte in einem Histogramm für diskrete Werte darstellen würden, dann erhalten wir das folgende Histogramm:\n\ndigitales_umfeld = read_csv(\"befragung_digitales_umfeld/digitales_umfeld1.csv\")\n\nRows: 135 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): mobilgeraet\ndbl (4): alter, tage, monate, digitalisiert\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ndigitales_umfeld |&gt; \n    ggplot(aes(x = tage)) +\n        geom_bar()\n\n\n\n\nAbbildung 18.1: Tage-Histogram Diskrete Werte\n\n\n\n\nAuf diesem Histogramm kann man keine Verteilung erkennen. Es scheint, als ob alle Werte genau einmal vorkommen. Der Wertebereich der y-Achse deutet aber darauf hin, dass einzelne Werte bis zu drei Mal vorkommen. Diese Balken sind jedoch so dünn, dass sie nicht im Diagramm dargestellt werden können.\nDie Werte in diesem Vektore verhalten sich also wie kontinuierliche Werte. Deshalb verwenden wir die Funktion geom_histogram(), um die Daten darzustellen.\n\ndigitales_umfeld |&gt; \n    ggplot(aes(x = tage)) +\n        geom_histogram()\n\n\n\n\nAbbildung 18.2: Tage-Histogram\n\n\n\n\nAus diesem Histogramm können wir wesentlich besser die Verteilung des Alters in Tagen ablesen, weil der Wertebereich in grössere Segmente gegliedert wurde und die Datensätze in diesen Segmenten gezählt wurden.\n\n\n\n\n\n\nMerke\n\n\n\nHistogramme für kontinuierliche Werte erzeugen wir mit der Funktion geom_histogram(). Histogramme für diskrete Werte erzeugen wir mit der geom_bar()-Funktion.\n\n\n\n18.3.1.1 Histogramme selbst berechnen\nGelegentlich haben uns bereits die Häufigkeiten für ein Histogramm als Teil unserer Stichproben. In solchen Fällen verwenden wir die Funktion geom_col(), um die Daten als Histogramm darzustellen. In diesem Fall müssen wir neben der x-Achse auch den Vektor mit den berechneten Werten für die y-Achse an ggplot()’s aes()-Funktion übergeben.\n\n\n\n18.3.2 Box-Plot\n\nDefinition 18.2 Ein Box-Plot stellt die Verteilung eines Stichprobenvektors mit Hilfe von Quartilen dar.\n\nBox-Plots werden mit der geom_boxplot() Funktion dargestellt.\nBeim Box-Plot wird der Median als dicke Linie dargestellt. Der Interquartilsabstand wird als Rechteck (Box) um den Median visualisiert (2. und 3. Quartil). Dabei liegt die Hälfte der aller gemessenen Werte innerhalb der dargestelltn Box. Der gesamte Umfang wird durch Linien links (1. Quartil) und rechts (4. Quartil) vom Interquartilsabstand dargestellt. Manchmal werden Punkte an den äusseren Rändern dargestellt. Diese Punkte stellen sog. Ausreisser dar.\nWiederholen wir die Visualisierung für unsere Alterstage mit einem Boxplot, dann erhalten wir folgendes Ergebnis:\n\ndigitales_umfeld |&gt; \n    ggplot(aes(x = tage)) +\n        geom_boxplot()\n\n\n\n\nAbbildung 18.3: Tage-Boxplot\n\n\n\n\nWir erkennen jetzt leicht, dass der Grossteil der Gruppe unter 10000 Tagen alt ist und dass es sechs Ausreisser gibt, die deutlich älter als der Grossteil der Gruppe sind.\n\n\n18.3.3 Punkt- und Jitter-Diagramme\nDie dritte wichtige visuelle Analysetechnik sind Punktwolken. Bei Punktwolken stellen wir die Werte von zwei Vektoren ähnlich einer Kreuztabelle gegenüber und überprüfen das gemeinsame Auftreten von Werten in den Vektoren unserer Messungen.\nFür Punktwolken stehen zwei Funktionen zur Verfügung:\n\ngeom_point() für kontinuierliche Werte.\ngeom_jitter() für diskrete Werte.\n\nMit Punktdiagrammen werden zwei Merkmale mit kontinuierlichen Daten gegenübergestellt. Punktdiagramme bilden Beziehungen zwischen Merkmalen ab.\n\niris |&gt;\n    ggplot(aes(x = Sepal.Length, y = Sepal.Width)) +\n        geom_point()\n\n\n\n\nAbbildung 18.4: Punktdiagramm der iris-Daten\n\n\n\n\n\ndaten = read_csv(\"befragung_digitales_umfeld/befragung.csv\");\n\ndaten |&gt;\n    filter(q18_6 &gt; 0 & \n           q18_7  &gt; 0 ) |&gt;\n    ggplot(aes(x = q18_6 , \n               y = q18_7)) + \n        geom_point()\n\n\n\n\nAbbildung 18.5: Beispiel eines Punktdiagramms mit diskreten Daten\n\n\n\n\nIn diesem Beispiel sehen wir, dass alle Werte genau an den gleichen Punkten im Koordinatensystem liegen. Ein solcher Plot ist ein gutes Beispiel für diskrete Werte. Bei diskreten Werten fallen alle Messungen genau auf bestimmte Punkte im Wertebereich. Kontinuierliche Werte weichen oft ein wenig voneinander ab, sodass wir eine Wolke sehen würden.\nUm Punktwolken für diskrete Werte zu erzeugen, verwenden wir die geom_jitter()-Funktion. Diese Funktion erzeugt einen kleinen Bereich um den diskreten (echten) Messwert und verteilt die einzelnen Datensätze mit einem zufälligen Abstand vom echten Messwert. Dadurch wird das gemeinsame Auftreten von Werten deutlich sichtbar, sofern es Gemeinsamkeiten gibt.\n\ndaten |&gt;\n    filter(q18_6 &gt; 0 & \n           q18_7  &gt; 0 ) |&gt;\n    ggplot(aes(x = q18_6 , \n               y = q18_7)) + \n        geom_jitter()\n\n\n\n\nAbbildung 18.6: Beispiel eines Jitter-Diagramms\n\n\n\n\nDurch den leichten Versatz sind nun gehäufte Wertepaare leichter zu erkennen. Bei Jitter-Plots dürfen wir aber nie vergessen, dass die Punkte zwar Messungen repräsentieren, aber leicht vom echten Messpunkt versetzt dargestellt wurden.\n\n\n18.3.4 Ausgleichsgeraden\nIm vorigen Abschnitt können wir eine Häufung entlang der nach rechts aufsteigenden Diagonalen erkennen. Solche Häufungen in Punktwolken deuten auf Korrelationen hin.\n\nDefinition 18.3 Eine Korrelation bezeichnet das wiederholte Auftreten von Wertepaaren in Stichproben. Korrelationen deuten auf Zusammenhänge zwischen zwei Vektoren hin.\n\nÄhnlich wie beim Vergleichen mit Histogrammen ist es bei Punktwolken hilfreich, für die Wolke eine Referenz zur Orientierung zu haben. Das erreichen wir mit der geom_smooth()-Funktion. Die Methode lm steht für “lineares Modell”. In diesem Modell versteckt sich das Wort Linie und deshalb erzeugt ein lineares Modell immer eine Ausgleichsgerade. Der graue Bereich zeigt uns die Spanne des Fehlerbereichs für diese Gerade. Bei einer linearen Korrelation sollte diese Gerade den Häufungen in unserem Plot ungefähr folgen.\n\ndaten |&gt;\n    filter(q18_6 &gt; 0 & \n           q18_7  &gt; 0 ) |&gt;\n    ggplot(aes(x = q18_6 , \n               y = q18_7)) + \n        geom_jitter() +\n        geom_smooth(method=lm)\n\n\n\n\nAbbildung 18.7: Beispiel eines Jitter-Diagramms mit Ausgleichsgerade\n\n\n\n\nDas folgende Beispiel zeigt eine Punktwolke, bei der die Wertepaare zufällig über den gesamten Wertebereich gestreut sind. In diesem Fall ist eine Korrelation kaum wahrscheinlich.\n\ndaten |&gt;\n    filter(q18_3 &gt; 0 & \n           q18_29  &gt; 0 ) |&gt;\n    ggplot(aes(x = q18_3 , \n               y = q18_29)) + \n        geom_jitter() +\n        geom_smooth(method=\"lm\")\n\n\n\n\nAbbildung 18.8: Beispiel eines Jitter-Diagramms mit flacher Ausgleichsgerade\n\n\n\n\nIm Beispiel ist die Ausgleichsgerade fast waagerecht. Wenn eine Ausgleichsgerade fast waagerecht ist, dann liegt in der Regel auch keine Korrelation vor.\nEs gibt auch nicht-lineare Korrelationen. In diesem Fall sehen wir Häufungen in bestimmten Teilen unserer Punktwolken oder unsere Punkte folgen einer Kurve. Solche Korrelationen müssten einer entsprechenden “Ausgleichskurve” folgen. Eine solche Ausgleichskurve erzeugen wir mit loess als Ausgleichsmethode.\nWenn eine Ausgleichskurve fast gerade ist, dann sollten wir eine lineare Korrelation annehmen. Ein Beispiel für eine fast gerade Ausgleichskurve zeigt uns der nächste Plot.\n\ndaten |&gt;\n    filter(q18_3 &gt; 0 & \n           q18_29  &gt; 0 ) |&gt;\n    ggplot(aes(x = q18_3 , \n               y = q18_29)) + \n        geom_jitter() +\n        geom_smooth(method = \"loess\")\n\n\n\n\nAbbildung 18.9: Beispiel eines Jitter-Diagramms mit nicht linearer Ausgleichslinie"
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#mehrdimensionale-plots-mit-aes",
    "href": "kapitel/daten-visualisieren/kapitel.html#mehrdimensionale-plots-mit-aes",
    "title": "18  Daten visualisieren",
    "section": "18.4 Mehrdimensionale Plots mit aes",
    "text": "18.4 Mehrdimensionale Plots mit aes\n\n18.4.1 Farbkodierung\nMit der Farbkodierung können zusätzliche Merkmale in einer Visualisierung kodiert werden. ggplot unterscheidet für die Farbkodierung zwischen diskreten und kontinuierlichen Daten. Bei diskreten Daten verwendet R Farben, die sich gut voneinander unterscheiden lassen. Bei kontinuierlichen Daten werden Farbverläufe zwischen mehreren Farben verwendet. Ausserdem hängt die Färbung von der Art der Visualisierung ab. Flächige Darstellungselemente, wie die Balken von Balkendiagrammen, wird eine Füllfarbe gesetzt. Die Füllfarbe wird über die Ästhetik fill kontrolliert. Darstellungselemente wie Linien oder Punkte wird eine Linienfarbe gesetzt. Die Linienfarbe wird über die Ästhetik colour festgelegt.\n\n\n\n\n\n\nMerke\n\n\n\nDie Färbung von Punkten wird über die Linienfarbe gesteuert.\n\n\n\niris |&gt;\n    ggplot(aes( x = Sepal.Length, \n                y = Sepal.Width, \n1                colour = Species)) +\n        geom_point()\n\n\n1\n\nFarbliche Hervorhebung\n\n\n\n\n\n\n\nAbbildung 18.10: Punktdiagramm der iris-Daten mit farblich hervorgehobenen Spezieswerten\n\n\n\n\nBalkendiagramme und Histogramme benötigen eine Flächenfärbung.\n\niris |&gt;\n    ggplot(aes( x = Sepal.Length, \n1                fill = Species)) +\n        geom_histogram()\n\n\n1\n\nFarbliche Hervorhebung\n\n\n\n\n\n\n\nAbbildung 18.11: Histogramm der iris-Daten mit farblich hervorgehobenen Spezieswerten\n\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nWenn Histogramme oder Balkendiagramme eine zusätzliche farbliche Kodierung erhalten, verbirgt eine gestapelte Balkendarstellung die Verteilungen. Mit dem Parameter position lässt sich die Positionierung der Balken steuern. Dies wird beispielsweise durch die Funktion position_dodge() vereinfacht.\n\n\n\niris |&gt;\n    ggplot(aes( x = Sepal.Length, \n1                fill = Species)) +\n2        geom_histogram(position = position_dodge())\n\n\n1\n\nFarbliche Hervorhebung\n\n2\n\nPositionierung der hervorgehobenen Balken\n\n\n\n\n\n\n\nAbbildung 18.12: Histogramm der iris-Daten mit farblich hervorgehobenen Spezieswerten\n\n\n\n\nDie Ästhetik kann auch in den Geometriefunktionen angepasst werden. Wird hier für die Farbästhetik jeweils ein einzelner Wert angegeben, erzeugt ggplot() einen Vektor mit diskreten Werten und weist die Farben dynamisch zu.\n\nDarstellungsbereich |&gt;\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", \n                  fun = f1, \n1                  aes(colour = \"f1(x) = x ^ 2 - 3 * x\")) +\n        geom_line(stat = \"function\", \n                  fun = f2, \n2                  aes(colour = \"f2(x) = 4 * x + 2\")) +\n        labs(colour = \"Funktion\")\n\n\n1\n\nFarbliche Hervorhebung der ersten Funktion\n\n2\n\nFarbliche Hervorhebung der zweiten Funktion\n\n\n\n\n\n\n\nAbbildung 18.13: Angepasste Ästhetik mit Einzelwerten in Geometriefunktionen\n\n\n\n\n\n\n\n\n\n\nWarnung\n\n\n\nggplot unterstützt Farbcodes zur Konfiguration von Füll- und Linienfarben ausserhalb der normalen Ästhetikparameter. Mit diesen Farbcodes wird die normale Füll- oder Linienfarbe auf eine andere Farbe geändert. Diese Methode zur Anpassung von Farbe sollte vermieden werden, weil für solche Farben keine Legende erzeugt wird.\n\n\n\n\n18.4.2 Grössenkodierung\n\n\n\n\n\n\nMerke\n\n\n\nDie Grössenkodierung eignet sich am Besten für kontinuierliche Daten.\n\n\n\n\n\n\n\n\nMerke\n\n\n\nDie Grössenkodierung lässt sich auf Linien oder Punkte anwenden. Flächen lassen sich nicht zusätzlich grössenkodieren, weil sie bereits Werte über die Grösse kodieren.\n\n\nDie Grössenkodierung von Punkten erfolgt über die Ästhetik size. Auf diese Weise werden Bubble-Charts (Blasendiagramme) erstellt.\n\nread_csv(\"geschlechter_schweizer_staedte.csv\") -&gt; \n    geschlechteranteile_ch\n\ngeschlechteranteile_ch |&gt;\n    ggplot(aes(x = S, y = N, size = Gesamt)) + \n        geom_point() +\n        xlab(\"Männeranteil der ständigen Wohnbevölkerung\") +\n        ylab(\"Manneranteil der nicht-ständigen Wohnbevölkerung\")\n\n\n\n\nAbbildung 18.14: Grössenkodierung am Beispiel des Männeranteils in Schweizer Städten\n\n\n\n\nDie Grössenkodierung von Linien erfolgt über die Ästhetik linewidth. Die Linienbreite funktioniert analog zur Punktgrösse im Punktdiagramm.\n\n\n\n\n\n\nMerke\n\n\n\nDie Ästhetik size wird in Kombination mit geom_point(), geom_text() oder geom_label() verwendet.\nDie Ästhetik linewidth wird in Kombination mit geom_line() verwendet.\n\n\n\n\n18.4.3 Formkodierung\nDie Formkodierung kodiert die Werte einer Variable über die Form (engl. shape).\n\n\n\n\n\n\nMerke\n\n\n\nDie Formkodierung eignet sich nur für diskrete Daten!\n\n\n\n\n\n\n\n\nMerke\n\n\n\nDie Formkodierung kann nur ein Punkt- oder Jitter-Diagramm ergänzen.\n\n\nDie Formkodierung erfolgt über die Ästhetik shape.\n\nmtcars |&gt; \n    mutate(am = am |&gt; factor()) |&gt;\n    ggplot(aes(\n        x = mpg, \n        y = hp, \n1        shape = am\n    )) + \n    geom_point()\n\n\n1\n\nFormkodierung über das Merkmal am.\n\n\n\n\n\n\n\nAbbildung 18.15: Anwendung von facet_wrap()\n\n\n\n\nEine Variante der Formkodierung ist die Linienart. Die Kodierung der Linienart erfolgt äber die Ästhetik linetype. Diese Formatierung prinzipiell mit allen Diagrammentypen verwendet werden, die Linien darstellen. Für Boxplots oder Balkendiagramme sollte eine Kodierung über die Linienart vermieden werden.\n\niris |&gt;\n    ggplot(aes(x = Sepal.Length, \n               y = Sepal.Width, \n               linetype = Species)) +\n        geom_point() +\n        geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nAbbildung 18.16: Kodierung über Linienarten\n\n\n\n\nEine weitere Variante der Formkodierung sind Textmarkierungen. Textmarkierungen werden über die Ästhetik label zugewiesen. Für eine Textmarkierung wird der Wert des gewählten Merkmals im Diagramm angezeigt.\n\ngeschlechteranteile_ch |&gt;\n    ggplot(aes(x = S, y = N, label = Ort)) +\n        geom_text() +\n        xlab(\"Männeranteil der ständigen Wohnbevölkerung\") +\n        ylab(\"Manneranteil der nicht-ständigen Wohnbevölkerung\")\n\n\n\n\nAbbildung 18.17: Textmarkierungen über den Männeranteil an der ständigen und nicht-ständigen Wohnbevölkerung Schweizer Städte\n\n\n\n\n\n\n18.4.4 Facetted Plots\nEin Facetted Plot gliedern die Darstellung von Werten in mehrere Teildiagramme. Diese Teildiagramme enthalten in der Regel nur die Werte\n\n\n\n\n\n\nMerke\n\n\n\nFacetten können nur mit diskreten Daten erstellt werden!\n\n\nFacetten sind keine Ästhetik, sondern eine Steuerung.\n\nmtcars |&gt; \n    ggplot(aes(mpg, hp)) + \n    geom_point() +\n1    facet_wrap(~ gear)\n\n\n1\n\nFacetten folgen den Werten des Merkmals gear.\n\n\n\n\n\n\n\nAbbildung 18.18: Anwendung von facet_wrap()\n\n\n\n\nEine Variante von facet_wrap() ist facet_grid(). Diese Funktion erstellt eine visuelle Matrix entlang der Werte zweier diskreter Merkmale.\n\nmtcars |&gt; \n    ggplot(aes(mpg, hp)) + \n    geom_point() +\n1    facet_grid(carb ~ gear)\n\n\n1\n\nFacetten über die Werte der Merkmale gear (horizontal) und carb (vertikal).\n\n\n\n\n\n\n\nAbbildung 18.19: Anwendung von facet_grid()"
  },
  {
    "objectID": "kapitel/daten-visualisieren/kapitel.html#spezielle-visualisierungen",
    "href": "kapitel/daten-visualisieren/kapitel.html#spezielle-visualisierungen",
    "title": "18  Daten visualisieren",
    "section": "18.5 Spezielle Visualisierungen",
    "text": "18.5 Spezielle Visualisierungen\n\n18.5.1 Donut-Diagramme\n\n\n\n\n\n\nWichtig\n\n\n\nTortendiagramme und Donut-Diagramme werden oft falsch interpretiert, weil Kreisflächen schwerer verglichen werden können als die Höhen von Balken. Sie sollten nur zur Illustration, aber nie zur Argumentation verwendet werden.\n\n\nR kann auch Plots erstellen, die nur einen Datenvektor umfassen. In diesem Fall wird der zweite Vektor für die y-Achse aus den Werten des Vektors berechnet. Diese Möglichkeit haben wir schon bei der Erstellung von Histogrammen kennengelernt.\nNehmen wir das folgende Beispiel: Wir erstellen ein Stichprobenobjekt mit einem Vektor q00_demo_gen, der die Werte 1 : Keine Angabe, 2 : Weiblich und 3 : Männlich enthält.\n\ndaten2 = tibble(\n    q00_demo_gen = c(\"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"1 : Keine Angabe\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\")\n)\n\nUns interessiert nun: Wie oft kommen die drei möglichen Werte in unserer Stichprobe vor?\nWir können die Werte mit count() selbst berechnen oder ggplot die Arbeit überlassen. Anstelle der geom_col()-Funktion verwenden wir nun die geom_bar()-Funktion. geom_bar() erwartet einen Vektor für die x-Achse und berechnet für die y-Achse das Auftreten der Werte, so wie wir es mit der count()-Funktion auch bestimmen würden.\n\ndaten2 |&gt;\n    count(q00_demo_gen)\n\n# A tibble: 3 × 2\n  q00_demo_gen         n\n  &lt;chr&gt;            &lt;int&gt;\n1 1 : Keine Angabe     1\n2 2 : Weiblich        95\n3 3 : Männlich       104\n\ndaten2 |&gt;\n    ggplot(aes(x = q00_demo_gen)) +\n        geom_bar()\n\n\n\n\nMit diesem Plot können wir die Unterschiede in unserer Werteverteilung leichter erkennen.\nFür Präsentationen ist so ein Plot aber nicht wahnsinnig attraktiv. Färben wir den Plot also ein. Das machen wir, indem wir den Vektornamen auch für die Füllung der Balken verwenden. ggplot wählt nun für jeden Wert in diesem Vektor eine eigene Farbe aus. Dadurch färben sich unsere Balken ein.\n\ndaten2 |&gt;\n    ggplot(aes(x=q00_demo_gen, fill = q00_demo_gen)) +\n        geom_bar()\n\n\n\n\nFür Histogramme verwenden wir normalerweise ein kartesisches Koordinatensystem. Wir können aber auch ein anderes Koordinatensystem wählen. Eine Variante sind polare Koordinaten. Mit einem polaren Koordinatensystem erreichen wir kreisförmige Darstellungen. Wir müssen dazu die Dimension, die auf das Zentrum des Diagramms zeigt, festlegen und als Parameter übergeben. In unserem Fall ist das die y-Dimension.\nWir stellen unsere Daten in einem polaren Koordinatensystem dar, indem wir mit der coord_polar()-Funktion ggplot mitteilen, dass wir ein anderes Koordinatensystem wünschen.\n\ndaten2 |&gt;\n    ggplot(aes(x=q00_demo_gen, fill = q00_demo_gen)) +\n        geom_bar() +\n        coord_polar(\"y\") \n\n\n\n\nUnser Plot hat jetzt unschöne Beschriftungen. Die werden wir mit einem Formatierungsthema los. ggplot hat verschiedenen Formatierungen als Thema vordefiniert. Eines davon ist das Thema void. Diese Formatierung entfernt alle Hintergründe, Achsen und Beschriftungen ausser Legenden.\n\ndaten2 |&gt;\n    ggplot(aes(x=q00_demo_gen, fill = q00_demo_gen)) +\n        geom_bar() +\n        coord_polar(\"y\") +\n        theme_void()\n\n\n\n\nDas sieht doch gleich viel besser aus.\n\n\n\n\n\n\nHinweis\n\n\n\nSolche ringartigen Visualisierungen werden als Zielscheiben- oder Donut-Diagramme bezeichnet.\n\n\n\n\n18.5.2 Torten-Diagramme\nFür Torten- bzw. Kreisdiagramme müssen alle Balken eines Balkendiagramms übereinander gestapelt werden. Das erreichen wir, indem wir für die x-Achse einen konstanten Wert angeben. Z.B. nehmen wir dazu die leere Zeichenkette. So werden merkwürdige Beschriftungen im Diagramm vermieden. Damit wir die Balken auseinanderhalten können, färben wir sie ein.\n\ndaten2 |&gt;\n    ggplot(aes(x =\"\", fill = q00_demo_gen)) +\n        geom_bar() \n\n\n\n\nMit der Funktion coord_flip werden die Achsen vertauscht und das Diagramm gedreht.\n\ndaten2 |&gt;\n    ggplot(aes(x =\"\", fill = q00_demo_gen)) +\n        geom_bar() +\n        coord_flip()\n\n\n\n\nWir erkennen nun deutlich, dass ggplot immer versucht möglichst viel Fläche zu nutzen.\nDas Interessante an dieser Darstellung ist aber nicht dieses Format, sondern dass wir dieses Diagramm ebenfalls in einem polaren Koordinatensystem darstellen können.\n\ndaten2 |&gt;\n    ggplot(aes(x =\"\", fill = q00_demo_gen)) +\n        geom_bar() +\n        coord_polar(\"y\") + \n        theme_void()\n\n\n\n\nAuf diese Weise erzeugen wir Tortendiagramme."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referenzen",
    "section": "",
    "text": "American Mathematical Society, & LATEX Project. (2020). User’s\nguide for the amsmath package. http://mirrors.ctan.org/macros/latex/required/amsmath/amsldoc.pdf\n\n\nBates, D., Maechler, M., Jagan, M., Davis, T. A., Oehlschlägel, J.,\n& Riedy, J. (2023). R package ’matrix’ (Version 1.6-3). https://cran.r-project.org/package=Matrix\n\n\nGrolemund, G. (2014). Introduction to r markdown. https://rmarkdown.rstudio.com/articles_intro.html\n\n\nHøgholm, M., & Madsen, L. (2022). Mathtools – mathematical tools\nto use with amsmath. https://ctan.org/pkg/mathtools?lang=en\n\n\nJupyter Development Team. (2015). The notebook file format. https://nbformat.readthedocs.io/en/latest/format_description.html\n\n\nPosit Software PBC. (2023). Quarto. https://quarto.org/\n\n\nTeam, R. C., Maechler, M., Gentleman, R., Ihaka, R., Venables, W. N.,\n& Smith, D. M. (2023). An introduction to r. https://cran.r-project.org/doc/manuals/R-intro.html\n\n\nThe Jupyter Book Community. (2023). Jupyter book. https://jupyterbook.org\n\n\nWickham, H. (2023a). Forcats: Tools for working with categorical\nvariables (factors). https://forcats.tidyverse.org/\n\n\nWickham, H. (2023b). Stringr: Simple, consistent wrappers for common\nstring operations. https://stringr.tidyverse.org"
  }
]